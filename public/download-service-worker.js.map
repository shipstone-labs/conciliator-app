{
  "version": 3,
  "sources": ["../node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/decode.js", "../node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/encode.js", "../node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/iterators.js", "../node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/index.js", "../app/workers/car-streaming-format.ts", "../app/workers/lit-key-manager.ts", "../app/workers/download-service-worker.ts"],
  "sourcesContent": ["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value << BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n", "import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value >= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value & BigInt(0xff)));\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, skipValues) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n", "import { Encoder } from './encode.js'\nimport { Decoder } from './decode.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - cbor-x Encoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function encodeIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return encodeIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return encodeIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * encodeIterSync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\nasync function * encodeIterAsync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for await (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - Decoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function decodeIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const decoder = new Decoder(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = decoder.decodeMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\n", "export { Encoder, addExtension, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './encode.js'\nexport { Tag, Decoder, decodeMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled, setSizeLimits } from './decode.js'\nexport { decodeIter, encodeIter } from './iterators.js'\n", "/**\n * CAR-based streaming format that supports efficient range requests\n *\n * Instead of packaging all encrypted chunks in a single CBOR file,\n * we create a manifest + separate chunk files approach:\n *\n * 1. Manifest file (small CBOR file) contains:\n *    - LIT protocol metadata\n *    - Chunk metadata with CIDs\n *    - File metadata\n *\n * 2. Individual chunk files:\n *    - Each chunk stored as separate CAR/raw file\n *    - Enables direct range requests to IPFS gateway\n *    - Only requested chunks are fetched\n */\n\n// Export the chunk size constant\nexport const CHUNK_SIZE = 1024 * 1024 // 1MB chunks\n\nexport interface ChunkInfo {\n  cid: string // CID of the encrypted chunk\n  offset: number // Byte offset in original file\n  size: number // Original chunk size\n  encryptedSize: number // Encrypted chunk size\n  counter: number // AES-CTR counter for this chunk\n}\n\nexport interface ManifestV3 {\n  version: 'LIT-ENCRYPTED-V3'\n  network: string\n  contractName: string\n  contract: `0x${string}`\n  to: `0x${string}`\n  dataToEncryptHash: `0x${string}`\n  unifiedAccessControlConditions: any[]\n  fileMetadata: {\n    name: string\n    size: number\n    type: string\n    chunkSize: number\n  }\n  chunks: ChunkInfo[]\n  created: number\n}\n\n// V4: Public wrapper with access control conditions\nexport interface ManifestV4 {\n  version: 'LIT-ENCRYPTED-V4'\n  accessControlConditions: any[] // Cleartext - needed for LIT to decrypt\n  encryptedManifest: string // LIT-encrypted manifest data\n  created: number\n}\n\n// V4: Encrypted manifest (contains everything including key)\nexport interface MetadataV4 {\n  symmetricKey: Uint8Array // The actual AES key\n  iv: Uint8Array // IV for file decryption\n  fileHash: `0x${string}` // Hash of original file\n  dataToEncryptHash: `0x${string}` // Hash of the symmetric key\n  fileMetadata: {\n    name: string\n    size: number\n    type: string\n    chunkSize: number\n  }\n  chunks: ChunkInfo[] // All chunk information\n}\n\n/**\n * Calculate byte range needed from a specific chunk\n */\nexport function getChunkByteRange(\n  chunk: ChunkInfo,\n  requestedStart: number,\n  requestedEnd: number\n): { start: number; end: number } | null {\n  const chunkEnd = chunk.offset + chunk.size - 1\n\n  // Check if this chunk overlaps with requested range\n  if (chunk.offset > requestedEnd || chunkEnd < requestedStart) {\n    return null\n  }\n\n  // Calculate the byte range within this chunk\n  const start = Math.max(0, requestedStart - chunk.offset)\n  const end = Math.min(chunk.size - 1, requestedEnd - chunk.offset)\n\n  return { start, end }\n}\n\n/**\n * Get chunks needed for a byte range with their internal ranges\n */\nexport function getChunksForByteRange(\n  manifest: ManifestV3,\n  start: number,\n  end: number\n): Array<{ chunk: ChunkInfo; start: number; end: number }> {\n  const needed: Array<{ chunk: ChunkInfo; start: number; end: number }> = []\n\n  for (const chunk of manifest.chunks) {\n    const range = getChunkByteRange(chunk, start, end)\n    if (range) {\n      needed.push({ chunk, ...range })\n    }\n  }\n\n  return needed\n}\n\n/**\n * Create a manifest for uploaded chunks\n */\nexport async function createManifestV3(\n  metadata: Omit<ManifestV3, 'version' | 'created'>\n): Promise<{ bytes: Uint8Array }> {\n  const manifest: ManifestV3 = {\n    version: 'LIT-ENCRYPTED-V3',\n    created: Date.now(),\n    ...metadata,\n  }\n\n  // Encode as CBOR\n  const { encode } = await import('cbor-x')\n  const bytes = encode(manifest)\n\n  return { bytes }\n}\n\n/**\n * Parse a manifest from bytes\n */\nexport async function parseManifestV3(bytes: Uint8Array): Promise<ManifestV3> {\n  const { decode } = await import('cbor-x')\n  const manifest = decode(bytes) as ManifestV3\n\n  if (manifest.version !== 'LIT-ENCRYPTED-V3') {\n    throw new Error('Invalid manifest version')\n  }\n\n  return manifest\n}\n\n/**\n * Helper to construct gateway URLs for chunks\n */\nexport function getChunkUrl(\n  chunkCid: string,\n  gateway = '/api/download'\n): string {\n  return `${gateway}/${chunkCid}`\n}\n\n/**\n * Create a V4 manifest\n */\nexport async function createManifestV4(\n  accessControlConditions: any[],\n  encryptedManifest: string\n): Promise<{ bytes: Uint8Array }> {\n  const manifest: ManifestV4 = {\n    version: 'LIT-ENCRYPTED-V4',\n    accessControlConditions,\n    encryptedManifest,\n    created: Date.now(),\n  }\n\n  // Encode as CBOR\n  const { encode } = await import('cbor-x')\n  const bytes = encode(manifest)\n\n  return { bytes }\n}\n\n/**\n * Parse a V4 manifest from bytes\n */\nexport async function parseManifestV4(bytes: Uint8Array): Promise<ManifestV4> {\n  const { decode } = await import('cbor-x')\n  const manifest = decode(bytes) as ManifestV4\n\n  if (manifest.version !== 'LIT-ENCRYPTED-V4') {\n    throw new Error('Invalid manifest version')\n  }\n\n  return manifest\n}\n\n/**\n * Create metadata bundle for V4\n */\nexport async function createMetadataV4(\n  metadata: MetadataV4\n): Promise<{ bytes: Uint8Array }> {\n  // Encode as CBOR\n  const { encode } = await import('cbor-x')\n  const bytes = encode(metadata)\n\n  return { bytes }\n}\n\n/**\n * Parse metadata from bytes\n */\nexport async function parseMetadataV4(bytes: Uint8Array): Promise<MetadataV4> {\n  const { decode } = await import('cbor-x')\n  return decode(bytes) as MetadataV4\n}\n\n/**\n * Fetch only required chunks for a byte range\n */\nexport async function fetchChunksForRange(\n  manifest: ManifestV3,\n  start: number,\n  end: number,\n  gateway = '/api/download'\n): Promise<Map<string, ArrayBuffer>> {\n  const needed = getChunksForByteRange(manifest, start, end)\n  const chunks = new Map<string, ArrayBuffer>()\n\n  // Fetch chunks in parallel\n  await Promise.all(\n    needed.map(async ({ chunk }) => {\n      if (!chunks.has(chunk.cid)) {\n        const response = await fetch(getChunkUrl(chunk.cid, gateway))\n        if (!response.ok) {\n          throw new Error(`Failed to fetch chunk ${chunk.cid}`)\n        }\n        chunks.set(chunk.cid, await response.arrayBuffer())\n      }\n    })\n  )\n\n  return chunks\n}\n", "import type { LitNodeClient, SessionSigsMap } from 'lit-wrapper'\nimport { decode } from 'cbor-x'\n\n// IndexedDB schema for sharing data between main thread and service worker\nconst DB_NAME = 'lit-key-store'\nconst DB_VERSION = 2 // Bumped for new schema\nconst STORE_NAMES = {\n  SESSION_SIGS: 'sessionSigs',\n  CRYPTO_KEYS: 'cryptoKeys', // New store for CryptoKey objects\n  MANIFESTS: 'manifests', // Store for manifest data\n  KEY_METADATA: 'keyMetadata', // Legacy, kept for migration\n}\n\ninterface StoredCryptoKey {\n  id: string // Same as manifest ID or CID\n  cryptoKey: CryptoKey\n  iv: Uint8Array\n  algorithm: string\n  created: number\n}\n\ninterface StoredManifest {\n  id: string // manifest-ID or CID\n  manifest: import('./car-streaming-format').MetadataV4\n  created: number\n}\n\n// Legacy interface for migration compatibility\ninterface KeyMetadata {\n  cid: string\n  dataToEncryptHash: `0x${string}`\n  fileHash: `0x${string}`\n  unifiedAccessControlConditions: any[]\n  encryptedSymmetricKey: string\n  createdAt: number\n}\n\n// Initialize IndexedDB\nasync function initDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION)\n\n    request.onerror = () => reject(request.error)\n    request.onsuccess = () => resolve(request.result)\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result\n\n      // Store for session signatures\n      if (!db.objectStoreNames.contains(STORE_NAMES.SESSION_SIGS)) {\n        db.createObjectStore(STORE_NAMES.SESSION_SIGS)\n      }\n\n      // New store for CryptoKey objects\n      if (!db.objectStoreNames.contains(STORE_NAMES.CRYPTO_KEYS)) {\n        const store = db.createObjectStore(STORE_NAMES.CRYPTO_KEYS, {\n          keyPath: 'id',\n        })\n        store.createIndex('created', 'created', { unique: false })\n      }\n\n      // New store for manifests\n      if (!db.objectStoreNames.contains(STORE_NAMES.MANIFESTS)) {\n        const store = db.createObjectStore(STORE_NAMES.MANIFESTS, {\n          keyPath: 'id',\n        })\n        store.createIndex('created', 'created', { unique: false })\n      }\n\n      // Legacy stores - kept for migration (remove after migration)\n      // These stores are not actively used but kept to avoid errors\n\n      if (!db.objectStoreNames.contains(STORE_NAMES.KEY_METADATA)) {\n        const store = db.createObjectStore(STORE_NAMES.KEY_METADATA, {\n          keyPath: 'cid',\n        })\n        store.createIndex('createdAt', 'createdAt', { unique: false })\n      }\n    }\n  })\n}\n\n// Main thread functions\nexport class LitKeyManager {\n  litClient: LitNodeClient // Made public for setupMainThreadKeyListener\n  private db: IDBDatabase | null = null\n\n  constructor(litClient: LitNodeClient) {\n    this.litClient = litClient\n  }\n\n  async init() {\n    this.db = await initDB()\n  }\n\n  // Store session signatures in IndexedDB for service worker access\n  async storeSessionSigs(sessionSigs: SessionSigsMap): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    const tx = this.db.transaction([STORE_NAMES.SESSION_SIGS], 'readwrite')\n    const store = tx.objectStore(STORE_NAMES.SESSION_SIGS)\n\n    // Store with timestamp for expiry checking\n    store.put(\n      {\n        sigs: sessionSigs,\n        timestamp: Date.now(),\n      },\n      'current'\n    )\n\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve(undefined)\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  // Encrypt the symmetric key using LIT protocol\n  async encryptSymmetricKey(\n    symmetricKey: ArrayBuffer,\n    _dataToEncryptHash: `0x${string}`, // Currently LIT does not require it on the input, but for large content this would normally be preferred.\n    unifiedAccessControlConditions: any[]\n  ): Promise<{ encryptedKey: string; keyHash: `0x${string}` }> {\n    const encryptedKey = await this.litClient.encrypt({\n      unifiedAccessControlConditions,\n      dataToEncrypt: new Uint8Array(symmetricKey),\n    })\n    return {\n      encryptedKey: JSON.stringify(encryptedKey),\n      keyHash: encryptedKey.dataToEncryptHash as `0x${string}`,\n    }\n  }\n\n  // V4: Encrypt entire metadata bundle with LIT\n  async encryptMetadataBundle(\n    metadataBytes: Uint8Array,\n    unifiedAccessControlConditions: any[]\n  ): Promise<{ encryptedBundle: string; bundleHash: `0x${string}` }> {\n    const encrypted = await this.litClient.encrypt({\n      unifiedAccessControlConditions,\n      dataToEncrypt: metadataBytes,\n    })\n    return {\n      encryptedBundle: JSON.stringify(encrypted),\n      bundleHash: encrypted.dataToEncryptHash as `0x${string}`,\n    }\n  }\n\n  // V4: Store encrypted metadata bundle reference\n  async storeV4Metadata(\n    cid: string, // Manifest CID\n    metadataCID: string, // Encrypted metadata CID\n    bundleHash: `0x${string}`, // Hash of the metadata bundle\n    unifiedAccessControlConditions: any[]\n  ): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    const metadata = {\n      cid,\n      metadataCID,\n      bundleHash,\n      unifiedAccessControlConditions,\n      version: 'V4',\n      createdAt: Date.now(),\n    }\n\n    const tx = this.db.transaction([STORE_NAMES.KEY_METADATA], 'readwrite')\n    const store = tx.objectStore(STORE_NAMES.KEY_METADATA)\n    store.put(metadata)\n\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve(undefined)\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  // Store encrypted key metadata (V3)\n  async storeKeyMetadata(\n    cid: string,\n    dataToEncryptHash: `0x${string}`, // Hash of the symmetric key\n    fileHash: `0x${string}`, // Hash of the original file\n    unifiedAccessControlConditions: any[],\n    encryptedSymmetricKey: string\n  ): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    const metadata: KeyMetadata = {\n      cid,\n      dataToEncryptHash,\n      fileHash,\n      unifiedAccessControlConditions,\n      encryptedSymmetricKey,\n      createdAt: Date.now(),\n    }\n\n    const tx = this.db.transaction([STORE_NAMES.KEY_METADATA], 'readwrite')\n    const store = tx.objectStore(STORE_NAMES.KEY_METADATA)\n    store.put(metadata)\n\n    await new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve(undefined)\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  // Get V4 decrypted key from encrypted metadata bundle\n  async getV4DecryptedKey(\n    cid: string,\n    metadataCID: string\n  ): Promise<{\n    key: ArrayBuffer\n    iv: Uint8Array\n  } | null> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    // Get V4 metadata\n    const tx = this.db.transaction([STORE_NAMES.KEY_METADATA], 'readonly')\n    const store = tx.objectStore(STORE_NAMES.KEY_METADATA)\n    const metadata = await new Promise<any>((resolve, reject) => {\n      const request = store.get(cid)\n      request.onsuccess = () => resolve(request.result)\n      request.onerror = () => reject(request.error)\n    })\n\n    if (!metadata || metadata.version !== 'V4') return null\n\n    // Get session sigs\n    const sessionSigs = await this.getSessionSigs()\n    if (!sessionSigs) throw new Error('No session signatures available')\n\n    // Fetch encrypted metadata bundle\n    const response = await fetch(`/api/download/${metadataCID}`)\n    if (!response.ok) {\n      throw new Error('Failed to fetch encrypted metadata')\n    }\n\n    const encryptedBundleText = await response.text()\n\n    // Parse the LIT-encrypted object that was stored as JSON\n    const encryptedData = JSON.parse(encryptedBundleText)\n\n    // Decrypt metadata bundle with LIT\n    // Note: This assumes the metadata was encrypted with LIT, not RSA\n    // For RSA-encrypted metadata, we'd need a different approach\n    const decrypted = await this.litClient.decrypt({\n      unifiedAccessControlConditions: metadata.unifiedAccessControlConditions,\n      ciphertext: encryptedData.ciphertext,\n      dataToEncryptHash: metadata.bundleHash,\n      sessionSigs,\n      chain: 'filecoinCalibrationTestnet',\n    })\n\n    // Parse decrypted metadata\n    const { parseMetadataV4 } = await import('./car-streaming-format')\n    const decryptedMetadata = await parseMetadataV4(\n      new Uint8Array(decrypted.decryptedData)\n    )\n\n    // Ensure we return a proper ArrayBuffer\n    const keyUint8Array = decryptedMetadata.symmetricKey\n    // Create a new ArrayBuffer and copy the data\n    const key = new ArrayBuffer(keyUint8Array.length)\n    new Uint8Array(key).set(keyUint8Array)\n\n    return {\n      key,\n      iv: decryptedMetadata.iv,\n    }\n  }\n\n  // Retrieve and decrypt symmetric key (V3)\n  async getDecryptedKey(\n    cid: string\n  ): Promise<{ key: ArrayBuffer; iv: Uint8Array } | null> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    // Get metadata\n    const tx = this.db.transaction([STORE_NAMES.KEY_METADATA], 'readonly')\n    const store = tx.objectStore(STORE_NAMES.KEY_METADATA)\n    const metadata = await new Promise<KeyMetadata | undefined>(\n      (resolve, reject) => {\n        const request = store.get(cid)\n        request.onsuccess = () => resolve(request.result)\n        request.onerror = () => reject(request.error)\n      }\n    )\n\n    if (!metadata) return null\n\n    // Get current session sigs\n    const sessionSigs = await this.getSessionSigs()\n    if (!sessionSigs) throw new Error('No session signatures available')\n\n    // Decrypt the symmetric key using LIT\n    const encryptedKey = JSON.parse(metadata.encryptedSymmetricKey)\n    const decryptedKey = await this.litClient.decrypt({\n      unifiedAccessControlConditions: metadata.unifiedAccessControlConditions,\n      ciphertext: encryptedKey.ciphertext,\n      dataToEncryptHash: metadata.dataToEncryptHash,\n      sessionSigs,\n      chain: 'filecoinCalibrationTestnet',\n    })\n\n    // The decrypted key should contain both key and IV\n    // Assuming format: first 32 bytes = key, next 12 bytes = IV\n    const keyData = new Uint8Array(decryptedKey.decryptedData)\n    const key = keyData.slice(0, 32)\n    const iv = keyData.slice(32, 44)\n\n    return {\n      key: key.buffer,\n      iv,\n    }\n  }\n\n  async getSessionSigs(): Promise<SessionSigsMap | null> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    const tx = this.db.transaction([STORE_NAMES.SESSION_SIGS], 'readonly')\n    const store = tx.objectStore(STORE_NAMES.SESSION_SIGS)\n    const data = await new Promise<any>((resolve, reject) => {\n      const request = store.get('current')\n      request.onsuccess = () => resolve(request.result)\n      request.onerror = () => reject(request.error)\n    })\n\n    if (!data) return null\n\n    // Check if expired (e.g., 24 hours)\n    const AGE_LIMIT = 24 * 60 * 60 * 1000\n    if (Date.now() - data.timestamp > AGE_LIMIT) {\n      return null\n    }\n\n    return data.sigs\n  }\n}\n\n// Service worker functions\nexport class ServiceWorkerKeyManager {\n  private db: IDBDatabase | null = null\n\n  async init() {\n    this.db = await initDB()\n  }\n\n  // Get manifest and corresponding CryptoKey\n  async getManifestAndKey(id: string): Promise<{\n    manifest: import('./car-streaming-format').MetadataV4\n    cryptoKey: CryptoKey\n    iv: Uint8Array\n  } | null> {\n    if (!this.db) throw new Error('Database not initialized')\n\n    try {\n      // First check if we have it cached in our stores\n      const cached = await this.getCachedManifestAndKey(id)\n      if (cached) return cached\n\n      // If it's a CID, fetch from IPFS and cache\n      if (!id.startsWith('manifest-')) {\n        const manifest = await this.fetchAndDecryptManifest(id)\n        if (manifest) {\n          // Cache the manifest and key\n          await this.cacheManifestAndKey(id, manifest)\n          return this.getCachedManifestAndKey(id)\n        }\n      }\n\n      return null\n    } catch (error) {\n      console.error('Failed to get manifest and key:', error)\n      return null\n    }\n  }\n\n  // Get cached manifest and key from IndexedDB\n  private async getCachedManifestAndKey(id: string): Promise<{\n    manifest: import('./car-streaming-format').MetadataV4\n    cryptoKey: CryptoKey\n    iv: Uint8Array\n  } | null> {\n    if (!this.db) return null\n\n    // Get manifest\n    const manifestTx = this.db.transaction([STORE_NAMES.MANIFESTS], 'readonly')\n    const manifestStore = manifestTx.objectStore(STORE_NAMES.MANIFESTS)\n    const manifestEntry = await new Promise<StoredManifest | undefined>(\n      (resolve, reject) => {\n        const request = manifestStore.get(id)\n        request.onsuccess = () => resolve(request.result)\n        request.onerror = () => reject(request.error)\n      }\n    )\n\n    if (!manifestEntry) return null\n\n    // Get crypto key\n    const keyTx = this.db.transaction([STORE_NAMES.CRYPTO_KEYS], 'readonly')\n    const keyStore = keyTx.objectStore(STORE_NAMES.CRYPTO_KEYS)\n    const keyEntry = await new Promise<StoredCryptoKey | undefined>(\n      (resolve, reject) => {\n        const request = keyStore.get(id)\n        request.onsuccess = () => resolve(request.result)\n        request.onerror = () => reject(request.error)\n      }\n    )\n\n    if (!keyEntry) return null\n\n    return {\n      manifest: manifestEntry.manifest,\n      cryptoKey: keyEntry.cryptoKey,\n      iv: keyEntry.iv,\n    }\n  }\n\n  // Cache manifest and key after fetching from IPFS\n  private async cacheManifestAndKey(\n    id: string,\n    manifest: import('./car-streaming-format').MetadataV4\n  ): Promise<void> {\n    if (!this.db) return\n\n    // Import the symmetric key as CryptoKey\n    const cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      manifest.symmetricKey,\n      { name: 'AES-CTR' },\n      false, // non-extractable\n      ['decrypt']\n    )\n\n    // Store manifest\n    const manifestTx = this.db.transaction([STORE_NAMES.MANIFESTS], 'readwrite')\n    const manifestStore = manifestTx.objectStore(STORE_NAMES.MANIFESTS)\n    await new Promise<void>((resolve, reject) => {\n      const request = manifestStore.put({\n        id,\n        manifest: {\n          fileHash: manifest.fileHash,\n          dataToEncryptHash: manifest.dataToEncryptHash,\n          fileMetadata: manifest.fileMetadata,\n          chunks: manifest.chunks,\n        },\n        created: Date.now(),\n      } as StoredManifest)\n      request.onsuccess = () => resolve()\n      request.onerror = () => reject(request.error)\n    })\n\n    // Store crypto key\n    const keyTx = this.db.transaction([STORE_NAMES.CRYPTO_KEYS], 'readwrite')\n    const keyStore = keyTx.objectStore(STORE_NAMES.CRYPTO_KEYS)\n    await new Promise<void>((resolve, reject) => {\n      const request = keyStore.put({\n        id,\n        cryptoKey,\n        iv: manifest.iv,\n        algorithm: 'AES-CTR',\n        created: Date.now(),\n      } as StoredCryptoKey)\n      request.onsuccess = () => resolve()\n      request.onerror = () => reject(request.error)\n    })\n  }\n\n  // Fetch and decrypt manifest from IPFS (for CID-based downloads)\n  private async fetchAndDecryptManifest(\n    cid: string\n  ): Promise<import('./car-streaming-format').MetadataV4 | null> {\n    try {\n      // Fetch the CBOR file from IPFS\n      const response = await fetch(`/api/download/${cid}`)\n      if (!response.ok) {\n        throw new Error('Failed to fetch manifest from IPFS')\n      }\n\n      const data = await response.arrayBuffer()\n      const { decode } = await import('cbor-x')\n      const decoded = decode(new Uint8Array(data)) as import(\n        './car-streaming-format'\n      ).ManifestV4\n\n      if (decoded.version !== 'LIT-ENCRYPTED-V4') {\n        throw new Error('Unsupported manifest version')\n      }\n\n      // Request decryption from main thread\n      const decryptedManifest = await this.requestManifestDecryption(\n        cid,\n        decoded.accessControlConditions,\n        decoded.encryptedManifest\n      )\n\n      return decryptedManifest\n    } catch (error) {\n      console.error('Failed to fetch and decrypt manifest:', error)\n      return null\n    }\n  }\n\n  // Request manifest decryption from main thread\n  private async requestManifestDecryption(\n    cid: string,\n    accessControlConditions: any[],\n    encryptedManifest: string\n  ): Promise<import('./car-streaming-format').MetadataV4 | null> {\n    return new Promise((resolve) => {\n      const channel = new BroadcastChannel('lit-key-requests')\n      const timeout = setTimeout(() => {\n        channel.close()\n        resolve(null)\n      }, 5000)\n\n      channel.onmessage = (event) => {\n        if (event.data.type === 'manifest-response' && event.data.cid === cid) {\n          clearTimeout(timeout)\n          channel.close()\n          resolve(event.data.manifest || null)\n        }\n      }\n\n      channel.postMessage({\n        type: 'manifest-request',\n        cid,\n        accessControlConditions,\n        encryptedManifest,\n      })\n    })\n  }\n}\n\n// Main thread listener for key requests\nexport function setupMainThreadKeyListener(manager: LitKeyManager) {\n  const channel = new BroadcastChannel('lit-key-requests')\n\n  channel.onmessage = async (event) => {\n    if (event.data.type === 'manifest-request') {\n      const { cid, accessControlConditions, encryptedManifest } = event.data\n      try {\n        // Decrypt the manifest using LIT\n        const sessionSigs = await manager.getSessionSigs()\n        if (!sessionSigs) {\n          throw new Error('No session signatures available')\n        }\n\n        // Parse the encrypted data\n        const encryptedData = JSON.parse(encryptedManifest)\n\n        // Decrypt with LIT\n        const decrypted = await manager.litClient.decrypt({\n          unifiedAccessControlConditions: accessControlConditions,\n          ciphertext: encryptedData.ciphertext,\n          dataToEncryptHash: encryptedData.dataToEncryptHash,\n          sessionSigs,\n          chain: 'filecoinCalibrationTestnet',\n        })\n\n        // Parse the decrypted manifest\n        const manifest = decode(new Uint8Array(decrypted.decryptedData))\n\n        channel.postMessage({\n          type: 'manifest-response',\n          cid,\n          manifest,\n        })\n      } catch (error) {\n        console.error('Failed to decrypt manifest:', error)\n        channel.postMessage({\n          type: 'manifest-response',\n          cid,\n          manifest: null,\n        })\n      }\n    }\n  }\n\n  return () => channel.close()\n}\n", "/// <reference lib=\"webworker\" />\n\nimport { ServiceWorkerKeyManager } from './lit-key-manager'\nimport { getChunksForByteRange, type MetadataV4 } from './car-streaming-format'\n\ndeclare const self: ServiceWorkerGlobalScope\n\n// Initialize key manager\nconst keyManager = new ServiceWorkerKeyManager()\nlet keyManagerInitialized = false\n\n// Initialize on first request\nasync function ensureKeyManager() {\n  if (!keyManagerInitialized) {\n    await keyManager.init()\n    keyManagerInitialized = true\n  }\n}\n\n// Message handler for initialization\nself.addEventListener('message', async (event) => {\n  if (event.data.type === 'INIT_KEY_MANAGER') {\n    try {\n      await ensureKeyManager()\n      event.ports[0]?.postMessage({ success: true })\n    } catch (error) {\n      event.ports[0]?.postMessage({\n        success: false,\n        error:\n          error instanceof Error\n            ? error.message\n            : 'Failed to initialize key manager',\n      })\n    }\n  }\n})\n\n// Fetch handler for /download/CID routes\nself.addEventListener('fetch', (event) => {\n  const url = new URL(event.request.url)\n\n  // Check if this is a download request\n  const match = url.pathname.match(/^\\/download\\/(.+)$/)\n  if (!match) return\n\n  const cid = match[1]\n  event.respondWith(handleDownload(cid, event.request))\n})\n\nasync function handleDownload(\n  cid: string,\n  request: Request\n): Promise<Response> {\n  try {\n    // Ensure key manager is initialized\n    await ensureKeyManager()\n\n    // Get the manifest and crypto key (works for both CID and manifest-based downloads)\n    const result = await keyManager.getManifestAndKey(cid)\n    if (!result) {\n      return new Response('Manifest not available or access denied', {\n        status: 403,\n      })\n    }\n\n    const { manifest, cryptoKey, iv } = result\n\n    // Parse range header if present\n    const range = request.headers.get('range')\n    let rangeStart = 0\n    let rangeEnd: number | undefined\n\n    if (range) {\n      const match = range.match(/bytes=(\\d+)-(\\d*)/)\n      if (match) {\n        rangeStart = Number.parseInt(match[1])\n        rangeEnd = match[2] ? Number.parseInt(match[2]) : undefined\n      }\n    }\n\n    // Now we have a unified manifest format, handle the download\n    return handleManifestDownload(manifest, cryptoKey, iv, rangeStart, rangeEnd)\n  } catch (error) {\n    console.error('Download error:', error)\n    return new Response('Failed to decrypt file', { status: 500 })\n  }\n}\n\nfunction cidAsURL(cid?: string) {\n  if (!cid) {\n    throw new Error('Invalid CID')\n  }\n  const [seg0, ...segs] = cid.split('/')\n  return `https://${seg0}.ipfs.w3s.link/${segs.join('/')}`\n}\n\n// Unified handler for manifest-based downloads\nasync function handleManifestDownload(\n  manifest: MetadataV4,\n  cryptoKey: CryptoKey,\n  iv: Uint8Array,\n  rangeStart: number,\n  rangeEnd?: number\n): Promise<Response> {\n  const fileSize = manifest.fileMetadata.size\n  const effectiveRangeEnd = rangeEnd ?? fileSize - 1\n\n  // Get chunks needed for this range\n  const neededChunks = getChunksForByteRange(\n    {\n      version: 'LIT-ENCRYPTED-V3', // Use V3 format for compatibility\n      network: '',\n      contractName: '',\n      contract: '0x0000000000000000000000000000000000000000',\n      to: '0x0000000000000000000000000000000000000000',\n      dataToEncryptHash: manifest.dataToEncryptHash,\n      unifiedAccessControlConditions: [],\n      fileMetadata: manifest.fileMetadata,\n      chunks: manifest.chunks,\n      created: Date.now(),\n    },\n    rangeStart,\n    effectiveRangeEnd\n  )\n\n  if (neededChunks.length === 0) {\n    return new Response('Requested range not satisfiable', {\n      status: 416,\n      headers: {\n        'Content-Range': `bytes */${fileSize}`,\n      },\n    })\n  }\n\n  // Create decryption stream\n  const stream = new ReadableStream({\n    async start(controller) {\n      try {\n        for (const chunkRequest of neededChunks) {\n          // Fetch encrypted chunk\n          const chunkResponse = await fetch(cidAsURL(chunkRequest.chunk.cid))\n          if (!chunkResponse.ok) {\n            throw new Error(\n              `Failed to fetch chunk ${chunkRequest.chunk.cid}: ${chunkResponse.status}`\n            )\n          }\n\n          const encryptedData = new Uint8Array(\n            await chunkResponse.arrayBuffer()\n          )\n\n          // Decrypt chunk with proper counter\n          const decryptedChunk = await decryptChunk(\n            encryptedData,\n            cryptoKey,\n            iv,\n            chunkRequest.chunk.counter\n          )\n\n          // Extract only the requested portion\n          const chunkData = decryptedChunk.slice(\n            chunkRequest.start,\n            chunkRequest.end + 1\n          )\n          controller.enqueue(chunkData)\n        }\n\n        controller.close()\n      } catch (error) {\n        controller.error(error)\n      }\n    },\n  })\n\n  const contentLength = effectiveRangeEnd - rangeStart + 1\n  const headers: HeadersInit = {\n    'Content-Type': manifest.fileMetadata.type || 'application/octet-stream',\n    'Content-Length': contentLength.toString(),\n    'Content-Disposition': `attachment; filename=\"${manifest.fileMetadata.name}\"`,\n    'Accept-Ranges': 'bytes',\n  }\n\n  if (rangeStart > 0 || effectiveRangeEnd < fileSize - 1) {\n    headers['Content-Range'] =\n      `bytes ${rangeStart}-${effectiveRangeEnd}/${fileSize}`\n    return new Response(stream, { status: 206, headers })\n  }\n\n  return new Response(stream, { headers })\n}\n\nasync function decryptChunk(\n  encryptedData: Uint8Array,\n  key: CryptoKey,\n  baseIv: Uint8Array,\n  counter: number\n): Promise<Uint8Array> {\n  // Create IV for this chunk by adding counter to base IV\n  const chunkIv = new Uint8Array(16)\n  chunkIv.set(baseIv)\n\n  // Add counter to IV (big-endian)\n  let carry = counter\n  for (let i = 15; i >= 0 && carry > 0; i--) {\n    const sum = chunkIv[i] + (carry & 0xff)\n    chunkIv[i] = sum & 0xff\n    carry = (carry >>> 8) + (sum >>> 8)\n  }\n\n  const decrypted = await crypto.subtle.decrypt(\n    {\n      name: 'AES-CTR',\n      counter: chunkIv,\n      length: 128,\n    },\n    key,\n    encryptedData\n  )\n\n  return new Uint8Array(decrypted)\n}\n\n// Install and activate immediately\nself.addEventListener('install', () => {\n  self.skipWaiting()\n})\n\nself.addEventListener('activate', (event) => {\n  event.waitUntil(self.clients.claim())\n})\n"],
  "mappings": "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",
  "names": ["i", "structure", "read", "target", "position", "packedValues", "isLittleEndianMachine", "encode", "Buffer", "bundledStrings", "addExtension", "referenceMap", "packedObjectMap", "sharedPackedObjectMap", "sharedValues", "options", "maxBytes", "decoder", "addExtension", "decode"]
}
