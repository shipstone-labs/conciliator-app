const typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(typeofs.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(isBuffer$1(e))return"Buffer";const n=getObjectType(e);return n||"Object"}function isBuffer$1(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}function getObjectType(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(objectTypeNames.includes(t))return t}class Type{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0),Type.negint=new Type(1,"negint",!0),Type.bytes=new Type(2,"bytes",!0),Type.string=new Type(3,"string",!0),Type.array=new Type(4,"array",!1),Type.map=new Type(5,"map",!1),Type.tag=new Type(6,"tag",!1),Type.float=new Type(7,"float",!0),Type.false=new Type(7,"false",!0),Type.true=new Type(7,"true",!0),Type.null=new Type(7,"null",!0),Type.undefined=new Type(7,"undefined",!0),Type.break=new Type(7,"break",!0);class Token{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,textDecoder$1=new TextDecoder,textEncoder$2=new TextEncoder;function isBuffer(e){return useBuffer&&globalThis.Buffer.isBuffer(e)}function asU8A(e){return e instanceof Uint8Array?isBuffer(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const toString$2=useBuffer?(e,t,n)=>n-t>64?globalThis.Buffer.from(e.subarray(t,n)).toString("utf8"):utf8Slice(e,t,n):(e,t,n)=>n-t>64?textDecoder$1.decode(e.subarray(t,n)):utf8Slice(e,t,n),fromString$1=useBuffer?e=>e.length>64?globalThis.Buffer.from(e):utf8ToBytes$1(e):e=>e.length>64?textEncoder$2.encode(e):utf8ToBytes$1(e),fromArray=e=>Uint8Array.from(e),slice$1=useBuffer?(e,t,n)=>isBuffer(e)?new Uint8Array(e.subarray(t,n)):e.slice(t,n):(e,t,n)=>e.slice(t,n),concat$1=useBuffer?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),asU8A(globalThis.Buffer.concat(e,t))):(e,t)=>{const n=new Uint8Array(t);let r=0;for(let t of e)r+t.length>n.length&&(t=t.subarray(0,n.length-r)),n.set(t,r),r+=t.length;return n},alloc$1=useBuffer?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function compare$1(e,t){if(isBuffer(e)&&isBuffer(t))return e.compare(t);for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}function utf8ToBytes$1(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let o=e.charCodeAt(r);o<128?t[n++]=o:o<2048?(t[n++]=o>>6|192,t[n++]=63&o|128):55296==(64512&o)&&r+1<e.length&&56320==(64512&e.charCodeAt(r+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++r)),t[n++]=o>>18|240,t[n++]=o>>12&63|128,t[n++]=o>>6&63|128,t[n++]=63&o|128):(t[n++]=o>>12|224,t[n++]=o>>6&63|128,t[n++]=63&o|128)}return t}function utf8Slice(e,t,n){const r=[];for(;t<n;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=n){let n,r,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:n=e[t+1],128==(192&n)&&(c=(31&o)<<6|63&n,c>127&&(i=c));break;case 3:n=e[t+1],r=e[t+2],128==(192&n)&&128==(192&r)&&(c=(15&o)<<12|(63&n)<<6|63&r,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:n=e[t+1],r=e[t+2],a=e[t+3],128==(192&n)&&128==(192&r)&&128==(192&a)&&(c=(15&o)<<18|(63&n)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i),t+=s}return decodeCodePointsArray(r)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(e){const t=e.length;if(t<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=MAX_ARGUMENTS_LENGTH));return n}const defaultChunkSize=256;class Bl{constructor(e=defaultChunkSize){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const n=t.length-(this.maxCursor-this.cursor)-1;t.set(e,n)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=alloc$1(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const n=this.chunks[0];e&&this.cursor>n.length/2?(t=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=slice$1(n,0,this.cursor)}else t=concat$1(this.chunks,this.cursor);return e&&this.reset(),t}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(e,t,n){if(e.length-t<n)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(e,t,n){assertEnoughData(e,t,1);const r=e[t];if(!0===n.strict&&r<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint16(e,t,n){assertEnoughData(e,t,2);const r=e[t]<<8|e[t+1];if(!0===n.strict&&r<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint32(e,t,n){assertEnoughData(e,t,4);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===n.strict&&r<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return r}function readUint64(e,t,n){assertEnoughData(e,t,8);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(r)<<BigInt(32))+BigInt(o);if(!0===n.strict&&i<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===n.allowBigInt)return i;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(e,t,n,r){return new Token(Type.uint,readUint8(e,t+1,r),2)}function decodeUint16(e,t,n,r){return new Token(Type.uint,readUint16(e,t+1,r),3)}function decodeUint32(e,t,n,r){return new Token(Type.uint,readUint32(e,t+1,r),5)}function decodeUint64(e,t,n,r){return new Token(Type.uint,readUint64(e,t+1,r),9)}function encodeUint(e,t){return encodeUintValue(e,0,t.value)}function encodeUintValue(e,t,n){if(n<uintBoundaries[0]){const r=Number(n);e.push([t|r])}else if(n<uintBoundaries[1]){const r=Number(n);e.push([24|t,r])}else if(n<uintBoundaries[2]){const r=Number(n);e.push([25|t,r>>>8,255&r])}else if(n<uintBoundaries[3]){const r=Number(n);e.push([26|t,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(n);if(!(r<uintBoundaries[4]))throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);{const n=[27|t,0,0,0,0,0,0,0];let o=Number(r&BigInt(4294967295)),i=Number(r>>BigInt(32)&BigInt(4294967295));n[8]=255&o,o>>=8,n[7]=255&o,o>>=8,n[6]=255&o,o>>=8,n[5]=255&o,n[4]=255&i,i>>=8,n[3]=255&i,i>>=8,n[2]=255&i,i>>=8,n[1]=255&i,e.push(n)}}}function decodeNegint8(e,t,n,r){return new Token(Type.negint,-1-readUint8(e,t+1,r),2)}function decodeNegint16(e,t,n,r){return new Token(Type.negint,-1-readUint16(e,t+1,r),3)}function decodeNegint32(e,t,n,r){return new Token(Type.negint,-1-readUint32(e,t+1,r),5)}encodeUint.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)},encodeUintValue.encodedSize=function(e){return e<uintBoundaries[0]?1:e<uintBoundaries[1]?2:e<uintBoundaries[2]?3:e<uintBoundaries[3]?5:9},encodeUint.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(e,t,n,r){const o=readUint64(e,t+1,r);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,e,9)}if(!0!==r.allowBigInt)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(o),9)}function encodeNegint(e,t){const n=t.value,r="bigint"==typeof n?n*neg1b-pos1b:-1*n-1;encodeUintValue(e,t.type.majorEncoded,r)}function toToken$3(e,t,n,r){assertEnoughData(e,t,n+r);const o=slice$1(e,t+n,t+n+r);return new Token(Type.bytes,o,n+r)}function decodeBytesCompact(e,t,n,r){return toToken$3(e,t,1,n)}function decodeBytes8(e,t,n,r){return toToken$3(e,t,2,readUint8(e,t+1,r))}function decodeBytes16(e,t,n,r){return toToken$3(e,t,3,readUint16(e,t+1,r))}function decodeBytes32(e,t,n,r){return toToken$3(e,t,5,readUint32(e,t+1,r))}function decodeBytes64(e,t,n,r){const o=readUint64(e,t+1,r);if("bigint"==typeof o)throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(e,t,9,o)}function tokenBytes(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===Type.string?fromString$1(e.value):e.value),e.encodedBytes}function encodeBytes(e,t){const n=tokenBytes(t);encodeUintValue(e,t.type.majorEncoded,n.length),e.push(n)}function compareBytes(e,t){return e.length<t.length?-1:e.length>t.length?1:compare$1(e,t)}function toToken$2(e,t,n,r,o){const i=n+r;assertEnoughData(e,t,i);const s=new Token(Type.string,toString$2(e,t+n,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=slice$1(e,t+n,t+i)),s}function decodeStringCompact(e,t,n,r){return toToken$2(e,t,1,n,r)}function decodeString8(e,t,n,r){return toToken$2(e,t,2,readUint8(e,t+1,r),r)}function decodeString16(e,t,n,r){return toToken$2(e,t,3,readUint16(e,t+1,r),r)}function decodeString32(e,t,n,r){return toToken$2(e,t,5,readUint32(e,t+1,r),r)}function decodeString64(e,t,n,r){const o=readUint64(e,t+1,r);if("bigint"==typeof o)throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(e,t,9,o,r)}encodeNegint.encodedSize=function(e){const t=e.value,n="bigint"==typeof t?t*neg1b-pos1b:-1*t-1;return n<uintBoundaries[0]?1:n<uintBoundaries[1]?2:n<uintBoundaries[2]?3:n<uintBoundaries[3]?5:9},encodeNegint.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},encodeBytes.encodedSize=function(e){const t=tokenBytes(e);return encodeUintValue.encodedSize(t.length)+t.length},encodeBytes.compareTokens=function(e,t){return compareBytes(tokenBytes(e),tokenBytes(t))};const encodeString=encodeBytes;function toToken$1(e,t,n,r){return new Token(Type.array,r,n)}function decodeArrayCompact(e,t,n,r){return toToken$1(e,t,1,n)}function decodeArray8(e,t,n,r){return toToken$1(e,t,2,readUint8(e,t+1,r))}function decodeArray16(e,t,n,r){return toToken$1(e,t,3,readUint16(e,t+1,r))}function decodeArray32(e,t,n,r){return toToken$1(e,t,5,readUint32(e,t+1,r))}function decodeArray64(e,t,n,r){const o=readUint64(e,t+1,r);if("bigint"==typeof o)throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(e,t,9,o)}function decodeArrayIndefinite(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(e,t,1,1/0)}function encodeArray(e,t){encodeUintValue(e,Type.array.majorEncoded,t.value)}function toToken(e,t,n,r){return new Token(Type.map,r,n)}function decodeMapCompact(e,t,n,r){return toToken(e,t,1,n)}function decodeMap8(e,t,n,r){return toToken(e,t,2,readUint8(e,t+1,r))}function decodeMap16(e,t,n,r){return toToken(e,t,3,readUint16(e,t+1,r))}function decodeMap32(e,t,n,r){return toToken(e,t,5,readUint32(e,t+1,r))}function decodeMap64(e,t,n,r){const o=readUint64(e,t+1,r);if("bigint"==typeof o)throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(e,t,9,o)}function decodeMapIndefinite(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(e,t,1,1/0)}function encodeMap(e,t){encodeUintValue(e,Type.map.majorEncoded,t.value)}function decodeTagCompact(e,t,n,r){return new Token(Type.tag,n,1)}function decodeTag8(e,t,n,r){return new Token(Type.tag,readUint8(e,t+1,r),2)}function decodeTag16(e,t,n,r){return new Token(Type.tag,readUint16(e,t+1,r),3)}function decodeTag32(e,t,n,r){return new Token(Type.tag,readUint32(e,t+1,r),5)}function decodeTag64(e,t,n,r){return new Token(Type.tag,readUint64(e,t+1,r),9)}function encodeTag(e,t){encodeUintValue(e,Type.tag.majorEncoded,t.value)}encodeArray.compareTokens=encodeUint.compareTokens,encodeArray.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)},encodeMap.compareTokens=encodeUint.compareTokens,encodeMap.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)},encodeTag.compareTokens=encodeUint.compareTokens,encodeTag.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(e,t,n,r){if(!1===r.allowUndefined)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return!0===r.coerceUndefinedToNull?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(e,t,n,r){if(!1===r.allowIndefinite)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(e,t,n){if(n){if(!1===n.allowNaN&&Number.isNaN(e))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(!1===n.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,e,t)}function decodeFloat16(e,t,n,r){return createToken(readFloat16(e,t+1),3,r)}function decodeFloat32(e,t,n,r){return createToken(readFloat32(e,t+1),5,r)}function decodeFloat64(e,t,n,r){return createToken(readFloat64(e,t+1),9,r)}function encodeFloat(e,t,n){const r=t.value;if(!1===r)e.push([Type.float.majorEncoded|MINOR_FALSE]);else if(!0===r)e.push([Type.float.majorEncoded|MINOR_TRUE]);else if(null===r)e.push([Type.float.majorEncoded|MINOR_NULL]);else if(void 0===r)e.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let t,o=!1;n&&!0===n.float64||(encodeFloat16(r),t=readFloat16(ui8a,1),r===t||Number.isNaN(r)?(ui8a[0]=249,e.push(ui8a.slice(0,3)),o=!0):(encodeFloat32(r),t=readFloat32(ui8a,1),r===t&&(ui8a[0]=250,e.push(ui8a.slice(0,5)),o=!0))),o||(encodeFloat64(r),t=readFloat64(ui8a,1),ui8a[0]=251,e.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(e,t){const n=e.value;if(!1===n||!0===n||null==n)return 1;if(!t||!0!==t.float64){encodeFloat16(n);let e=readFloat16(ui8a,1);if(n===e||Number.isNaN(n))return 3;if(encodeFloat32(n),e=readFloat32(ui8a,1),n===e)return 5}return 9};const buffer=new ArrayBuffer(9),dataView=new DataView(buffer,1),ui8a=new Uint8Array(buffer,0);function encodeFloat16(e){if(e===1/0)dataView.setUint16(0,31744,!1);else if(e===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(e))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,e);const t=dataView.getUint32(0),n=(2139095040&t)>>23,r=8388607&t;if(255===n)dataView.setUint16(0,31744,!1);else if(0===n)dataView.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=n-127;e<-24?dataView.setUint16(0,0):e<-14?dataView.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):dataView.setUint16(0,(2147483648&t)>>16|e+15<<10|r>>13,!1)}}}function readFloat16(e,t){if(e.length-t<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const n=(e[t]<<8)+e[t+1];if(31744===n)return 1/0;if(64512===n)return-1/0;if(32256===n)return NaN;const r=n>>10&31,o=1023&n;let i;return i=0===r?o*2**-24:31!==r?(o+1024)*2**(r-25):0===o?1/0:NaN,32768&n?-i:i}function encodeFloat32(e){dataView.setFloat32(0,e,!1)}function readFloat32(e,t){if(e.length-t<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,4).getFloat32(0,!1)}function encodeFloat64(e){dataView.setFloat64(0,e,!1)}function readFloat64(e,t){if(e.length-t<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,8).getFloat64(0,!1)}function invalidMinor(e,t,n){throw new Error(`${decodeErrPrefix} encountered invalid minor (${n}) for major ${e[t]>>>5}`)}function errorer(e){return()=>{throw new Error(`${decodeErrPrefix} ${e}`)}}encodeFloat.compareTokens=encodeUint.compareTokens;const jump=[];for(let e=0;e<=23;e++)jump[e]=invalidMinor;jump[24]=decodeUint8,jump[25]=decodeUint16,jump[26]=decodeUint32,jump[27]=decodeUint64,jump[28]=invalidMinor,jump[29]=invalidMinor,jump[30]=invalidMinor,jump[31]=invalidMinor;for(let e=32;e<=55;e++)jump[e]=invalidMinor;jump[56]=decodeNegint8,jump[57]=decodeNegint16,jump[58]=decodeNegint32,jump[59]=decodeNegint64,jump[60]=invalidMinor,jump[61]=invalidMinor,jump[62]=invalidMinor,jump[63]=invalidMinor;for(let e=64;e<=87;e++)jump[e]=decodeBytesCompact;jump[88]=decodeBytes8,jump[89]=decodeBytes16,jump[90]=decodeBytes32,jump[91]=decodeBytes64,jump[92]=invalidMinor,jump[93]=invalidMinor,jump[94]=invalidMinor,jump[95]=errorer("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)jump[e]=decodeStringCompact;jump[120]=decodeString8,jump[121]=decodeString16,jump[122]=decodeString32,jump[123]=decodeString64,jump[124]=invalidMinor,jump[125]=invalidMinor,jump[126]=invalidMinor,jump[127]=errorer("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)jump[e]=decodeArrayCompact;jump[152]=decodeArray8,jump[153]=decodeArray16,jump[154]=decodeArray32,jump[155]=decodeArray64,jump[156]=invalidMinor,jump[157]=invalidMinor,jump[158]=invalidMinor,jump[159]=decodeArrayIndefinite;for(let e=160;e<=183;e++)jump[e]=decodeMapCompact;jump[184]=decodeMap8,jump[185]=decodeMap16,jump[186]=decodeMap32,jump[187]=decodeMap64,jump[188]=invalidMinor,jump[189]=invalidMinor,jump[190]=invalidMinor,jump[191]=decodeMapIndefinite;for(let e=192;e<=215;e++)jump[e]=decodeTagCompact;jump[216]=decodeTag8,jump[217]=decodeTag16,jump[218]=decodeTag32,jump[219]=decodeTag64,jump[220]=invalidMinor,jump[221]=invalidMinor,jump[222]=invalidMinor,jump[223]=invalidMinor;for(let e=224;e<=243;e++)jump[e]=errorer("simple values are not supported");jump[244]=invalidMinor,jump[245]=invalidMinor,jump[246]=invalidMinor,jump[247]=decodeUndefined,jump[248]=errorer("simple values are not supported"),jump[249]=decodeFloat16,jump[250]=decodeFloat32,jump[251]=decodeFloat64,jump[252]=invalidMinor,jump[253]=invalidMinor,jump[254]=invalidMinor,jump[255]=decodeBreak;const quick=[];for(let e=0;e<24;e++)quick[e]=new Token(Type.uint,e,1);for(let e=-1;e>=-24;e--)quick[31-e]=new Token(Type.negint,e,1);function quickEncodeToken(e){switch(e.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return e.value.length?void 0:fromArray([64]);case Type.string:return""===e.value?fromArray([96]):void 0;case Type.array:return 0===e.value?fromArray([128]):void 0;case Type.map:return 0===e.value?fromArray([160]):void 0;case Type.uint:return e.value<24?fromArray([Number(e.value)]):void 0;case Type.negint:if(e.value>=-24)return fromArray([31-Number(e.value)])}}quick[64]=new Token(Type.bytes,new Uint8Array(0),1),quick[96]=new Token(Type.string,"",1),quick[128]=new Token(Type.array,0,1),quick[160]=new Token(Type.map,0,1),quick[244]=new Token(Type.false,!1,1),quick[245]=new Token(Type.true,!0,1),quick[246]=new Token(Type.null,null,1);const defaultEncodeOptions$2={float64:!1,mapSorter:mapSorter$1,quickEncodeToken:quickEncodeToken};function makeCborEncoders(){const e=[];return e[Type.uint.major]=encodeUint,e[Type.negint.major]=encodeNegint,e[Type.bytes.major]=encodeBytes,e[Type.string.major]=encodeString,e[Type.array.major]=encodeArray,e[Type.map.major]=encodeMap,e[Type.tag.major]=encodeTag,e[Type.float.major]=encodeFloat,e}const cborEncoders$1=makeCborEncoders(),buf=new Bl;class Ref{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(t,e)}}const simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number:(e,t,n,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Token(e>=0?Type.uint:Type.negint,e):new Token(Type.float,e),bigint:(e,t,n,r)=>e>=BigInt(0)?new Token(Type.uint,e):new Token(Type.negint,e),Uint8Array:(e,t,n,r)=>new Token(Type.bytes,e),string:(e,t,n,r)=>new Token(Type.string,e),boolean:(e,t,n,r)=>e?simpleTokens.true:simpleTokens.false,null:(e,t,n,r)=>simpleTokens.null,undefined:(e,t,n,r)=>simpleTokens.undefined,ArrayBuffer:(e,t,n,r)=>new Token(Type.bytes,new Uint8Array(e)),DataView:(e,t,n,r)=>new Token(Type.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,n,r){if(!e.length)return!0===n.addBreakTokens?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;r=Ref.createCheck(r,e);const o=[];let i=0;for(const t of e)o[i++]=objectToTokens(t,n,r);return n.addBreakTokens?[new Token(Type.array,e.length),o,new Token(Type.break)]:[new Token(Type.array,e.length),o]},Object(e,t,n,r){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===n.addBreakTokens?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;r=Ref.createCheck(r,e);const a=[];let c=0;for(const t of i)a[c++]=[objectToTokens(t,n,r),objectToTokens(o?e.get(t):e[t],n,r)];return sortMapEntries(a,n),n.addBreakTokens?[new Token(Type.map,s),a,new Token(Type.break)]:[new Token(Type.map,s),a]}};typeEncoders.Map=typeEncoders.Object,typeEncoders.Buffer=typeEncoders.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${e}Array`]=typeEncoders.DataView;function objectToTokens(e,t={},n){const r=is(e),o=t&&t.typeEncoders&&t.typeEncoders[r]||typeEncoders[r];if("function"==typeof o){const i=o(e,r,t,n);if(null!=i)return i}const i=typeEncoders[r];if(!i)throw new Error(`${encodeErrPrefix} unsupported type: ${r}`);return i(e,r,t,n)}function sortMapEntries(e,t){t.mapSorter&&e.sort(t.mapSorter)}function mapSorter$1(e,t){const n=Array.isArray(e[0])?e[0][0]:e[0],r=Array.isArray(t[0])?t[0][0]:t[0];if(n.type!==r.type)return n.type.compare(r.type);const o=n.type.major,i=cborEncoders$1[o].compareTokens(n,r);return 0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i}function tokensToEncoded(e,t,n,r){if(Array.isArray(t))for(const o of t)tokensToEncoded(e,o,n,r);else n[t.type.major](e,t,r)}function encodeCustom(e,t,n){const r=objectToTokens(e,n);if(!Array.isArray(r)&&n.quickEncodeToken){const e=n.quickEncodeToken(r);if(e)return e;const o=t[r.type.major];if(o.encodedSize){const e=o.encodedSize(r,n),t=new Bl(e);if(o(t,r,n),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${r} was wrong`);return asU8A(t.chunks[0])}}return buf.reset(),tokensToEncoded(buf,r,t,n),buf.toBytes(!0)}function encode$t(e,t){return t=Object.assign({},defaultEncodeOptions$2,t),encodeCustom(e,cborEncoders$1,t)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,t={}){this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=quick[e];if(void 0===t){const n=jump[e];if(!n)throw new Error(`${decodeErrPrefix} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const r=31&e;t=n(this.data,this._pos,r,this.options)}return this._pos+=t.encodedLength,t}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(e,t,n){const r=[];for(let o=0;o<e.value;o++){const i=tokensToObject(t,n);if(i===BREAK){if(e.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(i===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${e.value})`);r[o]=i}return r}function tokenToMap(e,t,n){const r=!0===n.useMaps,o=r?void 0:{},i=r?new Map:void 0;for(let s=0;s<e.value;s++){const a=tokensToObject(t,n);if(a===BREAK){if(e.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(a===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no key], expected ${e.value})`);if(!0!==r&&"string"!=typeof a)throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof a})`);if(!0===n.rejectDuplicateMapKeys&&(r&&i.has(a)||!r&&a in o))throw new Error(`${decodeErrPrefix} found repeat map key "${a}"`);const c=tokensToObject(t,n);if(c===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no value], expected ${e.value})`);r?i.set(a,c):o[a]=c}return r?i:o}function tokensToObject(e,t){if(e.done())return DONE;const n=e.next();if(n.type===Type.break)return BREAK;if(n.type.terminal)return n.value;if(n.type===Type.array)return tokenToArray(n,e,t);if(n.type===Type.map)return tokenToMap(n,e,t);if(n.type===Type.tag){if(t.tags&&"function"==typeof t.tags[n.value]){const r=tokensToObject(e,t);return t.tags[n.value](r)}throw new Error(`${decodeErrPrefix} tag not supported (${n.value})`)}throw new Error("unsupported")}function decodeFirst(e,t){if(!(e instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);const n=(t=Object.assign({},defaultDecodeOptions,t)).tokenizer||new Tokeniser(e,t),r=tokensToObject(n,t);if(r===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(r===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);return[r,e.subarray(n.pos())]}function decode$D(e,t){const[n,r]=decodeFirst(e,t);if(r.length>0)throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return n}const empty$4=new Uint8Array(0);function fromHex(e){const t=e.match(/../g);return null!=t?new Uint8Array(t.map((e=>parseInt(e,16)))):empty$4}function equals$6(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function coerce$2(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function fromString(e){return(new TextEncoder).encode(e)}function toString$1(e){return(new TextDecoder).decode(e)}function base$2(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==n[s])throw new TypeError(i+" is ambiguous");n[s]=o}var a=e.length,c=e.charAt(0),d=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,o=0;e[t]===c;)r++,t++;for(var i=(e.length-t)*d+1>>>0,s=new Uint8Array(i);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var l=0,h=i-1;(0!==u||l<o)&&-1!==h;h--,l++)u+=a*s[h]>>>0,s[h]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");o=l,t++}if(" "!==e[t]){for(var f=i-o;f!==i&&0===s[f];)f++;for(var p=new Uint8Array(r+(i-f)),y=r;f!==i;)p[y++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,o=0,i=t.length;o!==i&&0===t[o];)o++,n++;for(var s=(i-o)*u+1>>>0,d=new Uint8Array(s);o!==i;){for(var l=t[o],h=0,f=s-1;(0!==l||h<r)&&-1!==f;f--,h++)l+=256*d[f]>>>0,d[f]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");r=h,o++}for(var p=s-r;p!==s&&0===d[p];)p++;for(var y=c.repeat(n);p<s;++p)y+=e.charAt(d[p]);return y},decodeUnsafe:l,decode:function(e){var n=l(e);if(n)return n;throw new Error(`Non-${t} character`)}}}var src$2=base$2,_brrp__multiformats_scope_baseX$2=src$2;let Encoder$2=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$2=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const r=t.codePointAt(0);if(void 0===r)throw new Error("Invalid prefix character");this.prefixCodePoint=r,this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return or$a(this,e)}},ComposedDecoder$2=class{decoders;constructor(e){this.decoders=e}or(e){return or$a(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(null!=n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function or$a(e,t){return new ComposedDecoder$2({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}let Codec$2=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new Encoder$2(e,t,n),this.decoder=new Decoder$2(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function from$g({name:e,prefix:t,encode:n,decode:r}){return new Codec$2(e,t,n,r)}function baseX$2({name:e,prefix:t,alphabet:n}){const{encode:r,decode:o}=_brrp__multiformats_scope_baseX$2(n,e);return from$g({prefix:t,name:e,encode:r,decode:e=>coerce$2(o(e))})}function decode$C(e,t,n,r){const o={};for(let e=0;e<t.length;++e)o[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*n/8|0);let a=0,c=0,d=0;for(let t=0;t<i;++t){const i=o[e[t]];if(void 0===i)throw new SyntaxError(`Non-${r} character`);c=c<<n|i,a+=n,a>=8&&(a-=8,s[d++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s}function encode$s(e,t,n){const r="="===t[t.length-1],o=(1<<n)-1;let i="",s=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],s+=8;s>n;)s-=n,i+=t[o&a>>s];if(0!==s&&(i+=t[o&a<<n-s]),r)for(;i.length*n&7;)i+="=";return i}function rfc4648$2({name:e,prefix:t,bitsPerChar:n,alphabet:r}){return from$g({prefix:t,name:e,encode:e=>encode$s(e,r,n),decode:t=>decode$C(t,r,n,e)})}const base32$2=rfc4648$2({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$2({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rfc4648$2({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rfc4648$2({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rfc4648$2({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rfc4648$2({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rfc4648$2({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),rfc4648$2({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rfc4648$2({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const base36=baseX$2({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"});baseX$2({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});const base58btc$2=baseX$2({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$2({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var encode_1$4=encode$r,MSB$5=128,MSBALL$4=-128,INT$4=Math.pow(2,31);function encode$r(e,t,n){t=t||[];for(var r=n=n||0;e>=INT$4;)t[n++]=255&e|MSB$5,e/=128;for(;e&MSBALL$4;)t[n++]=255&e|MSB$5,e>>>=7;return t[n]=0|e,encode$r.bytes=n-r+1,t}var decode$B=read$6,MSB$1$3=128,REST$1$3=127;function read$6(e,t){var n,r=0,o=0,i=t=t||0,s=e.length;do{if(i>=s)throw read$6.bytes=0,new RangeError("Could not decode varint");n=e[i++],r+=o<28?(n&REST$1$3)<<o:(n&REST$1$3)*Math.pow(2,o),o+=7}while(n>=MSB$1$3);return read$6.bytes=i-t,r}var N1$3=Math.pow(2,7),N2$3=Math.pow(2,14),N3$3=Math.pow(2,21),N4$3=Math.pow(2,28),N5$3=Math.pow(2,35),N6$3=Math.pow(2,42),N7$3=Math.pow(2,49),N8$3=Math.pow(2,56),N9$3=Math.pow(2,63),length$4=function(e){return e<N1$3?1:e<N2$3?2:e<N3$3?3:e<N4$3?4:e<N5$3?5:e<N6$3?6:e<N7$3?7:e<N8$3?8:e<N9$3?9:10},varint$5={encode:encode_1$4,decode:decode$B,encodingLength:length$4},_brrp_varint$3=varint$5;function decode$A(e,t=0){return[_brrp_varint$3.decode(e,t),_brrp_varint$3.decode.bytes]}function encodeTo$3(e,t,n=0){return _brrp_varint$3.encode(e,t,n),t}function encodingLength$3(e){return _brrp_varint$3.encodingLength(e)}function create$h(e,t){const n=t.byteLength,r=encodingLength$3(e),o=r+encodingLength$3(n),i=new Uint8Array(o+n);return encodeTo$3(e,i,0),encodeTo$3(n,i,r),i.set(t,o),new Digest$5(e,n,t,i)}function decode$z(e){const t=coerce$2(e),[n,r]=decode$A(t),[o,i]=decode$A(t.subarray(r)),s=t.subarray(r+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest$5(n,o,s,t)}function equals$5(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&equals$6(e.bytes,n.bytes)}}let Digest$5=class{code;size;digest;bytes;constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}};function format$6(e,t){const{bytes:n,version:r}=e;return 0===r?toStringV0$2(n,baseCache$2(e),t??base58btc$2.encoder):toStringV1$2(n,baseCache$2(e),t??base32$2.encoder)}const cache$3=new WeakMap;function baseCache$2(e){const t=cache$3.get(e);if(null==t){const t=new Map;return cache$3.set(e,t),t}return t}let CID$2=class e{code;version;multihash;bytes;"/";constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==DAG_PB_CODE$3)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==SHA_256_CODE$2)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return e.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=create$h(t,n);return e.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return e.equals(this,t)}static equals(e,t){const n=t;return null!=n&&e.code===n.code&&e.version===n.version&&equals$5(e.multihash,n.multihash)}toString(e){return format$6(this,e)}toJSON(){return{"/":format$6(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(null==t)return null;const n=t;if(n instanceof e)return n;if(null!=n["/"]&&n["/"]===n.bytes||n.asCID===n){const{version:t,code:r,multihash:o,bytes:i}=n;return new e(t,r,o,i??encodeCID$2(t,r,o.bytes))}if(!0===n[cidSymbol$2]){const{version:t,multihash:r,code:o}=n,i=decode$z(r);return e.create(t,o,i)}return null}static create(t,n,r){if("number"!=typeof n)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:if(n!==DAG_PB_CODE$3)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$3}) block encoding`);return new e(t,n,r,r.bytes);case 1:{const o=encodeCID$2(t,n,r.bytes);return new e(t,n,r,o)}default:throw new Error("Invalid version")}}static createV0(t){return e.create(0,DAG_PB_CODE$3,t)}static createV1(t,n){return e.create(1,t,n)}static decode(t){const[n,r]=e.decodeFirst(t);if(0!==r.length)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=e.inspectBytes(t),r=n.size-n.multihashSize,o=coerce$2(t.subarray(r,r+n.multihashSize));if(o.byteLength!==n.multihashSize)throw new Error("Incorrect length");const i=o.subarray(n.multihashSize-n.digestSize),s=new Digest$5(n.multihashCode,n.digestSize,i,o);return[0===n.version?e.createV0(s):e.createV1(n.codec,s),t.subarray(n.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=decode$A(e.subarray(t));return t+=r,n};let r=n(),o=DAG_PB_CODE$3;if(18===r?(r=0,t=0):o=n(),0!==r&&1!==r)throw new RangeError(`Invalid CID version ${r}`);const i=t,s=n(),a=n(),c=t+a;return{version:r,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(t,n){const[r,o]=parseCIDtoBytes$2(t,n),i=e.decode(o);if(0===i.version&&"Q"!==t[0])throw Error("Version 0 CID string must not include multibase prefix");return baseCache$2(i).set(r,t),i}};function parseCIDtoBytes$2(e,t){switch(e[0]){case"Q":{const n=t??base58btc$2;return[base58btc$2.prefix,n.decode(`${base58btc$2.prefix}${e}`)]}case base58btc$2.prefix:{const n=t??base58btc$2;return[base58btc$2.prefix,n.decode(e)]}case base32$2.prefix:{const n=t??base32$2;return[base32$2.prefix,n.decode(e)]}case base36.prefix:{const n=t??base36;return[base36.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}function toStringV0$2(e,t,n){const{prefix:r}=n;if(r!==base58btc$2.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const o=t.get(r);if(null==o){const o=n.encode(e).slice(1);return t.set(r,o),o}return o}function toStringV1$2(e,t,n){const{prefix:r}=n,o=t.get(r);if(null==o){const o=n.encode(e);return t.set(r,o),o}return o}const DAG_PB_CODE$3=112,SHA_256_CODE$2=18;function encodeCID$2(e,t,n){const r=encodingLength$3(e),o=r+encodingLength$3(t),i=new Uint8Array(o+n.byteLength);return encodeTo$3(e,i,0),encodeTo$3(t,i,r),i.set(n,o),i}const cidSymbol$2=Symbol.for("@ipld/js-cid/CID"),CID_CBOR_TAG=42;function toByteView$2(e){return e instanceof ArrayBuffer?new Uint8Array(e,0,e.byteLength):e}function cidEncoder$1(e){if(e.asCID!==e&&e["/"]!==e.bytes)return null;const t=CID$2.asCID(e);if(!t)return null;const n=new Uint8Array(t.bytes.byteLength+1);return n.set(t.bytes,1),[new Token(Type.tag,CID_CBOR_TAG),new Token(Type.bytes,n)]}function undefinedEncoder$1(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const _encodeOptions={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID$2.decode(e.subarray(1))}_encodeOptions.typeEncoders;const _decodeOptions={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};_decodeOptions.tags[CID_CBOR_TAG]=cidDecoder,_decodeOptions.tags.slice();const name$9="dag-cbor",code$g=113,encode$q=e=>encode$t(e,_encodeOptions),decode$y=e=>decode$D(toByteView$2(e),_decodeOptions),encoder=new TextEncoder,decoder=new TextDecoder,encode$p=e=>encoder.encode(e),decode$x=e=>decoder.decode(e),DAG_PB_CODE$2=112;function createLegacy(e){return CID$2.create(0,DAG_PB_CODE$2,e)}function create$g(e,t){return CID$2.create(1,e,t)}function isLink(e){if(null==e)return!1;const t=e;if(null!=t["/"]&&t["/"]===t.bytes)return!0;return e.asCID===e}function parse$2(e,t){return CID$2.parse(e,t)}const code$f=0,name$8="identity",encode$o=coerce$2;function digest$3(e){return create$h(code$f,encode$o(e))}const identity={code:code$f,name:name$8,encode:encode$o,digest:digest$3};function from$f({name:e,code:t,encode:n}){return new Hasher$4(e,t,n)}let Hasher$4=class{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?create$h(this.code,t):t.then((e=>create$h(this.code,e)))}throw Error("Unknown type, must be binary type")}};const DID_PREFIX="did:",DID_PREFIX_SIZE=DID_PREFIX.length,DID_KEY_PREFIX="did:key:",DID_KEY_PREFIX_SIZE=DID_KEY_PREFIX.length,ED25519=237,RSA$1=4613,P256=4608,P384=4609,P521=4610,SECP256K1=231,BLS12381G1$1=234,BLS12381G2$1=235,DID_CORE=3357,METHOD_OFFSET=encodingLength$3(DID_CORE),parse$1=e=>{if(e.startsWith(DID_PREFIX)){if(e.startsWith(DID_KEY_PREFIX)){const t=base58btc$2.decode(e.slice(DID_KEY_PREFIX_SIZE));return decode$w(t)}{const t=encode$p(e.slice(DID_PREFIX_SIZE)),n=new Uint8Array(t.byteLength+METHOD_OFFSET);return encodeTo$3(DID_CORE,n),n.set(t,METHOD_OFFSET),new DID$1(n)}}throw new RangeError(`Invalid DID "${e}", must start with 'did:'`)},format$5=e=>e.did(),from$e=e=>e instanceof DID$1?e:e instanceof Uint8Array?decode$w(e):parse$1("string"==typeof e?e:e.did()),decode$w=e=>{const[t]=decode$A(e),{buffer:n,byteOffset:r,byteLength:o}=e;switch(t){case P256:if(e.length>35)throw new RangeError("Only p256-pub compressed is supported.");case ED25519:case RSA$1:case P384:case P521:case BLS12381G1$1:case BLS12381G2$1:case SECP256K1:return new DIDKey(n,r,o);case DID_CORE:return new DID$1(n,r,o);default:throw new RangeError(`Unsupported DID encoding, unknown multicode 0x${t.toString(16)}.`)}};let DID$1=class extends Uint8Array{did(){const e=new Uint8Array(this.buffer,this.byteOffset+METHOD_OFFSET);return`did:${decode$x(e)}`}toJSON(){return this.did()}};class DIDKey extends DID$1{did(){return`did:key:${base58btc$2.encode(this)}`}}const code$e=85,base64$1=rfc4648$2({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});rfc4648$2({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6});const base64url=rfc4648$2({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6});rfc4648$2({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});const NON_STANDARD=53248,ES256K=53479,BLS12381G1=53482,BLS12381G2=53483,EdDSA=53485,ES256=13636096,ES384=13636097,ES512=13636098,RS256=13636101,EIP191=53649,codeName=e=>{switch(e){case ES256K:return"ES256K";case BLS12381G1:return"BLS12381G1";case BLS12381G2:return"BLS12381G2";case EdDSA:return"EdDSA";case ES256:return"ES256";case ES384:return"ES384";case ES512:return"ES512";case RS256:return"RS256";case EIP191:return"EIP191";default:throw new RangeError(`Unknown signature algorithm code 0x${e.toString(16)}`)}},nameCode=e=>{switch(e){case"ES256K":return ES256K;case"BLS12381G1":return BLS12381G1;case"BLS12381G2":return BLS12381G2;case"EdDSA":return EdDSA;case"ES256":return ES256;case"ES384":return ES384;case"ES512":return ES512;case"RS256":return RS256;case"EIP191":return EIP191;default:return NON_STANDARD}};let Signature$1=class extends Uint8Array{get code(){const[e]=decode$A(this);return Object.defineProperties(this,{code:{value:e}}),e}get size(){const e=size$3(this);return Object.defineProperties(this,{size:{value:e}}),e}get algorithm(){const e=algorithm(this);return Object.defineProperties(this,{algorithm:{value:e}}),e}get raw(){const{buffer:e,byteOffset:t,size:n,code:r}=this,o=encodingLength$3(r),i=encodingLength$3(n),s=new Uint8Array(e,t+o+i,n);return Object.defineProperties(this,{raw:{value:s}}),s}async verify(e,t){try{if(!0===await e.verify(t,this))return{ok:{}};throw new Error("Invalid signature")}catch(e){return{error:e}}}toJSON(){return toJSON$1(this)}};const algorithm=e=>{const{code:t,raw:n,buffer:r,byteOffset:o}=e;if(t===NON_STANDARD){const e=n.byteLength+encodingLength$3(t)+encodingLength$3(n.byteLength),i=new Uint8Array(r,o+e);return decode$x(i)}return codeName(t)},size$3=e=>{const t=encodingLength$3(e.code),[n]=decode$A(new Uint8Array(e.buffer,e.byteOffset+t));return n},create$f=(e,t)=>{codeName(e);const n=encodingLength$3(e),r=encodingLength$3(t.byteLength),o=new Signature$1(n+r+t.byteLength);return encodeTo$3(e,o),encodeTo$3(t.byteLength,o,n),o.set(t,n+r),Object.defineProperties(o,{code:{value:e},size:{value:t.byteLength}}),o},createNamed=(e,t)=>{const n=nameCode(e);return n===NON_STANDARD?createNonStandard(e,t):create$f(n,t)},createNonStandard=(e,t)=>{const n=NON_STANDARD,r=encodingLength$3(n),o=encodingLength$3(t.byteLength),i=encode$p(e),s=new Signature$1(r+o+t.byteLength+i.byteLength);return encodeTo$3(n,s),encodeTo$3(t.byteLength,s,r),s.set(t,r+o),s.set(i,r+o+t.byteLength),s},view$4=e=>new Signature$1(e.buffer,e.byteOffset,e.byteLength),decode$v=e=>{if(!(e instanceof Uint8Array))throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(e)}`);const t=view$4(e),{code:n,algorithm:r,raw:o}=t;return t},encode$n=e=>decode$v(e),toJSON$1=e=>({"/":{bytes:base64$1.baseEncode(e)}}),readPayload=e=>readPayloadWith(e,{readPrincipal:readPrincipal,readProof:readProof}),readJWTPayload=e=>readPayloadWith(e,{readPrincipal:readStringPrincipal,readProof:readStringProof}),readPayloadWith=(e,{readPrincipal:t,readProof:n})=>({iss:t(e.iss,"iss"),aud:t(e.aud,"aud"),att:readCapabilities(e.att,"att"),prf:readOptionalArray(e.prf,n,"prf")||[],exp:readNullable(e.exp===1/0?null:e.exp,readInt$2,"exp"),nbf:readOptional(e.nbf,readInt$2,"nbf"),fct:readOptionalArray(e.fct,readFact,"fct")||[],nnc:readOptional(e.nnc,readString,"nnc")}),readSignature=e=>{if(e instanceof Uint8Array)return decode$v(e);throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(e)}`)},readInt$2=(e,t)=>Number.isInteger(e)?e:ParseError.throw(`Expected ${t} to be integer, instead got ${JSON.stringify(e)}`),readCapability=(e,t)=>readStruct(e,asCapability,t),readCapabilities=(e,t)=>readArray(e,readCapability,t),asCapability=e=>({...e,can:readAbility(e.can),with:readResource(e.with)}),readAbility=e=>"string"!=typeof e?ParseError.throw(`Capability has invalid 'can: ${JSON.stringify(e)}', value must be a string`):e.slice(1,-1).includes("/")?e.toLocaleLowerCase():"*"===e?e:ParseError.throw(`Capability has invalid 'can: "${e}"', value must have at least one path segment`),readResource=e=>"string"!=typeof e?ParseError.throw(`Capability has invalid 'with: ${JSON.stringify(e)}', value must be a string`):parseURL(e)||ParseError.throw(`Capability has invalid 'with: "${e}"', value must be a valid URI string`),parseURL=e=>{try{return new URL(e),e}catch(e){return null}},readArray=(e,t,n)=>Array.isArray(e)?e.map(((e,r)=>t(e,`${n}[${r}]`))):ParseError.throw(`${n} must be an array`),readOptionalArray=(e,t,n)=>void 0===e?e:readArray(e,t,n),readStruct=(e,t,n)=>null!=e&&"object"==typeof e?t(e):ParseError.throw(`${n} must be of type object, instead got ${e}`),readFact=(e,t)=>readStruct(e,Object,t),readProof=(e,t)=>isLink(e)?e:fail$1(`Expected ${t} to be IPLD link, instead got ${JSON.stringify(e)}`),readStringProof=(e,t)=>parseProof(readString(e,t)),parseProof=e=>{try{return parse$2(e)}catch(t){return create$g(code$e,identity.digest(encode$p(e)))}},readPrincipal=(e,t)=>decode$w(readBytes$1(e,t)),readStringPrincipal=(e,t)=>parse$1(readString(e,t)),readOptional=(e,t,n="Field")=>void 0!==e?t(e,n):void 0,readNullable=(e,t,n)=>null===e?null:t(e,n),readString=(e,t="Field")=>"string"==typeof e?e:fail$1(`${t} has invalid value ${e}`),readBytes$1=(e,t)=>e instanceof Uint8Array?e:fail$1(`Expected ${t} to be Uint8Array, instead got ${JSON.stringify(e)}`),readVersion=(e,t)=>/\d+\.\d+\.\d+/.test(e)?e:ParseError.throw(`Invalid version '${t}: ${JSON.stringify(e)}'`),readLiteral=(e,t,n)=>e===t?t:ParseError.throw(`Expected ${n} to be a ${JSON.stringify(t)} instead got ${JSON.stringify(e)}`);class ParseError extends TypeError{get name(){return"ParseError"}static throw(e){throw new this(e)}}const fail$1=e=>ParseError.throw(e);class JSONEncoder extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const t=this.inRecursive[this.inRecursive.length-1];t&&(t.type===Type.array&&(t.elements++,1!==t.elements&&e.push([44])),t.type===Type.map&&(t.elements++,1!==t.elements&&(t.elements%2==1?e.push([44]):e.push([58]))))}[Type.uint.major](e,t){this.prefix(e);const n=String(t.value),r=[];for(let e=0;e<n.length;e++)r[e]=n.charCodeAt(e);e.push(r)}[Type.negint.major](e,t){this[Type.uint.major](e,t)}[Type.bytes.major](e,t){throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)}[Type.string.major](e,t){this.prefix(e);const n=fromString$1(JSON.stringify(t.value));e.push(n.length>32?asU8A(n):n)}[Type.array.major](e,t){this.prefix(e),this.inRecursive.push({type:Type.array,elements:0}),e.push([91])}[Type.map.major](e,t){this.prefix(e),this.inRecursive.push({type:Type.map,elements:0}),e.push([123])}[Type.tag.major](e,t){}[Type.float.major](e,t){if("break"===t.type.name){const t=this.inRecursive.pop();if(t){if(t.type===Type.array)e.push([93]);else{if(t.type!==Type.map)throw new Error("Unexpected recursive type; this should not happen!");e.push([125])}return}throw new Error("Unexpected break; this should not happen!")}if(void 0===t.value)throw new Error(`${encodeErrPrefix} unsupported type: undefined`);if(this.prefix(e),"true"===t.type.name)return void e.push([116,114,117,101]);if("false"===t.type.name)return void e.push([102,97,108,115,101]);if("null"===t.type.name)return void e.push([110,117,108,108]);const n=String(t.value),r=[];let o=!1;for(let e=0;e<n.length;e++)r[e]=n.charCodeAt(e),o||46!==r[e]&&101!==r[e]&&69!==r[e]||(o=!0);o||(r.push(46),r.push(48)),e.push(r)}}function mapSorter(e,t){if(Array.isArray(e[0])||Array.isArray(t[0]))throw new Error(`${encodeErrPrefix} complex map keys are not supported`);const n=e[0],r=t[0];if(n.type!==Type.string||r.type!==Type.string)throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);if(n<r)return-1;if(n>r)return 1;throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)}const defaultEncodeOptions$1={addBreakTokens:!0,mapSorter:mapSorter};function encode$m(e,t){return t=Object.assign({},defaultEncodeOptions$1,t),encodeCustom(e,new JSONEncoder,t)}class Tokenizer{constructor(e,t={}){this._pos=0,this.data=e,this.options=t,this.modeStack=["value"],this.lastToken=""}pos(){return this._pos}done(){return this._pos>=this.data.length}ch(){return this.data[this._pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;32===e||9===e||13===e||10===e;)e=this.data[++this._pos]}expect(e){if(this.data.length-this._pos<e.length)throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);for(let t=0;t<e.length;t++)if(this.data[this._pos++]!==e[t])throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...e)}'`)}parseNumber(){const e=this._pos;let t=!1,n=!1;const r=e=>{for(;!this.done();){const t=this.ch();if(!e.includes(t))break;this._pos++}};if(45===this.ch()&&(t=!0,this._pos++),48===this.ch()){if(this._pos++,46!==this.ch())return new Token(Type.uint,0,this._pos-e);this._pos++,n=!0}if(r([48,49,50,51,52,53,54,55,56,57]),t&&this._pos===e+1)throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);if(!this.done()&&46===this.ch()){if(n)throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);n=!0,this._pos++,r([48,49,50,51,52,53,54,55,56,57])}this.done()||101!==this.ch()&&69!==this.ch()||(n=!0,this._pos++,this.done()||43!==this.ch()&&45!==this.ch()||this._pos++,r([48,49,50,51,52,53,54,55,56,57]));const o=String.fromCharCode.apply(null,this.data.subarray(e,this._pos)),i=parseFloat(o);return n?new Token(Type.float,i,this._pos-e):!0!==this.options.allowBigInt||Number.isSafeInteger(i)?new Token(i>=0?Type.uint:Type.negint,i,this._pos-e):new Token(i>=0?Type.uint:Type.negint,BigInt(o),this._pos-e)}parseString(){if(34!==this.ch())throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);this._pos++;for(let e=this._pos,t=0;e<this.data.length&&t<65536;e++,t++){const n=this.data[e];if(92===n||n<32||n>=128)break;if(34===n){const n=String.fromCharCode.apply(null,this.data.subarray(this._pos,e));return this._pos=e+1,new Token(Type.string,n,t)}}const e=this._pos,t=[],n=()=>{if(this._pos+4>=this.data.length)throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);let e=0;for(let t=0;t<4;t++){let t=this.ch();if(t>=48&&t<=57)t-=48;else if(t>=97&&t<=102)t=t-97+10;else{if(!(t>=65&&t<=70))throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);t=t-65+10}e=16*e+t,this._pos++}return e},r=()=>{const e=this.ch();let n,r,o,i,s=null,a=e>239?4:e>223?3:e>191?2:1;if(this._pos+a>this.data.length)throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);switch(a){case 1:e<128&&(s=e);break;case 2:n=this.data[this._pos+1],128==(192&n)&&(i=(31&e)<<6|63&n,i>127&&(s=i));break;case 3:n=this.data[this._pos+1],r=this.data[this._pos+2],128==(192&n)&&128==(192&r)&&(i=(15&e)<<12|(63&n)<<6|63&r,i>2047&&(i<55296||i>57343)&&(s=i));break;case 4:n=this.data[this._pos+1],r=this.data[this._pos+2],o=this.data[this._pos+3],128==(192&n)&&128==(192&r)&&128==(192&o)&&(i=(15&e)<<18|(63&n)<<12|(63&r)<<6|63&o,i>65535&&i<1114112&&(s=i))}null===s?(s=65533,a=1):s>65535&&(s-=65536,t.push(s>>>10&1023|55296),s=56320|1023&s),t.push(s),this._pos+=a};for(;!this.done();){const o=this.ch();let i;switch(o){case 92:if(this._pos++,this.done())throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);switch(i=this.ch(),this._pos++,i){case 34:case 39:case 92:case 47:t.push(i);break;case 98:t.push(8);break;case 116:t.push(9);break;case 110:t.push(10);break;case 102:t.push(12);break;case 114:t.push(13);break;case 117:t.push(n());break;default:throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)}break;case 34:return this._pos++,new Token(Type.string,decodeCodePointsArray(t),this._pos-e);default:if(o<32)throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);o<128?(t.push(o),this._pos++):r()}}throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this._pos++,new Token(Type.map,1/0,1);case 91:return this.modeStack.push("array-start"),this._pos++,new Token(Type.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new Token(Type.null,null,4);case 102:return this.expect([102,97,108,115,101]),new Token(Type.false,!1,5);case 116:return this.expect([116,114,117,101]),new Token(Type.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":if(this.modeStack.pop(),93===this.ch())return this._pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(44!==this.ch())throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue();case"array-start":return this.modeStack.pop(),93===this.ch()?(this._pos++,this.skipWhitespace(),new Token(Type.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(125===this.ch())return this.modeStack.pop(),this._pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(44!==this.ch())throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this._pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),125===this.ch())return this._pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),58!==this.ch())throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)}}}function decode$u(e,t){return decode$D(e,t=Object.assign({tokenizer:new Tokenizer(e,t)},t))}function toByteView$1(e){return e instanceof ArrayBuffer?new Uint8Array(e,0,e.byteLength):e}function cidEncoder(e){if(e.asCID!==e&&e["/"]!==e.bytes)return null;const t=CID$2.asCID(e);if(!t)return null;const n=t.toString();return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.string,n,n.length),new Token(Type.break,void 0,1)]}function bytesEncoder(e){const t=base64$1.encode(e).slice(1);return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.map,1/0,1),new Token(Type.string,"bytes",5),new Token(Type.string,t,t.length),new Token(Type.break,void 0,1),new Token(Type.break,void 0,1)]}function taBytesEncoder(e){return bytesEncoder(new Uint8Array(e.buffer,e.byteOffset,e.byteLength))}function abBytesEncoder(e){return bytesEncoder(new Uint8Array(e))}function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions={typeEncoders:{Object:cidEncoder,Buffer:bytesEncoder,Uint8Array:bytesEncoder,Int8Array:taBytesEncoder,Uint16Array:taBytesEncoder,Int16Array:taBytesEncoder,Uint32Array:taBytesEncoder,Int32Array:taBytesEncoder,Float32Array:taBytesEncoder,Float64Array:taBytesEncoder,Uint8ClampedArray:taBytesEncoder,BigInt64Array:taBytesEncoder,BigUint64Array:taBytesEncoder,DataView:taBytesEncoder,ArrayBuffer:abBytesEncoder,undefined:undefinedEncoder,number:numberEncoder}};class DagJsonTokenizer extends Tokenizer{constructor(e,t){super(e,t),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===Type.map){const e=this._next();if(e.type===Type.string&&"/"===e.value){const e=this._next();if(e.type===Type.string){if(this._next().type!==Type.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new Token(Type.tag,42,0)}if(e.type===Type.map){const e=this._next();if(e.type===Type.string&&"bytes"===e.value){const e=this._next();if(e.type===Type.string){for(let e=0;e<2;e++){if(this._next().type!==Type.break)throw new Error("Invalid encoded Bytes form")}const t=base64$1.decode(`m${e.value}`);return new Token(Type.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};decodeOptions.tags[42]=CID$2.parse;const encode$l=e=>encode$m(e,encodeOptions),decode$t=e=>{const t=toByteView$1(e);return decode$u(t,Object.assign(decodeOptions,{tokenizer:new DagJsonTokenizer(t,decodeOptions)}))};new TextDecoder,new TextEncoder;const format$4=e=>`${formatHeader(e.v,e.s.algorithm)}.${formatPayload(e)}.${formatSignature(e.s)}`,formatSignPayload=(e,t,n)=>`${formatHeader(t,n)}.${formatPayload(e)}`,formatHeader=(e,t)=>base64url.baseEncode(encodeHeader$1(e,t)),formatPayload=e=>base64url.baseEncode(encodePayload(e)),formatSignature=e=>base64url.baseEncode(e.raw),encodeHeader$1=(e,t)=>encode$l({alg:t,ucv:e,typ:"JWT"}),encodePayload=e=>encode$l({iss:format$5(e.iss),aud:format$5(e.aud),att:e.att,exp:e.exp,prf:e.prf.map(encodeProof),...e.fct.length>0&&{fct:e.fct},...e.nnc&&{nnc:e.nnc},...e.nbf&&{nbf:e.nbf}}),encodeProof=e=>e.toString(),toJSON=e=>JSON.parse(decode$x(encode$l(e)));let View$1=class{constructor(e){this.model=e}get version(){return this.model.v}get issuer(){return from$e(this.model.iss)}get audience(){return from$e(this.model.aud)}get capabilities(){return this.model.att}get expiration(){const{exp:e}=this.model;return null===e?1/0:e}get notBefore(){return this.model.nbf}get nonce(){return this.model.nnc}get facts(){return this.model.fct}get proofs(){return this.model.prf}get signature(){return this.model.s}get jwt(){return this.model.jwt}get s(){return this.model.s}get v(){return this.model.v}get iss(){return this.model.iss}get aud(){return this.model.aud}get att(){return this.model.att}get exp(){return this.model.exp}get nbf(){return this.model.nbf}get nnc(){return this.model.nnc}get fct(){return this.model.fct}get prf(){return this.model.prf}toJSON(){const{v:e,iss:t,aud:n,s:r,att:o,prf:i,exp:s,fct:a,nnc:c,nbf:d}=this.model;return{iss:t,aud:n,v:e,s:r,exp:s,...toJSON({att:o,prf:i,...a.length>0&&{fct:a}}),...null!=c&&{nnc:c},...d&&{nbf:d}}}};const code$d=code$g,from$d=e=>new CBORView(e),encode$k=e=>{const{fct:t,nnc:n,nbf:r,...o}=readPayload(e);return encode$q({...t.length>0&&{fct:t},...null!=n&&{nnc:n},...r&&{nbf:r},...o,v:readVersion(e.v,"v"),s:encodeSignature(e.s,"s")})},encodeSignature=(e,t)=>{try{return encode$n(e)}catch(n){throw new Error(`Expected signature ${t}, instead got ${JSON.stringify(e)}`,{cause:n})}},decode$s=e=>{const t=decode$y(e);return new CBORView({...readPayload(t),v:readVersion(t.v,"v"),s:readSignature(t.s)})};class CBORView extends View$1{get code(){return code$d}format(){return format$4(this.model)}encode(){return encode$k(this.model)}}const parse=e=>{const t=e.split("."),[n,r,o]=3===t.length?t:fail$1(`Can't parse UCAN: ${e}: Expected JWT format: 3 dot-separated base64url-encoded values.`),{ucv:i,alg:s}=parseHeader(n);return{...parsePayload(r),v:i,s:createNamed(s,base64url.baseDecode(o))}},parseHeader=e=>{const{ucv:t,alg:n,typ:r}=decode$t(base64url.baseDecode(e));return{typ:readLiteral(r,"JWT","typ"),ucv:readVersion(t,"ucv"),alg:readString(n,"alg")}},parsePayload=e=>{const t=decode$t(base64url.baseDecode(e));return readJWTPayload(t)},decode$r=e=>{const t=decode$x(e);return new JWTView({...parse(t),jwt:t})},encode$j=({jwt:e})=>encode$p(e),format$3=({jwt:e})=>e;class JWTView extends View$1{constructor(e){super(e),this.model=e}get code(){return code$e}format(){return format$3(this.model)}encode(){return encode$j(this.model)}}function sha$3(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const sha256$4=from$f({name:"sha2-256",code:18,encode:sha$3("SHA-256")}),VERSION="0.9.1",defaultHasher=sha256$4,decode$q=e=>{try{return decode$s(e)}catch(t){return decode$r(e)}},write$6=async(e,{hasher:t=defaultHasher}={})=>{const[n,r]=e.jwt?[code$e,encode$j(e)]:[code$d,encode$k(e)];return{bytes:r,cid:create$g(n,await t.digest(r)),data:e}},issue$2=async({issuer:e,audience:t,capabilities:n,lifetimeInSeconds:r=30,expiration:o=now()+r,notBefore:i,facts:s=[],proofs:a=[],nonce:c})=>{const d=VERSION,u=readPayload({iss:parse$1(e.did()),aud:parse$1(t.did()),att:n,fct:s,exp:o,nbf:i,prf:a,nnc:c}),l=encodeSignaturePayload(u,d,e.signatureAlgorithm);return from$d({...u,v:d,s:await e.sign(l)})},encodeSignaturePayload=(e,t,n)=>encode$p(formatSignPayload(e,t,n)),now=()=>Math.floor(Date.now()/1e3),contentType$7="application/vnd.ipld.dag-cbor",prepare$1=(e,t)=>{if(t.has(e))throw new TypeError("Can not encode circular structure");if(void 0===e&&0===t.size)return null;if(null===e)return null;if("symbol"==typeof e&&0===t.size)return null;if(isLink(e))return e;if(ArrayBuffer.isView(e))return e;if(Array.isArray(e)){t.add(e);const n=[];for(const r of e)n.push(void 0===r||"symbol"==typeof r?null:prepare$1(r,t));return n}if("function"==typeof e.toJSON){t.add(e);const n=e.toJSON();return prepare$1(n,t)}if("object"==typeof e){t.add(e);const n={};for(const[r,o]of Object.entries(e))void 0!==o&&"symbol"!=typeof o&&(n[r]=prepare$1(o,new Set(t)));return n}return e},encode$i=e=>encode$q(prepare$1(e,new Set)),link$3=async(e,{hasher:t=sha256$4}={})=>create$g(code$g,await t.digest(e)),write$5=async(e,t)=>{const n=encode$i(e);return{cid:await link$3(n,t),bytes:n}};var CBOR=Object.freeze({__proto__:null,code:code$g,contentType:contentType$7,decode:decode$y,encode:encode$i,link:link$3,name:name$9,write:write$5});const iterate$2=function*(e){e&&"object"==typeof e&&"iterateIPLDBlocks"in e&&"function"==typeof e.iterateIPLDBlocks&&(yield*e.iterateIPLDBlocks())},createStore=(e=[])=>{const t=new Map;return addEveryInto(e,t),t},EMBED_CODE=identity.code,get$i=(e,t,n)=>{if(e.multihash.code===EMBED_CODE)return{cid:e,bytes:e.multihash.digest};const r=t.get(`${e}`);return r||n},notFound=e=>{throw new Error(`Block for the ${e} is not found`)},writeInto=async(e,t,n={})=>{const r=n.codec||CBOR,o=n.hasher||sha256$4,i=r.encode(e),s=await o.digest(i),a=create$g(r.code,s);return t.set(a.toString(),{bytes:i,cid:a}),{bytes:i,cid:a,data:e}},addInto=({cid:e,bytes:t},n)=>(n.set(e.toString(),{bytes:t,cid:e}),{bytes:t,cid:e}),addEveryInto=(e,t)=>{for(const n of e)addInto(n,t)};var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},encode_1$3,hasRequiredEncode,decode$p,hasRequiredDecode,length$3,hasRequiredLength,varint$4,hasRequiredVarint;function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function requireEncode(){if(hasRequiredEncode)return encode_1$3;hasRequiredEncode=1,encode_1$3=function r(o,i,s){if(Number.MAX_SAFE_INTEGER&&o>Number.MAX_SAFE_INTEGER)throw r.bytes=0,new RangeError("Could not encode varint");i=i||[],s=s||0;var a=s;for(;o>=n;)i[s++]=255&o|e,o/=128;for(;o&t;)i[s++]=255&o|e,o>>>=7;return i[s]=0|o,r.bytes=s-a+1,i};var e=128,t=-128,n=Math.pow(2,31);return encode_1$3}function requireDecode(){if(hasRequiredDecode)return decode$p;hasRequiredDecode=1,decode$p=function n(r,o){var i,s=0,a=(o=o||0,0),c=o,d=r.length;do{if(c>=d||a>49)throw n.bytes=0,new RangeError("Could not decode varint");i=r[c++],s+=a<28?(i&t)<<a:(i&t)*Math.pow(2,a),a+=7}while(i>=e);return n.bytes=c-o,s};var e=128,t=127;return decode$p}function requireLength(){if(hasRequiredLength)return length$3;hasRequiredLength=1;var e=Math.pow(2,7),t=Math.pow(2,14),n=Math.pow(2,21),r=Math.pow(2,28),o=Math.pow(2,35),i=Math.pow(2,42),s=Math.pow(2,49),a=Math.pow(2,56),c=Math.pow(2,63);return length$3=function(d){return d<e?1:d<t?2:d<n?3:d<r?4:d<o?5:d<i?6:d<s?7:d<a?8:d<c?9:10}}function requireVarint(){return hasRequiredVarint?varint$4:(hasRequiredVarint=1,varint$4={encode:requireEncode(),decode:requireDecode(),encodingLength:requireLength()})}var varintExports=requireVarint(),varint$3=getDefaultExportFromCjs(varintExports);const CIDV0_BYTES$1={SHA2_256:18,LENGTH:32,DAG_PB:112},V2_HEADER_LENGTH=40;function decodeVarint$1(e,t){if(!e.length)throw new Error("Unexpected end of data");const n=varint$3.decode(e);return t.seek(varint$3.decode.bytes),n}function decodeV2Header(e){const t=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;return{version:2,characteristics:[t.getBigUint64(n,!0),t.getBigUint64(n+=8,!0)],dataOffset:Number(t.getBigUint64(n+=8,!0)),dataSize:Number(t.getBigUint64(n+=8,!0)),indexOffset:Number(t.getBigUint64(n+=8,!0))}}function getMultihashLength$1(e){varint$3.decode(e);const t=varint$3.decode.bytes,n=varint$3.decode(e.subarray(varint$3.decode.bytes));return t+varint$3.decode.bytes+n}const Kinds={Null:e=>null===e?e:void 0,Int:e=>Number.isInteger(e)?e:void 0,Float:e=>"number"==typeof e&&Number.isFinite(e)?e:void 0,String:e=>"string"==typeof e?e:void 0,Bool:e=>"boolean"==typeof e?e:void 0,Bytes:e=>e instanceof Uint8Array?e:void 0,Link:e=>null!==e&&"object"==typeof e&&e.asCID===e?e:void 0,List:e=>Array.isArray(e)?e:void 0,Map:e=>null===e||"object"!=typeof e||e.asCID===e||Array.isArray(e)||e instanceof Uint8Array?void 0:e},Types={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":Kinds.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(void 0!==Kinds.List(e)){for(let t=0;t<e.length;t++){let n=e[t];if(n=Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](n),void 0===n)return;if(n!==e[t]){const n=e.slice(0,t);for(let r=t;r<e.length;r++){let t=e[r];if(t=Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),void 0===t)return;n.push(t)}return n}}return e}},Int:Kinds.Int,CarV1HeaderOrV2Pragma:e=>{if(void 0===Kinds.Map(e))return;const t=Object.entries(e);let n=e,r=1;for(let o=0;o<t.length;o++){const[i,s]=t[o];switch(i){case"roots":{const r=Types["CarV1HeaderOrV2Pragma > roots (anon)"](e[i]);if(void 0===r)return;if(r!==s||n!==e){if(n===e){n={};for(let e=0;e<o;e++)n[t[e][0]]=t[e][1]}n.roots=r}}break;case"version":{r--;const a=Types.Int(e[i]);if(void 0===a)return;if(a!==s||n!==e){if(n===e){n={};for(let e=0;e<o;e++)n[t[e][0]]=t[e][1]}n.version=a}}break;default:return}}return r>0?void 0:n}},Reprs={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":Kinds.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(void 0!==Kinds.List(e)){for(let t=0;t<e.length;t++){let n=e[t];if(n=Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](n),void 0===n)return;if(n!==e[t]){const n=e.slice(0,t);for(let r=t;r<e.length;r++){let t=e[r];if(t=Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),void 0===t)return;n.push(t)}return n}}return e}},Int:Kinds.Int,CarV1HeaderOrV2Pragma:e=>{if(void 0===Kinds.Map(e))return;const t=Object.entries(e);let n=e,r=1;for(let o=0;o<t.length;o++){const[i,s]=t[o];switch(i){case"roots":{const r=Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](s);if(void 0===r)return;if(r!==s||n!==e){if(n===e){n={};for(let e=0;e<o;e++)n[t[e][0]]=t[e][1]}n.roots=r}}break;case"version":{r--;const i=Reprs.Int(s);if(void 0===i)return;if(i!==s||n!==e){if(n===e){n={};for(let e=0;e<o;e++)n[t[e][0]]=t[e][1]}n.version=i}}break;default:return}}return r>0?void 0:n}},CarV1HeaderOrV2Pragma={toTyped:Types.CarV1HeaderOrV2Pragma,toRepresentation:Reprs.CarV1HeaderOrV2Pragma};function readHeader$1(e,t){const n=decodeVarint$1(e.upTo(8),e);if(0===n)throw new Error("Invalid CAR header (zero length)");const r=e.exactly(n,!0),o=decode$y(r);if(void 0===CarV1HeaderOrV2Pragma.toTyped(o))throw new Error("Invalid CAR header format");if(1!==o.version&&2!==o.version||void 0!==t&&o.version!==t)throw new Error(`Invalid CAR version: ${o.version}${void 0!==t?` (expected ${t})`:""}`);if(1===o.version){if(!Array.isArray(o.roots))throw new Error("Invalid CAR header format");return o}if(void 0!==o.roots)throw new Error("Invalid CAR header format");const i=decodeV2Header(e.exactly(V2_HEADER_LENGTH,!0));e.seek(i.dataOffset-e.pos);const s=readHeader$1(e,1);return Object.assign(s,i)}function readCid$1(e){const t=e.exactly(2,!1);if(t[0]===CIDV0_BYTES$1.SHA2_256&&t[1]===CIDV0_BYTES$1.LENGTH){const t=decode$z(e.exactly(34,!0));return CID$2.create(0,CIDV0_BYTES$1.DAG_PB,t)}const n=decodeVarint$1(e.upTo(8),e);if(1!==n)throw new Error(`Unexpected CID version (${n})`);const r=decodeVarint$1(e.upTo(8),e),o=decode$z(e.exactly(getMultihashLength$1(e.upTo(8)),!0));return CID$2.create(n,r,o)}function readBlockHead$1(e){const t=e.pos;let n=decodeVarint$1(e.upTo(8),e);if(0===n)throw new Error("Invalid CAR section (zero length)");n+=e.pos-t;return{cid:readCid$1(e),length:n,blockLength:n-Number(e.pos-t)}}function fromBytes$5(e){let t=bytesReader$1(e);const n=readHeader$1(t);if(2===n.version){const e=t.pos-n.dataOffset;t=limitReader$1(t,n.dataSize-e)}const r=[];for(;t.upTo(8).length>0;){const{cid:e,blockLength:n}=readBlockHead$1(t);r.push({cid:e,bytes:t.exactly(n,!0)})}return{header:n,blocks:r}}function bytesReader$1(e){let t=0;return{upTo:n=>e.subarray(t,t+Math.min(n,e.length-t)),exactly(n,r=!1){if(n>e.length-t)throw new Error("Unexpected end of data");const o=e.subarray(t,t+n);return r&&(t+=n),o},seek(e){t+=e},get pos(){return t}}}function limitReader$1(e,t){let n=0;return{upTo(r){let o=e.upTo(r);return o.length+n>t&&(o=o.subarray(0,t-n)),o},exactly(r,o=!1){const i=e.exactly(r,o);if(i.length+n>t)throw new Error("Unexpected end of data");return o&&(n+=r),i},seek(t){n+=t,e.seek(t)},get pos(){return e.pos}}}class CarBufferReader{constructor(e,t){this._header=e,this._blocks=t,this._cids=void 0}get version(){return this._header.version}getRoots(){return this._header.roots}has(e){return this._blocks.some((t=>t.cid.equals(e)))}get(e){return this._blocks.find((t=>t.cid.equals(e)))}blocks(){return this._blocks}cids(){return this._cids||(this._cids=this._blocks.map((e=>e.cid))),this._cids}static fromBytes(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");const{header:t,blocks:n}=fromBytes$5(e);return new CarBufferReader(t,n)}}const cborEncoders=makeCborEncoders(),defaultEncodeOptions={float64:!1,quickEncodeToken:quickEncodeToken};function tokensToLength(e,t=cborEncoders,n=defaultEncodeOptions){if(Array.isArray(e)){let r=0;for(const o of e)r+=tokensToLength(o,t,n);return r}{const r=t[e.type.major];if(void 0===r.encodedSize||"function"!=typeof r.encodedSize)throw new Error(`Encoder for ${e.type.name} does not have an encodedSize()`);return r.encodedSize(e,n)}}class CarBufferWriter{constructor(e,t){this.bytes=e,this.byteOffset=t,this.roots=[],this.headerSize=t}addRoot(e,t){return addRoot(this,e,t),this}write(e){return addBlock(this,e),this}close(e){return close$7(this,e)}}const addRoot=(e,t,n={})=>{const{resize:r=!1}=n,{bytes:o,headerSize:i,byteOffset:s,roots:a}=e;e.roots.push(t);const c=headerLength(e);if(c>i){if(!(c-i+s<o.byteLength))throw a.pop(),new RangeError(`Buffer has no capacity for a new root ${t}`);if(!r)throw a.pop(),new RangeError(`Header of size ${i} has no capacity for new root ${t}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);resizeHeader(e,c)}},blockLength=({cid:e,bytes:t})=>{const n=e.bytes.byteLength+t.byteLength;return varint$3.encodingLength(n)+n},addBlock=(e,{cid:t,bytes:n})=>{const r=t.bytes.byteLength+n.byteLength,o=varint$3.encode(r);if(e.byteOffset+o.length+r>e.bytes.byteLength)throw new RangeError("Buffer has no capacity for this block");writeBytes(e,o),writeBytes(e,t.bytes),writeBytes(e,n)},close$7=(e,t={})=>{const{resize:n=!1}=t,{roots:r,bytes:o,byteOffset:i,headerSize:s}=e,a=encode$q({version:1,roots:r}),c=varint$3.encode(a.length),d=c.length+a.byteLength;if(0===s-d)return writeHeader(e,c,a),o.subarray(0,i);if(n)return resizeHeader(e,d),writeHeader(e,c,a),o.subarray(0,e.byteOffset);throw new RangeError("Header size was overestimated.\nYou can use close({ resize: true }) to resize header")},resizeHeader=(e,t)=>{const{bytes:n,headerSize:r}=e;n.set(n.subarray(r,e.byteOffset),t),e.byteOffset+=t-r,e.headerSize=t},writeBytes=(e,t)=>{e.bytes.set(t,e.byteOffset),e.byteOffset+=t.length},writeHeader=({bytes:e},t,n)=>{e.set(t),e.set(n,t.length)},headerPreludeTokens=[new Token(Type.map,2),new Token(Type.string,"version"),new Token(Type.uint,1),new Token(Type.string,"roots")],CID_TAG=new Token(Type.tag,42),calculateHeaderLength=e=>{const t=[...headerPreludeTokens];t.push(new Token(Type.array,e.length));for(const n of e)t.push(CID_TAG),t.push(new Token(Type.bytes,{length:n+1}));const n=tokensToLength(t);return varint$3.encodingLength(n)+n},headerLength=({roots:e})=>calculateHeaderLength(e.map((e=>e.bytes.byteLength))),createWriter$2=(e,t={})=>{const{roots:n=[],byteOffset:r=0,byteLength:o=e.byteLength,headerSize:i=headerLength({roots:n})}=t,s=new Uint8Array(e,r,o),a=new CarBufferWriter(s,i);for(const e of n)a.addRoot(e);return a},contentType$6="application/vnd.ipld.car",name$7="CAR",code$c=514;class Writer{constructor(e=[],t=0){this.written=new Set,this.blocks=e,this.byteLength=t}write(...e){for(const t of e){const e=t.cid.toString(base32$2);this.written.has(e)||(this.blocks.push(t),this.byteLength+=blockLength(t),this.written.add(e))}return this}flush(...e){const t=[];for(const n of e.reverse()){const e=n.cid.toString(base32$2);this.written.has(e)||(this.blocks.unshift(n),this.byteLength+=blockLength({cid:n.cid,bytes:n.bytes}),this.written.add(e)),t.unshift(n.cid)}this.byteLength+=headerLength({roots:t});const n=new ArrayBuffer(this.byteLength),r=createWriter$2(n,{roots:t});for(const e of this.blocks)r.write(e);return r.close()}}const createWriter$1=()=>new Writer,encode$h=({roots:e=[],blocks:t})=>{const n=new Writer;return t&&n.write(...t.values()),n.flush(...e)},decode$o=e=>{const t=CarBufferReader.fromBytes(e),n=[],r=new Map;for(const e of t.getRoots()){const r=t.get(e);r&&n.push(r)}for(const e of t.blocks())r.set(e.cid.toString(),e);return{roots:n,blocks:r}},link$2=async(e,{hasher:t=sha256$4}={})=>create$g(code$c,await t.digest(e)),write$4=async(e,t)=>{const n=encode$h(e);return{bytes:n,cid:await link$2(n,t)}};var car=Object.freeze({__proto__:null,code:code$c,contentType:contentType$6,createWriter:createWriter$1,decode:decode$o,encode:encode$h,link:link$2,name:name$7,write:write$4});const ok=e=>{if(null==e)throw new TypeError(`ok(${e}) is not allowed, consider ok({}) instead`);return{ok:e}},error$1=e=>{if(null==e)throw new TypeError(`error(${e}) is not allowed, consider passing an error instead`);return{error:e}},panic$1=e=>{throw new Failure(e)},fail=e=>({error:new Failure(e)});class Failure extends Error{describe(){return this.toString()}get message(){return this.describe()}toJSON(){const{name:e,message:t,stack:n}=this;return{name:e,message:t,stack:n}}}class API{constructor(e){this.settings=e}toString(){return`new ${this.constructor.name}()`}readWith(e,t){throw new Error("Abstract method readWith must be implemented by subclass")}read(e){return this.readWith(e,this.settings)}is(e){return!this.read(e)?.error}from(e){const t=this.read(e);if(t.error)throw t.error;return t.ok}optional(){return optional$1(this)}nullable(){return nullable(this)}array(){return array(this)}or(e){return or$9(this,e)}and(e){return and$4(this,e)}refine(e){return refine(this,e)}brand(e){return this}default(e){const t=this.from(e);if(void 0===t)throw new Error("Value of type undefined is not a valid default");return new Default({reader:this,value:t})}}class Unknown extends API{read(e){return{ok:e}}toString(){return"unknown()"}}const unknown=()=>new Unknown;class Nullable extends API{readWith(e,t){const n=t.read(e);return n.error?null===e?{ok:null}:{error:new UnionError({causes:[n.error,typeError({expect:"null",actual:e}).error]})}:n}toString(){return`${this.settings}.nullable()`}}const nullable=e=>new Nullable(e);class Optional extends API{optional(){return this}readWith(e,t){const n=t.read(e);return n.error&&void 0===e?{ok:void 0}:n}toString(){return`${this.settings}.optional()`}}class Default extends API{optional(){return this}readWith(e,{reader:t,value:n}){if(void 0===e)return{ok:n};{const r=t.read(e);return r.error||void 0!==r.ok?r:{ok:n}}}toString(){return`${this.settings.reader}.default(${JSON.stringify(this.settings.value)})`}get value(){return this.settings.value}}const optional$1=e=>new Optional(e);class ArrayOf extends API{readWith(e,t){if(!Array.isArray(e))return typeError({expect:"array",actual:e});const n=[];for(const[r,o]of e.entries()){const e=t.read(o);if(e.error)return memberError({at:r,cause:e.error});n.push(e.ok)}return{ok:n}}get element(){return this.settings}toString(){return`array(${this.element})`}}const array=e=>new ArrayOf(e);class Tuple extends API{readWith(e,t){if(!Array.isArray(e))return typeError({expect:"array",actual:e});if(e.length!==this.shape.length)return error(`Array must contain exactly ${this.shape.length} elements`);const n=[];for(const[r,o]of t.entries()){const t=o.read(e[r]);if(t.error)return memberError({at:r,cause:t.error});n[r]=t.ok}return{ok:n}}get shape(){return this.settings}toString(){return`tuple([${this.shape.map((e=>e.toString())).join(", ")}])`}}const tuple=e=>new Tuple(e);class Dictionary extends API{readWith(e,{key:t,value:n}){if("object"!=typeof e||null===e||Array.isArray(e))return typeError({expect:"dictionary",actual:e});const r={};for(const[o,i]of Object.entries(e)){const e=t.read(o);if(e.error)return memberError({at:o,cause:e.error});const s=n.read(i);if(s.error)return memberError({at:o,cause:s.error});void 0!==s.ok&&(r[e.ok]=s.ok)}return{ok:r}}get key(){return this.settings.key}get value(){return this.settings.value}partial(){const{key:e,value:t}=this.settings;return new Dictionary({key:e,value:optional$1(t)})}toString(){return`dictionary(${this.settings})`}}const dictionary=({value:e,key:t})=>new Dictionary({value:e,key:t||string()});class Union extends API{readWith(e,t){const n=[];for(const r of t){const t=r.read(e);if(!t.error)return t;n.push(t.error)}return{error:new UnionError({causes:n})}}get variants(){return this.settings}toString(){return`union([${this.variants.map((e=>e.toString())).join(", ")}])`}}const union=e=>new Union(e),or$9=(e,t)=>union([e,t]);class Intersection extends API{readWith(e,t){const n=[];for(const r of t){const t=r.read(e);t.error&&n.push(t.error)}return n.length>0?{error:new IntersectionError({causes:n})}:{ok:e}}toString(){return`intersection([${this.settings.map((e=>e.toString())).join(",")}])`}}const intersection$1=e=>new Intersection(e),and$4=(e,t)=>intersection$1([e,t]);let Boolean$1=class extends API{readWith(e){switch(e){case!0:case!1:return{ok:e};default:return typeError({expect:"boolean",actual:e})}}toString(){return"boolean()"}};const anyBoolean=new Boolean$1,boolean=()=>anyBoolean;class UnknownNumber extends API{greaterThan(e){return this.refine(greaterThan(e))}lessThan(e){return this.refine(lessThan(e))}refine(e){return new RefinedNumber({base:this,schema:e})}}class AnyNumber extends UnknownNumber{readWith(e){return"number"==typeof e?{ok:e}:typeError({expect:"number",actual:e})}toString(){return"number()"}}const anyNumber=new AnyNumber,number=()=>anyNumber;class RefinedNumber extends UnknownNumber{readWith(e,{base:t,schema:n}){const r=t.read(e);return r.error?r:n.read(r.ok)}toString(){return`${this.settings.base}.refine(${this.settings.schema})`}}class LessThan extends API{readWith(e,t){return e<t?{ok:e}:error(`Expected ${e} < ${t}`)}toString(){return`lessThan(${this.settings})`}}const lessThan=e=>new LessThan(e);class GreaterThan extends API{readWith(e,t){return e>t?{ok:e}:error(`Expected ${e} > ${t}`)}toString(){return`greaterThan(${this.settings})`}}const greaterThan=e=>new GreaterThan(e),Integer={read:e=>Number.isInteger(e)?{ok:e}:typeError({expect:"integer",actual:e}),toString:()=>"Integer"},anyInteger=anyNumber.refine(Integer),integer=()=>anyInteger,Float={read:e=>Number.isFinite(e)?{ok:e}:typeError({expect:"Float",actual:e}),toString:()=>"Float"};anyNumber.refine(Float);class UnknownString extends API{refine(e){return new RefinedString({base:this,schema:e})}startsWith(e){return this.refine(startsWith(e))}endsWith(e){return this.refine(endsWith(e))}toString(){return"string()"}}class RefinedString extends UnknownString{readWith(e,{base:t,schema:n}){const r=t.read(e);return r.error?r:n.read(r.ok)}toString(){return`${this.settings.base}.refine(${this.settings.schema})`}}class AnyString extends UnknownString{readWith(e){return"string"==typeof e?{ok:e}:typeError({expect:"string",actual:e})}}const anyString=new AnyString,string=()=>anyString;class BytesSchema extends API{readWith(e){return e instanceof Uint8Array?{ok:e}:typeError({expect:"Uint8Array",actual:e})}}const Bytes=new BytesSchema,bytes=()=>Bytes;class StartsWith extends API{readWith(e,t){return e.startsWith(t)?{ok:e}:error(`Expect string to start with "${t}" instead got "${e}"`)}get prefix(){return this.settings}toString(){return`startsWith("${this.prefix}")`}}const startsWith=e=>new StartsWith(e);class EndsWith extends API{readWith(e,t){return e.endsWith(t)?{ok:e}:error(`Expect string to end with "${t}" instead got "${e}"`)}get suffix(){return this.settings}toString(){return`endsWith("${this.suffix}")`}}const endsWith=e=>new EndsWith(e);class Refine extends API{readWith(e,{base:t,schema:n}){const r=t.read(e);return r.error?r:n.read(r.ok)}toString(){return`${this.settings.base}.refine(${this.settings.schema})`}}const refine=(e,t)=>new Refine({base:e,schema:t});class Literal extends API{readWith(e,t){return e!==t?{error:new LiteralError({expect:t,actual:e})}:{ok:t}}get value(){return this.settings}default(e=this.value){return super.default(e)}toString(){return`literal(${toString(this.value)})`}}const literal=e=>new Literal(e);class Struct extends API{readWith(e,t){if("object"!=typeof e||null===e||Array.isArray(e))return typeError({expect:"object",actual:e});const n=e,r={},o=Object.entries(t);for(const[e,t]of o){const o=t.read(n[e]);if(o.error)return memberError({at:e,cause:o.error});void 0!==o.ok&&(r[e]=o.ok)}return{ok:r}}partial(){return new Struct(Object.fromEntries(Object.entries(this.shape).map((([e,t])=>[e,optional$1(t)]))))}get shape(){return this.settings}toString(){return["struct({ ",...Object.entries(this.shape).map((([e,t])=>`${e}: ${t}`)).join(", ")," })"].join("")}create(e){return this.from(e||{})}extend(e){return new Struct({...this.shape,...e})}}const struct=e=>{const t={},n=Object.entries(e);for(const[e,r]of n)switch(typeof r){case"number":case"string":case"boolean":t[e]=literal(r);break;case"object":t[e]=null===r?literal(null):r;break;default:throw new Error(`Invalid struct field "${e}", expected schema or literal, instead got ${typeof r}`)}return new Struct(t)};class Variant extends API{readWith(e,t){if("object"!=typeof e||null===e||Array.isArray(e))return typeError({expect:"object",actual:e});const n=Object.keys(e),[r]=1===n.length?n:[],o=r?t[r]:void 0;if(o){const t=o.read(e[r]);return t.error?memberError({at:r,cause:t.error}):{ok:{[r]:t.ok}}}if(t._){const n=t._.read(e);return n.error?n:{ok:{_:n.ok}}}return error(r?`Expected an object with one of the these keys: ${Object.keys(t).sort().join(", ")} instead got object with key ${r}`:"Expected an object with a single key instead got object with keys "+n.sort().join(", "))}match(e,t){const n=this.read(e);if(n.error){if(void 0!==t)return[null,t];throw n.error}{const[e]=Object.keys(n.ok);return[e,n.ok[e]]}}create(e){return this.from(e)}}const variant=e=>new Variant(e),error=e=>({error:new SchemaError(e)});class SchemaError extends Failure{get name(){return"SchemaError"}describe(){return this.name}}let TypeError$1=class extends SchemaError{constructor({expect:e,actual:t}){super(),this.expect=e,this.actual=t}get name(){return"TypeError"}describe(){return`Expected value of type ${this.expect} instead got ${toString(this.actual)}`}};const typeError=e=>({error:new TypeError$1(e)}),toString=e=>{const t=typeof e;switch(t){case"boolean":case"string":return JSON.stringify(e);case"bigint":return`${e}n`;case"number":case"symbol":case"undefined":return String(e);case"object":return null===e?"null":Array.isArray(e)?"array":Symbol.toStringTag in e?e[Symbol.toStringTag]:"object";default:return t}};class LiteralError extends SchemaError{constructor({expect:e,actual:t}){super(),this.expect=e,this.actual=t}get name(){return"LiteralError"}describe(){return`Expected literal ${toString(this.expect)} instead got ${toString(this.actual)}`}}class ElementError extends SchemaError{constructor({at:e,cause:t}){super(),this.at=e,this.cause=t}get name(){return"ElementError"}describe(){return[`Array contains invalid element at ${this.at}:`,li$1(this.cause.message)].join("\n")}}class FieldError extends SchemaError{constructor({at:e,cause:t}){super(),this.at=e,this.cause=t}get name(){return"FieldError"}describe(){return[`Object contains invalid field "${this.at}":`,li$1(this.cause.message)].join("\n")}}const memberError=({at:e,cause:t})=>"string"==typeof e?{error:new FieldError({at:e,cause:t})}:{error:new ElementError({at:e,cause:t})};class UnionError extends SchemaError{constructor({causes:e}){super(),this.causes=e}get name(){return"UnionError"}describe(){const{causes:e}=this;return["Value does not match any type of the union:",...e.map((e=>li$1(e.message)))].join("\n")}}class IntersectionError extends SchemaError{constructor({causes:e}){super(),this.causes=e}get name(){return"IntersectionError"}describe(){const{causes:e}=this;return["Value does not match following types of the intersection:",...e.map((e=>li$1(e.message)))].join("\n")}}const indent$1=(e,t="  ")=>`${t}${e.split("\n").join(`\n${t}`)}`,li$1=e=>indent$1(`- ${e}`);class URISchema extends API{readWith(e,{protocol:t}={}){if("string"!=typeof e&&!(e instanceof URL))return error("Expected URI but got "+(null===e?"null":typeof e));try{const n=new URL(String(e));return null!=t&&n.protocol!==t?error(`Expected ${t} URI instead got ${n.href}`):{ok:n.href}}catch(e){return error("Invalid URI")}}}const match$3=e=>new URISchema(e);class LinkSchema extends API{readWith(e,{code:t,multihash:n={},version:r}){if(null==e)return error(`Expected link but got ${e} instead`);if(isLink(e)){if(null!=t&&e.code!==t)return error(`Expected link to be CID with 0x${t.toString(16)} codec`);if(null!=n.code&&e.multihash.code!==n.code)return error(`Expected link to be CID with 0x${n.code.toString(16)} hashing algorithm`);if(null!=r&&e.version!==r)return error(`Expected link to be CID version ${r} instead of ${e.version}`);const[o,i]=null!=n.digest?[base32$2.baseEncode(n.digest),base32$2.baseEncode(e.multihash.digest)]:["",""];return o!==i?error(`Expected link with "${o}" hash digest instead of "${i}"`):{ok:e}}return error(`Expected link to be a CID instead of ${e}`)}}const schema$2=new LinkSchema({}),link$1=()=>schema$2,match$2=(e={})=>new LinkSchema(e),read$5=e=>schema$2.read(e),optional=()=>schema$2.optional();var Link=Object.freeze({__proto__:null,create:create$g,createLegacy:createLegacy,isLink:isLink,link:link$1,match:match$2,optional:optional,parse:parse$2,read:read$5,schema:schema$2});class DIDSchema extends API{readWith(e,t){const n=t?`did:${t}:`:"did:";return e.startsWith(n)?{ok:e}:error(`Expected a ${n} but got "${e}" instead`)}}const schema$1=string().refine(new DIDSchema),did=()=>schema$1,read$4=e=>schema$1.read(e),match$1=(e={})=>string().refine(new DIDSchema(e.method)),from$c=e=>match$1({}).from(e);class DIDBytesSchema extends API{readWith(e,t){if(!(e instanceof Uint8Array))return typeError({expect:"Uint8Array",actual:e});let n;try{n=decode$w(e).did()}catch(e){return error(`Unable to parse bytes as did: ${e}`)}const r=t?`did:${t}:`:"did:";return n.startsWith(r)?{ok:n}:error(`Expected a ${r} but got "${n}" instead`)}}const schemaBytes=new DIDBytesSchema,didBytes=()=>schemaBytes,readBytes=e=>schemaBytes.read(e),matchBytes=(e={})=>new DIDBytesSchema(e.method),fromBytes$4=e=>matchBytes({}).from(e);var DID=Object.freeze({__proto__:null,did:did,didBytes:didBytes,from:from$c,fromBytes:fromBytes$4,match:match$1,matchBytes:matchBytes,read:read$4,readBytes:readBytes});const schema=string(),match=e=>e?schema.refine(new Match$1(e.pattern)):schema;let Match$1=class extends API{readWith(e,t){return t.test(e)?{ok:e}:error(`Expected to match ${t} but got "${e}" instead`)}};const isDelegation=e=>!isLink(e),allows=(...e)=>{let t={};for(const n of e)for(const{with:e,can:r,nb:o}of iterateCapabilities(n)){const n=t[e]||(t[e]={});(n[r]||(n[r]=[])).push({...o})}return t},iterateCapabilities=function*({issuer:e,capabilities:t,proofs:n}){for(const r of t)if("ucan:*"===r.with){yield{...r,with:e.did()};for(const e of n)if(isDelegation(e))for(const t of iterateCapabilities(e)){const e=matchAbility(t.can,r.can);e&&(yield{...t,can:e,nb:{...t.nb,...Object(r.nb)}})}}else yield r},matchAbility=(e,t)=>"*"===e?t:"*"===t||t.endsWith("/*")&&e.startsWith(t.slice(0,-1))?e:e.endsWith("/*")&&t.startsWith(e.slice(0,-1))?t:e===t?e:null;class Delegation{constructor(e,t=new Map){this.root=e,this.blocks=t,Object.defineProperties(this,{blocks:{enumerable:!1}})}get attachedLinks(){const e=new Set,t=this.data;for(const n of t.capabilities){const t=getLinksFromObject(n);for(const n of t)e.add(`${n}`)}for(const n of t.facts)if(isLink(n))e.add(`${n}`);else{const t=Object.values(n).filter((e=>isLink(e)));for(const n of t)e.add(`${n}`)}return e}get version(){return this.data.version}get signature(){return this.data.signature}get cid(){return this.root.cid}link(){return this.root.cid}get asCID(){return this.cid}get bytes(){return this.root.bytes}get data(){const e=decode$n(this.root);return Object.defineProperties(this,{data:{value:e,enumerable:!1}}),e}attach(e){if(!this.attachedLinks.has(`${e.cid.link()}`))throw new Error(`given block with ${e.cid} is not an attached link`);this.blocks.set(`${e.cid}`,e)}export(){return exportDAG(this.root,this.blocks,this.attachedLinks)}archive(){return archive$2(this)}iterateIPLDBlocks(){return exportDAG(this.root,this.blocks,this.attachedLinks)}get proofs(){return proofs(this)}get issuer(){return this.data.issuer}get audience(){return this.data.audience}get capabilities(){return this.data.capabilities}get expiration(){return this.data.expiration}get notBefore(){return this.data.notBefore}get nonce(){return this.data.nonce}get facts(){return this.data.facts}iterate(){return it(this)}delegate(){return this}buildIPLDView(){return this}toJSON(){return{...this.data.toJSON(),"/":this.cid.toString(),prf:this.proofs.map((e=>isDelegation(e)?e:{"/":e.toString()}))}}}const archive$2=async e=>{try{const t=new Map;for(const n of e.iterateIPLDBlocks())t.set(`${n.cid}`,n);const n=await write$5({[`ucan@${e.version}`]:e.root.cid});t.set(`${n.cid}`,n);const r=encode$h({roots:[n],blocks:t});return ok(r)}catch(e){return error$1(e)}},ArchiveSchema=variant({"ucan@0.9.1":match$2({version:1})}),extract$1=async e=>{try{const{roots:t,blocks:n}=decode$o(e),[r]=t;if(null==r)return error("CAR archive does not contain a root block");const{bytes:o}=r,i=decode$y(o),[,s]=ArchiveSchema.match(i);return ok(view$3({root:s,blocks:n}))}catch(e){return error$1(e)}},it=function*(e){for(const t of e.proofs)isDelegation(t)&&(yield*it(t),yield t)},decodeCache=new WeakMap,decode$n=({bytes:e})=>{const t=decodeCache.get(e);if(!t){const t=decode$q(e);return decodeCache.set(e,t),t}return t},delegate$3=async({issuer:e,audience:t,proofs:n=[],attachedBlocks:r=new Map,...o},i)=>{const s=[],a=new Map;for(const e of n)if(isDelegation(e)){s.push(e.cid);for(const t of e.export())a.set(t.cid.toString(),t)}else s.push(e);const c=await issue$2({...o,issuer:e,audience:t,proofs:s}),{cid:d,bytes:u}=await write$6(c,i);decodeCache.set(d,c);const l=new Delegation({cid:d,bytes:u},a);Object.defineProperties(l,{proofs:{value:n}});for(const e of r.values())l.attach(e);return l},exportDAG=function*(e,t,n){for(const n of decode$n(e).proofs){const e=t.get(`${n}`);e&&(yield*exportSubDAG(e,t))}for(const e of n.values()){const n=t.get(e);n&&(yield n)}yield e},exportSubDAG=function*(e,t){for(const n of decode$n(e).proofs){const e=t.get(`${n}`);e&&(yield*exportSubDAG(e,t))}yield e},importDAG=e=>{let t=[];for(const n of e)t.push([n.cid.toString(),n]);const n=t.pop();if(n){const[,e]=n;return new Delegation(e,new Map(t))}throw new RangeError("Empty DAG can not be turned into a delegation")},create$e=({root:e,blocks:t})=>new Delegation(e,t),view$3=({root:e,blocks:t},n)=>{const r=get$i(e,t,null);return null==r?void 0!==n?n:notFound(e):create$e({root:r,blocks:t})},proofs=e=>{const t=[],{root:n,blocks:r}=e;for(const e of decode$n(n).proofs){const n=r.get(e.toString());t.push(n?create$e({root:n,blocks:r}):e)}return Object.defineProperty(e,"proofs",{value:t}),t};function getLinksFromObject(e){const t=[];return function e(n){for(const r in n){const o=n[r];isLink(o)?t.push(o):o&&"object"==typeof o&&e(o)}}(e),t}const invoke=e=>new IssuedInvocation(e),create$d=({root:e,blocks:t})=>new Invocation(e,t),view$2=({root:e,blocks:t},n)=>{const r=get$i(e,t,null);return null==r?void 0!==n?n:notFound(e):create$d({root:r,blocks:t})};class IssuedInvocation{constructor({issuer:e,audience:t,capability:n,proofs:r=[],expiration:o,lifetimeInSeconds:i,notBefore:s,nonce:a,facts:c=[]}){this.issuer=e,this.audience=t,this.proofs=r,this.capabilities=[n],this.expiration=o,this.lifetimeInSeconds=i,this.notBefore=s,this.nonce=a,this.facts=c,this.attachedBlocks=new Map}attach(e){this.attachedBlocks.set(`${e.cid}`,e)}delegate(){return delegate$3(this)}buildIPLDView(){return delegate$3(this)}async execute(e){const[t]=await e.execute(this);return t}}class Invocation extends Delegation{}const view$1=({root:e,blocks:t},n)=>{const r=get$i(e,t,null);if(null==r)return void 0!==n?n:notFound(e);const o=decode$y(r.bytes);return new Receipt({root:{...r,data:o},store:t})};class Receipt{constructor({root:e,store:t,ran:n,issuer:r,signature:o,proofs:i}){this.store=t,this.root=e,this._ran=n,this._fx=void 0,this._signature=o,this._proofs=i,this._issuer=r}get ran(){const e=this._ran;if(e)return e;{const e=view$2({root:this.root.data.ocm.ran,blocks:this.store},this.root.data.ocm.ran);return this._ran=e,e}}get proofs(){const e=this._proofs;if(e)return e;{const{store:e,root:t}=this,{prf:n}=t.data.ocm,r=[];if(n)for(const t of n){const n=view$3({root:t,blocks:e},t);r.push(n)}return this._proofs=r,r}}link(){return this.root.cid}get meta(){return this.root.data.ocm.meta}get issuer(){const e=this._issuer;if(e)return e;{const{iss:e}=this.root.data.ocm;if(e){const t=parse$1(e);return this._issuer=t,t}}}get out(){return this.root.data.ocm.out}get fx(){let e=this._fx;if(!e){const{store:t}=this,{fork:n,join:r}=this.root.data.ocm.fx;e={fork:n.map((e=>view$2({root:e,blocks:t},e)))},r&&(e.join=view$2({root:r,blocks:t},r)),this._fx=e}return e}get signature(){const e=this._signature;if(e)return e;{const e=view$4(this.root.data.sig);return this._signature=e,e}}verifySignature(e){return this.signature.verify(e,encode$i(this.root.data.ocm))}buildIPLDView(){return this}*iterateIPLDBlocks(){const{ran:e,fx:t,proofs:n,root:r}=this;yield*iterate$2(e);for(const e of t.fork)yield*iterate$2(e);t.join&&(yield*iterate$2(t.join));for(const e of n)yield*iterate$2(e);yield r}}class ReceptBuilder{constructor({issuer:e,result:t,ran:n,fx:r=NOFX,proofs:o=[],meta:i={}}){this.issuer=e,this.result=t,this.ran=n,this.fx=r,this.proofs=o,this.meta=i}async buildIPLDView({hasher:e=sha256$4,codec:t=CBOR}={}){const n=createStore();addEveryInto(iterate$2(this.ran),n);const r=[];for(const e of this.proofs)addEveryInto(iterate$2(e),n),r.push(e.link());const o={fork:[]};for(const e of this.fx.fork)addEveryInto(iterate$2(e),n),o.fork.push(e.link());this.fx.join&&(addEveryInto(iterate$2(this.fx.join),n),o.join=this.fx.join.link());const i={ran:this.ran.link(),out:this.result,fx:o,meta:this.meta,iss:this.issuer.did(),prf:r},s=await this.issuer.sign(encode$i(i)),a={ocm:i,sig:s},c=await writeInto(a,n,{hasher:e,codec:t});return new Receipt({root:c,store:n,signature:s,proofs:this.proofs,ran:this.ran})}}const NOFX=Object.freeze({fork:Object.freeze([])}),issue$1=e=>new ReceptBuilder(e).buildIPLDView(),MessageSchema=variant({"ucanto/message@7.0.0":struct({execute:match$2().array().optional(),delegate:dictionary({key:string(),value:match$2()}).array().optional()})}),build$1=({invocations:e,receipts:t})=>new MessageBuilder({invocations:e,receipts:t}).buildIPLDView(),view=({root:e,store:t},n)=>{const r=get$i(e,t,null);if(null===r)return void 0!==n?n:notFound(e);const o=decode$y(r.bytes),[i,s]=MessageSchema.match(o,n);return"ucanto/message@7.0.0"===i?new Message({root:{...r,data:o},store:t}):s};class MessageBuilder{constructor({invocations:e,receipts:t}){this.invocations=e,this.receipts=t}async buildIPLDView(e){const t=new Map,{invocations:n,...r}=await writeInvocations(this.invocations||[],t),{receipts:o,...i}=await writeReceipts(this.receipts||[],t),s=await writeInto({"ucanto/message@7.0.0":{...r,...i}},t,e);return new Message({root:s,store:t},{receipts:o,invocations:n})}}const writeInvocations=async(e,t)=>{const n=[],r=[];for(const o of e){const e=await o.buildIPLDView();r.push(e.link()),n.push(e);for(const n of e.iterateIPLDBlocks())t.set(`${n.cid}`,n)}return{invocations:n,...r.length>0?{execute:r}:{}}},writeReceipts=async(e,t)=>{if(0===e.length)return{};const n=new Map,r={};for(const[o,i]of e.entries()){const e=await i.buildIPLDView();for(const n of e.iterateIPLDBlocks())t.set(`${n.cid}`,n);const s=`${e.ran.link()}`;s in r?n.set(`${s}@${o}`,e):(r[s]=e.root.cid,n.set(s,e))}return{receipts:n,report:r}};class Message{constructor({root:e,store:t},{invocations:n,receipts:r}={}){this.root=e,this.store=t,this._invocations=n,this._receipts=r}*iterateIPLDBlocks(){for(const e of this.invocations)yield*e.iterateIPLDBlocks();for(const e of this.receipts.values())yield*e.iterateIPLDBlocks();yield this.root}get(e,t){const n=(this.root.data["ucanto/message@7.0.0"].report||{})[`${e}`];return n?view$1({root:n,blocks:this.store}):void 0!==t?t:panic$1(`Message does not include receipt for ${e}`)}get invocationLinks(){return this.root.data["ucanto/message@7.0.0"].execute||[]}get invocations(){let e=this._invocations;return e||(e=this.invocationLinks.map((e=>view$2({root:e,blocks:this.store})))),e}get receipts(){let e=this._receipts;if(!e){e=new Map;const t=this.root.data["ucanto/message@7.0.0"].report||{};for(const[n,r]of Object.entries(t)){const t=view$1({root:r,blocks:this.store});e.set(`${t.ran.link()}`,t)}}return e}}const connect=e=>new Connection(e);class Connection{constructor(e){this.id=e.id,this.options=e,this.codec=e.codec,this.channel=e.channel,this.hasher=e.hasher||sha256$4}async execute(...e){return execute(e,this)}}const execute=async(e,t)=>{const n=await build$1({invocations:e}),r=await t.codec.encode(n,t),o=await t.channel.request(r);try{const e=await t.codec.decode(o),r=n.invocationLinks.map((t=>e.get(t)));return r}catch(e){const{message:r,name:o="Error",...i}=e,s=[];for await(const e of n.invocationLinks){const n=await issue$1({ran:e,result:{error:{...i,name:o,message:r}},issuer:{did:()=>t.id.did(),sign:()=>createNonStandard("",new Uint8Array)}});s.push(n)}return s}},contentType$5=contentType$6,HEADERS$2=Object.freeze({"content-type":contentType$5,accept:contentType$5}),encode$g=(e,t)=>{const n=new Map;for(const t of e.iterateIPLDBlocks())n.set(`${t.cid}`,t);const r=encode$h({roots:[e.root],blocks:n});return{headers:t?.headers||{...HEADERS$2},body:r}},decode$m=async({headers:e,body:t})=>{const{roots:n,blocks:r}=decode$o(t);return view({root:n[0].cid,store:r})};var request$3=Object.freeze({__proto__:null,codec:car,contentType:contentType$5,decode:decode$m,encode:encode$g});const contentType$4=contentType$6,HEADERS$1=Object.freeze({"content-type":contentType$4}),encode$f=(e,t)=>{const n=new Map;for(const t of e.iterateIPLDBlocks())n.set(`${t.cid}`,t);const r=encode$h({roots:[e.root],blocks:n});return{headers:{...HEADERS$1},body:r}},decode$l=async({headers:e,body:t})=>{const{roots:n,blocks:r}=decode$o(t);return view({root:n[0].cid,store:r})};var response$1=Object.freeze({__proto__:null,codec:car,contentType:contentType$4,decode:decode$l,encode:encode$f});const inbound=e=>new Inbound(e);class Inbound{accept({headers:e}){const t=e["content-type"]||e["Content-Type"],n=this.decoders[t];if(!n)return{error:{status:415,message:"The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.",headers:{accept:Object.keys(this.decoders).join(", ")}}};const r=parseAcceptHeader(e.accept||e.Accept||"*/*");for(const{category:e,type:t}of r)for(const r of this.encoders){if(!("*"!==e&&e!==r.category||"*"!==t&&t!==r.type))return{ok:{...r,decoder:n}}}return{error:{status:406,message:"The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.",headers:{accept:formatAcceptHeader(Object.values(this.encoders))}}}}constructor({decoders:e={},encoders:t={}}){if(this.decoders=e,0===Object.keys(e).length)throw new Error("At least one decoder MUST be provided");if(this.encoders=Object.entries(t).map((([e,t])=>({...parseMediaType(e),encoder:t}))).sort(((e,t)=>t.preference-e.preference)),0===this.encoders.length)throw new Error("At least one encoder MUST be provided")}}const outbound$1=e=>new Outbound(e);class Outbound{constructor({decoders:e={},encoders:t={}}){if(this.decoders=e,0===Object.keys(e).length)throw new Error("At least one decoder MUST be provided");if(this.encoders=Object.entries(t).map((([e,t])=>({...parseMediaType(e),encoder:t}))).sort(((e,t)=>t.preference-e.preference)),this.acceptType=formatAcceptHeader(this.encoders),0===this.encoders.length)throw new Error("At least one encoder MUST be provided");this.encoder=this.encoders[0].encoder}encode(e){return this.encoder.encode(e,{accept:this.acceptType})}decode(e){const{headers:t}=e,n=t["content-type"]||t["Content-Type"],r=this.decoders[n]||this.decoders["*/*"];switch(e.status){case 415:case 406:throw Object.assign(new RangeError((new TextDecoder).decode(e.body)),{status:e.status,headers:e.headers})}if(!r)throw Object.assign(TypeError(`Can not decode response with content-type '${n}' because no matching transport decoder is configured.`),{error:!0});return r.decode(e)}}const parseMediaType=e=>{const[t="*/*",n=""]=e.trim().split(";"),[r="*",o="*"]=t.split("/"),i=new URLSearchParams(n),s=parseFloat(i.get("q")||"0");return{category:r,type:o,preference:isNaN(s)?0:s}},formatMediaType=({category:e,type:t,preference:n})=>`${e}/${t}${n?`;q=${n}`:""}`,parseAcceptHeader=e=>e.split(",").map(parseMediaType).sort(((e,t)=>t.preference-e.preference)),formatAcceptHeader=e=>e.map(formatMediaType).join(", "),contentType$3=contentType$6;inbound({decoders:{[contentType$5]:request$3},encoders:{[contentType$4]:response$1}});const outbound=outbound$1({encoders:{[contentType$5]:request$3},decoders:{[contentType$4]:response$1}}),open$2=({url:e,method:t="POST",fetch:n})=>{if(!n){if(void 0===globalThis.fetch)throw new TypeError("ucanto HTTP transport got undefined `fetch`. Try passing in a `fetch` implementation explicitly.");n=globalThis.fetch.bind(globalThis)}return new Channel({url:e,method:t,fetch:n})};class Channel{constructor({url:e,fetch:t,method:n}){this.fetch=t,this.method=n,this.url=e}async request({headers:e,body:t}){const n=await this.fetch(this.url.href,{headers:e,body:t,method:this.method}),r=n.ok?await n.arrayBuffer():HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} → ${n.status}`,n);return{headers:n.headers.entries?Object.fromEntries(n.headers.entries()):{},body:new Uint8Array(r)}}}class HTTPError extends Error{static throw(e,t){throw new this(e,t)}constructor(e,{url:t,status:n=500,statusText:r="Server error"}){super(e),this.name="HTTPError",this.url=t,this.status=n,this.statusText=r}}const the=e=>e,entries$1=e=>Object.entries(e),combine=([e,...t])=>{const n=e.map((e=>[e]));for(const e of t){const t=n.splice(0);for(const r of e)for(const e of t)n.push([...e,r])}return n},intersection=(e,t)=>{const[n,r]=e.length<t.length?[new Set(e),new Set(t)]:[new Set(t),new Set(e)];for(const e of n)r.has(e)||n.delete(e);return[...n]};class EscalatedCapability extends Failure{constructor(e,t,n){super(),this.claimed=e,this.delegated=t,this.cause=n,this.name=the("EscalatedCapability")}describe(){return`Constraint violation: ${this.cause.message}`}}class DelegationError extends Failure{constructor(e,t){super(),this.name=the("InvalidClaim"),this.causes=e,this.context=t}describe(){return[`Can not derive ${this.context} from delegated capabilities:`,...this.causes.map((e=>li(e.message)))].join("\n")}get cause(){if(1!==this.causes.length)return this;{const[e]=this.causes,t="InvalidClaim"===e.name?e.cause:e;return Object.defineProperties(this,{cause:{value:t}}),t}}}class MalformedCapability extends Failure{constructor(e,t){super(),this.name=the("MalformedCapability"),this.capability=e,this.cause=t}describe(){return[`Encountered malformed '${this.capability.can}' capability: ${format$2(this.capability)}`,li(this.cause.message)].join("\n")}}class UnknownCapability extends Failure{constructor(e){super(),this.name=the("UnknownCapability"),this.capability=e}describe(){return`Encountered unknown capability: ${format$2(this.capability)}`}}const format$2=(e,t)=>JSON.stringify(e,((e,t)=>isLink(t)?t.toString():t),t),indent=(e,t="  ")=>`${t}${e.split("\n").join(`\n${t}`)}`,li=e=>indent(`- ${e}`),capability=({derives:e=defaultDerives,nb:t=defaultNBSchema,...n})=>new Capability({derives:e,nb:t,...n}),defaultNBSchema=struct({}),or$8=(e,t)=>new Or(e,t),and$3=(...e)=>new And(e),derive$1=({from:e,to:t,derives:n})=>new Derive(e,t,n);class View{match(e){return{error:new UnknownCapability(e.capability)}}select(e){return select(this,e)}derive({derives:e,to:t}){return derive$1({derives:e,to:t,from:this})}}class Unit extends View{or(e){return or$8(this,e)}and(e){return and$3(this,e)}}class Capability extends Unit{constructor(e){super(),this.descriptor=e,this.schema=struct({can:literal(e.can),with:e.with,nb:e.nb})}create(e){const{descriptor:t,can:n}=this;t.nb;const r=e.nb||{},o=t.with.read(e.with);if(o.error)throw Object.assign(new Error(`Invalid 'with' - ${o.error.message}`),{cause:o});const i=t.nb.read(r);if(i.error)throw Object.assign(new Error(`Invalid 'nb' - ${i.error.message}`),{cause:i});return createCapability({can:n,with:o.ok,nb:i.ok})}invoke({with:e,nb:t,...n}){return invoke({...n,capability:this.create({with:e,nb:t})})}async delegate({nb:e={},with:t,...n}){const{descriptor:r,can:o}=this;r.nb;const i=r.with.read(t);if(i.error)throw Object.assign(new Error(`Invalid 'with' - ${i.error.message}`),{cause:i});const s=r.nb.partial().read(e);if(s.error)throw Object.assign(new Error(`Invalid 'nb' - ${s.error.message}`),{cause:s});return delegate$3({capabilities:[createCapability({can:o,with:i.ok,nb:s.ok})],...n})}get can(){return this.descriptor.can}match(e){const t=parseCapability(this.descriptor,e);return t.error?t:{ok:new Match(e,t.ok,this.descriptor)}}toString(){return JSON.stringify({can:this.descriptor.can})}}const createCapability=({can:e,with:t,nb:n})=>({can:e,with:t,...isEmpty(n)?{}:{nb:n}}),isEmpty=e=>{for(const t in e)return!1;return!0};class Or extends Unit{constructor(e,t){super(),this.left=e,this.right=t}match(e){const t=this.left.match(e);if(t.error){const n=this.right.match(e);return n.error?"MalformedCapability"===n.error.name?n:t:n}return t}toString(){return`${this.left.toString()}|${this.right.toString()}`}}class And extends View{constructor(e){super(),this.selectors=e}match(e){const t=[];for(const n of this.selectors){const r=n.match(e);if(r.error)return r;t.push(r.ok)}return{ok:new AndMatch(t)}}select(e){return selectGroup(this,e)}and(e){return new And([...this.selectors,e])}toString(){return`[${this.selectors.map(String).join(", ")}]`}}class Derive extends Unit{constructor(e,t,n){super(),this.from=e,this.to=t,this.derives=n}create(e){return this.to.create(e)}invoke(e){return this.to.invoke(e)}delegate(e){return this.to.delegate(e)}get can(){return this.to.can}match(e){const t=this.to.match(e);return t.error?t:{ok:new DerivedMatch(t.ok,this.from,this.derives)}}toString(){return this.to.toString()}}class Match{constructor(e,t,n){this.source=[e],this.value=t,this.descriptor=n}get can(){return this.value.can}get proofs(){const e=[this.source[0].delegation];return Object.defineProperties(this,{proofs:{value:e}}),e}prune(e){return e.canIssue(this.value,this.source[0].delegation.issuer.did())?null:this}select(e){const t=[],n=[],r=[];for(const o of e){const e=resolveCapability(this.descriptor,this.value,o);if(e.ok){const t=this.descriptor.derives(this.value,e.ok);t.error?n.push(new DelegationError([new EscalatedCapability(this.value,e.ok,t.error)],this)):r.push(new Match(o,e.ok,this.descriptor))}else if("UnknownCapability"===e.error.name)t.push(e.error.capability);else n.push(new DelegationError([e.error],this))}return{matches:r,unknown:t,errors:n}}toString(){const{nb:e}=this.value;return JSON.stringify({can:this.descriptor.can,with:this.value.with,nb:e&&Object.keys(e).length>0?e:void 0})}}class DerivedMatch{constructor(e,t,n){this.selected=e,this.from=t,this.derives=n}get can(){return this.value.can}get source(){return this.selected.source}get proofs(){const e=[];for(const{delegation:t}of this.selected.source)e.push(t);return Object.defineProperties(this,{proofs:{value:e}}),e}get value(){return this.selected.value}prune(e){const t=this.selected.prune(e);return t?new DerivedMatch(t,this.from,this.derives):null}select(e){const{derives:t,selected:n,from:r}=this,{value:o}=n,i=n.select(e),s=r.select(e),a=[],c=[];for(const e of s.matches){const n=t(o,e.value);n.error?c.push(new DelegationError([new EscalatedCapability(o,e.value,n.error)],this)):a.push(e)}return{unknown:intersection(i.unknown,s.unknown),errors:[...c,...i.errors,...s.errors.map((e=>new DelegationError([e],this)))],matches:[...i.matches.map((e=>new DerivedMatch(e,r,t))),...a]}}toString(){return this.selected.toString()}}class AndMatch{constructor(e){this.matches=e}get selectors(){return this.matches}get source(){const e=[];for(const t of this.matches)e.push(...t.source);return Object.defineProperties(this,{source:{value:e}}),e}prune(e){const t=[];for(const n of this.matches){const r=n.prune(e);r&&t.push(r)}return 0===t.length?null:new AndMatch(t)}get proofs(){const e=[];for(const{delegation:t}of this.source)e.push(t);return Object.defineProperties(this,{proofs:{value:e}}),e}get value(){const e=[];for(const t of this.matches)e.push(t.value);return Object.defineProperties(this,{value:{value:e}}),e}select(e){return selectGroup(this,e)}toString(){return`[${this.matches.map((e=>e.toString())).join(", ")}]`}}const resolveAbility=(e,t,n)=>{switch(e){case t:case"*":return t;default:return e.endsWith("/*")&&t.startsWith(e.slice(0,-1))?t:n}},resolveResource=(e,t,n)=>{switch(e){case t:case"ucan:*":return t;default:return n}},parseCapability=(e,t)=>{const{delegation:n}=t,r=t.capability;if(e.can!==r.can)return{error:new UnknownCapability(r)};const o=e.with.read(r.with);if(o.error)return{error:new MalformedCapability(r,o.error)};const i=e.nb.read(r.nb||{});return i.error?{error:new MalformedCapability(r,i.error)}:{ok:new CapabilityView(e.can,o.ok,i.ok,n)}},resolveCapability=(e,t,{capability:n,delegation:r})=>{const o=resolveAbility(n.can,t.can,null);if(null==o)return{error:new UnknownCapability(n)};const i=resolveResource(n.with,t.with,n.with),s=e.with.read(i);if(s.error)return{error:new MalformedCapability(n,s.error)};const a=e.nb.read({...t.nb,...n.nb});return a.error?{error:new MalformedCapability(n,a.error)}:{ok:new CapabilityView(o,s.ok,a.ok,r)}};class CapabilityView{constructor(e,t,n,r){this.can=e,this.with=t,this.delegation=r,this.nb=n}}const select=(e,t)=>{const n=[],r=[],o=[];for(const i of t){const t=e.match(i);if(t.error)if("UnknownCapability"===t.error.name)n.push(t.error.capability);else o.push(new DelegationError([t.error],t.error.capability));else r.push(t.ok)}return{matches:r,errors:o,unknown:n}},selectGroup=(e,t)=>{let n;const r=[],o=[];for(const i of e.selectors){const s=i.select(t);n=n?intersection(n,s.unknown):s.unknown;for(const t of s.errors)o.push(new DelegationError([t],e));r.push(s.matches)}const i=combine(r).map((e=>new AndMatch(e)));return{unknown:n||[],errors:o,matches:i}},defaultDerives=(e,t)=>{if(t.with.endsWith("*")){if(!e.with.startsWith(t.with.slice(0,-1)))return error(`Resource ${e.with} does not match delegated ${t.with} `)}else if(t.with!==e.with)return error(`Resource ${e.with} is not contained by ${t.with}`);const n=t.nb||{},r=e.nb||{},o=entries$1(n);for(const[e,t]of o)if(r[e]!=t)return error(`${String(e)}: ${r[e]} violates ${t}`);return{ok:!0}};function equals$4(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}const ProviderDID$4=match$1({method:"web"}),SpaceDID$1=match$1({method:"key"}),AccountDID$1=match$1({method:"mailto"}),Await=struct({"ucan/await":tuple([string(),match$2()])});function equalWith(e,t){return e.with===t.with?ok({}):fail(`Can not derive ${e.can} with ${e.with} from ${t.with}`)}function equal(e,t,n){return void 0===t||"*"===t||String(e)===String(t)?ok({}):fail(`Constrain violation: ${e} violates imposed ${n} constraint ${t}`)}const equalLink=(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):t.nb.link&&`${t.nb.link}`!=`${e.nb.link}`?fail(`Link ${e.nb.link?`${e.nb.link}`:""} violates imposed ${t.nb.link} constraint.`):ok({}),equalBlob=(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):t.nb.blob.digest&&!equals$4(t.nb.blob.digest,e.nb.blob.digest)?fail(`Link ${e.nb.blob.digest?`${e.nb.blob.digest}`:""} violates imposed ${t.nb.blob.digest} constraint.`):void 0!==e.nb.blob.size&&void 0!==t.nb.blob.size&&e.nb.blob.size>t.nb.blob.size?fail(`Size constraint violation: ${e.nb.blob.size} > ${t.nb.blob.size}`):ok({}),equalBody=(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):t.nb.body.digest&&!equals$4(t.nb.body.digest,e.nb.body.digest)?fail(`Link ${e.nb.body.digest?`${e.nb.body.digest}`:""} violates imposed ${t.nb.body.digest} constraint.`):void 0!==e.nb.body.size&&void 0!==t.nb.body.size&&e.nb.body.size>t.nb.body.size?fail(`Size constraint violation: ${e.nb.body.size} > ${t.nb.body.size}`):ok({}),checkLink=(e,t,n)=>equal(String(e),void 0===t?void 0:String(t),n),and$2=e=>e.error?e:void 0;function parseAbility(e){const[t,...n]=e.split("/");return{namespace:t,segments:n}}function canDelegateAbility(e,t){const n=parseAbility(e),r=parseAbility(t);return"*"===n.namespace&&0===n.segments.length||("*"!==r.namespace||0!==r.segments.length)&&(n.namespace===r.namespace&&("*"===n.segments[0]||n.segments.length===r.segments.length&&n.segments.reduce(((e,t,n)=>e&&r.segments[n]===t),!0)))}const code$b=514,CARLink$1=match$2({code:code$b,version:1}),store$1=capability({can:"store/*",with:SpaceDID$1,derives:equalWith}),add$a=capability({can:"store/add",with:SpaceDID$1,nb:struct({link:CARLink$1,size:integer(),origin:optional()}),derives:(e,t)=>{const n=equalLink(e,t);return n.error?n:void 0!==e.nb.size&&void 0!==t.nb.size&&e.nb.size>t.nb.size?fail(`Size constraint violation: ${e.nb.size} > ${t.nb.size}`):ok({})}}),get$h=capability({can:"store/get",with:SpaceDID$1,nb:struct({link:CARLink$1.optional()}),derives:equalLink}),remove$8=capability({can:"store/remove",with:SpaceDID$1,nb:struct({link:CARLink$1}),derives:equalLink}),list$9=capability({can:"store/list",with:SpaceDID$1,nb:struct({cursor:string().optional(),size:integer().optional(),pre:boolean().optional()}),derives:(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):ok({})});add$a.or(remove$8).or(list$9);const upload$1=capability({can:"upload/*",with:SpaceDID$1,derives:equalWith}),CARLink=match$2({code:code$c,version:1}),add$9=capability({can:"upload/add",with:SpaceDID$1,nb:struct({root:Link,shards:CARLink.array().optional()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.root,t.nb.root,"root"))||and$2(equal(e.nb.shards,t.nb.shards,"shards"))||ok({})}),get$g=capability({can:"upload/get",with:SpaceDID$1,nb:struct({root:optional()}),derives:(e,t)=>{const n=equalWith(e,t);return n.error?n:t.nb.root?equal(e.nb.root,t.nb.root,"root"):n}}),remove$7=capability({can:"upload/remove",with:SpaceDID$1,nb:struct({root:Link}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.root,t.nb.root,"root"))||ok({})}),list$8=capability({can:"upload/list",with:SpaceDID$1,nb:struct({cursor:string().optional(),size:integer().optional(),pre:boolean().optional()})});add$9.or(remove$7).or(list$8);const top=capability({can:"*",with:or$9(match$1(),literal("ucan:*")),derives:equalWith}),space=capability({can:"space/*",with:SpaceDID$1,derives:equalWith}),info=add$a.or(list$9).or(remove$8).or(add$9).or(list$8).or(remove$7).derive({to:capability({can:"space/info",with:SpaceDID$1}),derives:equalWith});capability({can:"space/allocate",with:SpaceDID$1,nb:struct({size:integer()}),derives:(e,t)=>{const n=equalWith(e,t);return n.ok?e.nb.size<=t.nb.size?ok({}):fail(`Claimed size ${e.nb.size} escalates delegated size ${t.nb.size}`):n}});const contentServe=capability({can:"space/content/serve/*",with:SpaceDID$1,derives:equalWith}),egressRecord$1=capability({can:"space/content/serve/egress/record",with:SpaceDID$1,nb:struct({resource:match$2(),bytes:integer().greaterThan(0),servedAt:integer().greaterThan(-1)}),derives:equalWith}),UCANLink=match$2({version:1});capability({can:"ucan/*",with:match$1(),derives:equalWith});const revoke=capability({can:"ucan/revoke",with:match$1(),nb:struct({ucan:UCANLink,proof:UCANLink.array().optional()}),derives:(e,t)=>and$2(equalWith(e,t))??and$2(checkLink(e.nb.ucan,t.nb.ucan,"nb.ucan"))??equal((e.nb.proof??[]).join("/"),(t.nb.proof??[]).join("/"),"nb.proof")}),conclude$1=capability({can:"ucan/conclude",with:match$1(),nb:struct({receipt:match$2()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.receipt,t.nb.receipt,"nb.receipt"))||ok({})}),attest=capability({can:"ucan/attest",with:match$1(),nb:struct({proof:match$2({version:1})}),derives:(e,t)=>and$2(equalWith(e,t))??checkLink(e.nb.proof,t.nb.proof,"nb.proof")}),Account$1=match$1({method:"mailto"}),CapabilityRequest=struct({can:string()}),AuthorizationRequest=struct({iss:Account$1,att:CapabilityRequest.array()}),access$1=capability({can:"access/*",with:match$3({protocol:"did:"})}),authorize=capability({can:"access/authorize",with:match$1({method:"key"}),nb:AuthorizationRequest,derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.iss,t.nb.iss,"iss"))||and$2(subsetCapabilities(e.nb.att,t.nb.att))||ok({})});capability({can:"access/confirm",with:DID,nb:struct({cause:match$2({version:1}),iss:Account$1,aud:match$1(),att:CapabilityRequest.array()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.iss,t.nb.iss,"iss"))||and$2(equal(e.nb.aud,t.nb.aud,"aud"))||and$2(subsetCapabilities(e.nb.att,t.nb.att))||and$2(checkLink(e.nb.cause,t.nb.cause,"nb.cause"))||ok({})});const claim$2=capability({can:"access/claim",with:match$1({method:"key"}).or(match$1({method:"mailto"}))}),delegate$2=capability({can:"access/delegate",with:SpaceDID$1,nb:struct({delegations:dictionary({value:match$2()})}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(subsetsNbDelegations(e,t))||ok({})});function subsetsNbDelegations(e,t){const n=setDifference(delegatedCids(e),new Set(delegatedCids(t)));return n.size>0?fail(`unauthorized nb.delegations ${[...n].join(", ")}`):ok({})}const subsetCapabilities=(e,t)=>{const n=new Set(t.map((e=>e.can)));if(n.has("*"))return ok({});const r=setDifference(e.map((e=>e.can)),n);return r.size>0?fail(`unauthorized nb.att.can ${[...r].join(", ")}`):ok({})};function*delegatedCids(e){for(const t of Object.values(e.nb.delegations||{}))yield t.toString()}function setDifference(e,t){const n=new Set;for(const r of e)t.has(r)||n.add(r);return n}function fromEmail(e){const{domain:t,local:n}=parseEmail(e);return`did:mailto:${encodeURIComponent(t)}:${encodeURIComponent(n)}`}function toEmail(e){const t=e.split(":");if("mailto"!==t[1])throw new Error(`DID ${e} is not a mailto did.`);return`${decodeURIComponent(t[3])}@${decodeURIComponent(t[2])}`}function email(e){const{domain:t,local:n}=parseEmail(e);return`${n}@${t}`}function parseEmail(e){const t=e.split("@");if(t.length<2)throw new TypeError(`expected at least 2 @-delimtied segments, but got ${t.length}`);return{domain:t.at(-1)??"",local:t.slice(0,-1).join("@")}}function alloc(e=0){return new Uint8Array(e)}function allocUnsafe(e=0){return new Uint8Array(e)}function asUint8Array$1(e){return e}function compare(e,t){for(let n=0;n<e.byteLength;n++){if(e[n]<t[n])return-1;if(e[n]>t[n])return 1}return e.byteLength>t.byteLength?1:e.byteLength<t.byteLength?-1:0}function concat(e,t){null==t&&(t=e.reduce(((e,t)=>e+t.length),0));const n=allocUnsafe(t);let r=0;for(const t of e)n.set(t,r),r+=t.length;return asUint8Array$1(n)}baseX$2({prefix:"9",name:"base10",alphabet:"0123456789"}),rfc4648$2({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),rfc4648$2({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),rfc4648$2({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});const alphabet$1=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars=alphabet$1.reduce(((e,t,n)=>(e[n]=t,e)),[]),alphabetCharsToBytes=alphabet$1.reduce(((e,t,n)=>{const r=t.codePointAt(0);if(null==r)throw new Error(`Invalid character: ${t}`);return e[r]=n,e}),[]);function encode$e(e){return e.reduce(((e,t)=>e+=alphabetBytesToChars[t]),"")}function decode$k(e){const t=[];for(const n of e){const e=n.codePointAt(0);if(null==e)throw new Error(`Invalid character: ${n}`);const r=alphabetCharsToBytes[e];if(null==r)throw new Error(`Non-base256emoji character: ${n}`);t.push(r)}return new Uint8Array(t)}function bytesToDelegations(e){if(!(e instanceof Uint8Array)||0===e.length)throw new TypeError("Input should be a non-empty Uint8Array.");const t=CarBufferReader.fromBytes(e),n=t.getRoots(),r=[];for(const e of n){const n=t.get(e);if(!n)throw new Error("Failed to find root from raw delegation.");{const o=new Map;for(const n of t.blocks())n.cid.toString()!==e.toString()&&o.set(n.cid.toString(),n);r.push(new Delegation(n,o))}}return r}from$g({prefix:"🚀",name:"base256emoji",encode:encode$e,decode:decode$k}),rfc4648$2({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),from$g({prefix:"\0",name:"identity",encode:e=>toString$1(e),decode:e=>fromString(e)}),new TextEncoder,new TextDecoder;const delegate$1=async(e,{delegations:t,proofs:n=[],space:r=e.currentSpace()})=>{if(!r)return fail("Space must be specified");const o=Object.values(t).map((e=>[e.cid.toString(),e.cid])),{out:i}=await e.invokeAndExecute(delegate$2,{with:r,nb:{delegations:Object.fromEntries(o)},proofs:[...t,...n]});return i},request$2=async(e,{account:t,provider:n=e.connection.id.did(),audience:r=e.did(),access:o=spaceAccess})=>{const{out:i}=await e.invokeAndExecute(authorize,{audience:parse$1(n),with:r,nb:{iss:t,att:[...toCapabilities$1(o)]}});return i.error?i:{ok:new PendingAccessRequest({...i.ok,agent:e,audience:r,provider:n})}},claim$1=async(e,{provider:t=e.connection.id.did(),audience:n=e.did()}={})=>{const{out:r}=await e.invokeAndExecute(claim$2,{audience:parse$1(t),with:n});if(r.error)return r;{const t=Object.values(r.ok.delegations).flatMap((e=>bytesToDelegations(e)));return{ok:new GrantedAccess({agent:e,proofs:t})}}};class PendingAccessRequest{constructor(e){this.model=e}get agent(){return this.model.agent}get audience(){return this.model.audience}get expiration(){return new Date(1e3*this.model.expiration)}get request(){return this.model.request}get provider(){return this.model.provider}async poll(){const{agent:e,audience:t,provider:n,expiration:r}=this.model;if(1e3*r-Date.now()<=0)return{error:new RequestExpired(this.model)};{const r=await claim$1(e,{audience:t,provider:n});return r.error?r:{ok:r.ok.proofs.filter((e=>isRequestedAccess(e,this.model)))}}}async claim({signal:e,interval:t=250}={}){for(;!0!==e?.aborted;){const e=await this.poll();if(e.error)return e;if(e.ok.length>0)return{ok:new GrantedAccess({agent:this.agent,proofs:e.ok})};await new Promise((e=>setTimeout(e,t)))}return{error:Object.assign(new Error("Aborted"),{reason:e.reason})}}}class RequestExpired extends Failure{constructor(e){super(),this.model=e}get name(){return"RequestExpired"}get request(){return this.model.request}get expiredAt(){return new Date(1e3*this.model.expiration)}describe(){return`Access request expired at ${this.expiredAt} for ${this.request} request.`}}class GrantedAccess{constructor(e){this.model=e}get proofs(){return this.model.proofs}save({agent:e=this.model.agent}={}){return importAuthorization(e,this)}}const isRequestedAccess=(e,{request:t})=>e.facts.some((e=>`${e["access/request"]}`==`${t}`)),toCapabilities$1=e=>{const t=[],n=Object.entries(e);for(const[e,r]of n)r&&t.push({can:e});return t},spaceAccess={"space/*":{},"blob/*":{},"index/*":{},"store/*":{},"upload/*":{},"access/*":{},"filecoin/*":{},"usage/*":{}},accountAccess$1={"*":{}};var access=Object.freeze({__proto__:null,GrantedAccess:GrantedAccess,accountAccess:accountAccess$1,claim:claim$1,delegate:delegate$1,request:request$2,spaceAccess:spaceAccess,toCapabilities:toCapabilities$1}),_nodeResolve_empty={},nodeCrypto=Object.freeze({__proto__:null,default:_nodeResolve_empty});
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_8n=BigInt(8),CU_O=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),CURVE=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:CU_O,n:CU_O,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const SQRT_AD_MINUS_ONE=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),INVSQRT_A_MINUS_D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ONE_MINUS_D_SQ=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),D_MINUS_ONE_SQ=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(e,t,n,r){this.x=e,this.y=t,this.z=n,this.t=r}static fromAffine(e){if(!(e instanceof Point))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return e.equals(Point.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(e.x,e.y,_1n,mod(e.x*e.y))}static toAffineBatch(e){const t=invertBatch(e.map((e=>e.z)));return e.map(((e,n)=>e.toAffine(t[n])))}static normalizeZ(e){return this.toAffineBatch(e).map(this.fromAffine)}equals(e){assertExtPoint(e);const{x:t,y:n,z:r}=this,{x:o,y:i,z:s}=e,a=mod(t*s),c=mod(o*r),d=mod(n*s),u=mod(i*r);return a===c&&d===u}negate(){return new ExtendedPoint(mod(-this.x),this.y,this.z,mod(-this.t))}double(){const{x:e,y:t,z:n}=this,{a:r}=CURVE,o=mod(e*e),i=mod(t*t),s=mod(_2n*mod(n*n)),a=mod(r*o),c=e+t,d=mod(mod(c*c)-o-i),u=a+i,l=u-s,h=a-i,f=mod(d*l),p=mod(u*h),y=mod(d*h),g=mod(l*u);return new ExtendedPoint(f,p,g,y)}add(e){assertExtPoint(e);const{x:t,y:n,z:r,t:o}=this,{x:i,y:s,z:a,t:c}=e,d=mod((n-t)*(s+i)),u=mod((n+t)*(s-i)),l=mod(u-d);if(l===_0n)return this.double();const h=mod(r*_2n*c),f=mod(o*_2n*a),p=f+h,y=u+d,g=f-h,b=mod(p*l),w=mod(y*g),m=mod(p*g),$=mod(l*y);return new ExtendedPoint(b,w,$,m)}subtract(e){return this.add(e.negate())}precomputeWindow(e){const t=1+256/e,n=[];let r=this,o=r;for(let i=0;i<t;i++){o=r,n.push(o);for(let t=1;t<2**(e-1);t++)o=o.add(r),n.push(o);r=o.double()}return n}wNAF(e,t){!t&&this.equals(ExtendedPoint.BASE)&&(t=Point.BASE);const n=t&&t._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=t&&pointPrecomputes.get(t);r||(r=this.precomputeWindow(n),t&&1!==n&&(r=ExtendedPoint.normalizeZ(r),pointPrecomputes.set(t,r)));let o=ExtendedPoint.ZERO,i=ExtendedPoint.BASE;const s=1+256/n,a=2**(n-1),c=BigInt(2**n-1),d=2**n,u=BigInt(n);for(let t=0;t<s;t++){const n=t*a;let s=Number(e&c);e>>=u,s>a&&(s-=d,e+=_1n);const l=n,h=n+Math.abs(s)-1,f=t%2!=0,p=s<0;0===s?i=i.add(constTimeNegate(f,r[l])):o=o.add(constTimeNegate(p,r[h]))}return ExtendedPoint.normalizeZ([o,i])[0]}multiply(e,t){return this.wNAF(normalizeScalar(e,CURVE.l),t)}multiplyUnsafe(e){let t=normalizeScalar(e,CURVE.l,!1);const n=ExtendedPoint.BASE,r=ExtendedPoint.ZERO;if(t===_0n)return r;if(this.equals(r)||t===_1n)return this;if(this.equals(n))return this.wNAF(t);let o=r,i=this;for(;t>_0n;)t&_1n&&(o=o.add(i)),i=i.double(),t>>=_1n;return o}isSmallOrder(){return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){let e=this.multiplyUnsafe(CURVE.l/_2n).double();return CURVE.l%_2n&&(e=e.add(this)),e.equals(ExtendedPoint.ZERO)}toAffine(e){const{x:t,y:n,z:r}=this,o=this.equals(ExtendedPoint.ZERO);null==e&&(e=o?_8n:invert(r));const i=mod(t*e),s=mod(n*e),a=mod(r*e);if(o)return Point.ZERO;if(a!==_1n)throw new Error("invZ was invalid");return new Point(i,s)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}}function constTimeNegate(e,t){const n=t.negate();return e?n:t}function assertExtPoint(e){if(!(e instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function assertRstPoint(e){if(!(e instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function legacyRist(){throw new Error("Legacy method: switch to RistrettoPoint")}ExtendedPoint.BASE=new ExtendedPoint(CURVE.Gx,CURVE.Gy,_1n,mod(CURVE.Gx*CURVE.Gy)),ExtendedPoint.ZERO=new ExtendedPoint(_0n,_1n,_1n,_0n);class RistrettoPoint{constructor(e){this.ep=e}static calcElligatorRistrettoMap(e){const{d:t}=CURVE,n=mod(SQRT_M1*e*e),r=mod((n+_1n)*ONE_MINUS_D_SQ);let o=BigInt(-1);const i=mod((o-t*n)*mod(n+t));let{isValid:s,value:a}=uvRatio(r,i),c=mod(a*e);edIsNegative(c)||(c=mod(-c)),s||(a=c),s||(o=n);const d=mod(o*(n-_1n)*D_MINUS_ONE_SQ-i),u=a*a,l=mod((a+a)*i),h=mod(d*SQRT_AD_MINUS_ONE),f=mod(_1n-u),p=mod(_1n+u);return new ExtendedPoint(mod(l*p),mod(f*h),mod(h*p),mod(l*f))}static hashToCurve(e){const t=bytes255ToNumberLE((e=ensureBytes(e,64)).slice(0,32)),n=this.calcElligatorRistrettoMap(t),r=bytes255ToNumberLE(e.slice(32,64)),o=this.calcElligatorRistrettoMap(r);return new RistrettoPoint(n.add(o))}static fromHex(e){e=ensureBytes(e,32);const{a:t,d:n}=CURVE,r="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",o=bytes255ToNumberLE(e);if(!equalBytes(numberTo32BytesLE(o),e)||edIsNegative(o))throw new Error(r);const i=mod(o*o),s=mod(_1n+t*i),a=mod(_1n-t*i),c=mod(s*s),d=mod(a*a),u=mod(t*n*c-d),{isValid:l,value:h}=invertSqrt(mod(u*d)),f=mod(h*a),p=mod(h*f*u);let y=mod((o+o)*f);edIsNegative(y)&&(y=mod(-y));const g=mod(s*p),b=mod(y*g);if(!l||edIsNegative(b)||g===_0n)throw new Error(r);return new RistrettoPoint(new ExtendedPoint(y,g,_1n,b))}toRawBytes(){let{x:e,y:t,z:n,t:r}=this.ep;const o=mod(mod(n+t)*mod(n-t)),i=mod(e*t),s=mod(i*i),{value:a}=invertSqrt(mod(o*s)),c=mod(a*o),d=mod(a*i),u=mod(c*d*r);let l;if(edIsNegative(r*u)){let n=mod(t*SQRT_M1),r=mod(e*SQRT_M1);e=n,t=r,l=mod(c*INVSQRT_A_MINUS_D)}else l=d;edIsNegative(e*u)&&(t=mod(-t));let h=mod((n-t)*l);return edIsNegative(h)&&(h=mod(-h)),numberTo32BytesLE(h)}toHex(){return bytesToHex(this.toRawBytes())}toString(){return this.toHex()}equals(e){assertRstPoint(e);const t=this.ep,n=e.ep,r=mod(t.x*n.y)===mod(t.y*n.x),o=mod(t.y*n.y)===mod(t.x*n.x);return r||o}add(e){return assertRstPoint(e),new RistrettoPoint(this.ep.add(e.ep))}subtract(e){return assertRstPoint(e),new RistrettoPoint(this.ep.subtract(e.ep))}multiply(e){return new RistrettoPoint(this.ep.multiply(e))}multiplyUnsafe(e){return new RistrettoPoint(this.ep.multiplyUnsafe(e))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE),RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const pointPrecomputes=new WeakMap;class Point{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,pointPrecomputes.delete(this)}static fromHex(e,t=!0){const{d:n,P:r}=CURVE,o=(e=ensureBytes(e,32)).slice();o[31]=-129&e[31];const i=bytesToNumberLE(o);if(t&&i>=r)throw new Error("Expected 0 < hex < P");if(!t&&i>=POW_2_256)throw new Error("Expected 0 < hex < 2**256");const s=mod(i*i),a=mod(s-_1n),c=mod(n*s+_1n);let{isValid:d,value:u}=uvRatio(a,c);if(!d)throw new Error("Point.fromHex: invalid y coordinate");const l=(u&_1n)===_1n;return!!(128&e[31])!==l&&(u=mod(-u)),new Point(u,i)}static async fromPrivateKey(e){return(await getExtendedPublicKey(e)).point}toRawBytes(){const e=numberTo32BytesLE(this.y);return e[31]|=this.x&_1n?128:0,e}toHex(){return bytesToHex(this.toRawBytes())}toX25519(){const{y:e}=this;return numberTo32BytesLE(mod((_1n+e)*invert(_1n-e)))}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new Point(mod(-this.x),this.y)}add(e){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return ExtendedPoint.fromAffine(this).multiply(e,this).toAffine()}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy),Point.ZERO=new Point(_0n,_1n);class Signature{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromHex(e){const t=ensureBytes(e,64),n=Point.fromHex(t.slice(0,32),!1),r=bytesToNumberLE(t.slice(32,64));return new Signature(n,r)}assertValidity(){const{r:e,s:t}=this;if(!(e instanceof Point))throw new Error("Expected Point instance");return normalizeScalar(t,CURVE.l,!1),this}toRawBytes(){const e=new Uint8Array(64);return e.set(this.r.toRawBytes()),e.set(numberTo32BytesLE(this.s),32),e}toHex(){return bytesToHex(this.toRawBytes())}}function concatBytes(...e){if(!e.every((e=>e instanceof Uint8Array)))throw new Error("Expected Uint8Array list");if(1===e.length)return e[0];const t=e.reduce(((e,t)=>e+t.length),0),n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const o=e[t];n.set(o,r),r+=o.length}return n}const hexes=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function bytesToHex(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=hexes[e[n]];return t}function hexToBytes(e){if("string"!=typeof e)throw new TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const t=new Uint8Array(e.length/2);for(let n=0;n<t.length;n++){const r=2*n,o=e.slice(r,r+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");t[n]=i}return t}function numberTo32BytesBE(e){return hexToBytes(e.toString(16).padStart(64,"0"))}function numberTo32BytesLE(e){return numberTo32BytesBE(e).reverse()}function edIsNegative(e){return(mod(e)&_1n)===_1n}function bytesToNumberLE(e){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+bytesToHex(Uint8Array.from(e).reverse()))}const MAX_255B=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(e){return mod(bytesToNumberLE(e)&MAX_255B)}function mod(e,t=CURVE.P){const n=e%t;return n>=_0n?n:t+n}function invert(e,t=CURVE.P){if(e===_0n||t<=_0n)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=mod(e,t),r=t,o=_0n,i=_1n;for(;n!==_0n;){const e=r%n,t=o-i*(r/n);r=n,n=e,o=i,i=t}if(r!==_1n)throw new Error("invert: does not exist");return mod(o,t)}function invertBatch(e,t=CURVE.P){const n=new Array(e.length),r=invert(e.reduce(((e,r,o)=>r===_0n?e:(n[o]=e,mod(e*r,t))),_1n),t);return e.reduceRight(((e,r,o)=>r===_0n?e:(n[o]=mod(e*n[o],t),mod(e*r,t))),r),n}function pow2(e,t){const{P:n}=CURVE;let r=e;for(;t-- >_0n;)r*=r,r%=n;return r}function pow_2_252_3(e){const{P:t}=CURVE,n=BigInt(5),r=BigInt(10),o=BigInt(20),i=BigInt(40),s=BigInt(80),a=e*e%t*e%t,c=pow2(a,_2n)*a%t,d=pow2(c,_1n)*e%t,u=pow2(d,n)*d%t,l=pow2(u,r)*u%t,h=pow2(l,o)*l%t,f=pow2(h,i)*h%t,p=pow2(f,s)*f%t,y=pow2(p,s)*f%t,g=pow2(y,r)*u%t;return{pow_p_5_8:pow2(g,_2n)*e%t,b2:a}}function uvRatio(e,t){const n=mod(t*t*t),r=mod(n*n*t);let o=mod(e*n*pow_2_252_3(e*r).pow_p_5_8);const i=mod(t*o*o),s=o,a=mod(o*SQRT_M1),c=i===e,d=i===mod(-e),u=i===mod(-e*SQRT_M1);return c&&(o=s),(d||u)&&(o=a),edIsNegative(o)&&(o=mod(-o)),{isValid:c||d,value:o}}function invertSqrt(e){return uvRatio(_1n,e)}function modlLE(e){return mod(bytesToNumberLE(e),CURVE.l)}function equalBytes(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ensureBytes(e,t){const n=e instanceof Uint8Array?Uint8Array.from(e):hexToBytes(e);if("number"==typeof t&&n.length!==t)throw new Error(`Expected ${t} bytes`);return n}function normalizeScalar(e,t,n=!0){if(!t)throw new TypeError("Specify max value");if("number"==typeof e&&Number.isSafeInteger(e)&&(e=BigInt(e)),"bigint"==typeof e&&e<t)if(n){if(_0n<e)return e}else if(_0n<=e)return e;throw new TypeError("Expected valid scalar: 0 < scalar < max")}function adjustBytes25519(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function checkPrivateKey(e){if(32!==(e="bigint"==typeof e||"number"==typeof e?numberTo32BytesBE(normalizeScalar(e,POW_2_256)):ensureBytes(e)).length)throw new Error("Expected 32 bytes");return e}function getKeyFromHash(e){const t=adjustBytes25519(e.slice(0,32)),n=e.slice(32,64),r=modlLE(t),o=Point.BASE.multiply(r),i=o.toRawBytes();return{head:t,prefix:n,scalar:r,point:o,pointBytes:i}}let _sha512Sync;async function getExtendedPublicKey(e){return getKeyFromHash(await utils$1.sha512(checkPrivateKey(e)))}async function getPublicKey(e){return(await getExtendedPublicKey(e)).pointBytes}async function sign(e,t){e=ensureBytes(e);const{prefix:n,scalar:r,pointBytes:o}=await getExtendedPublicKey(t),i=modlLE(await utils$1.sha512(n,e)),s=Point.BASE.multiply(i),a=mod(i+modlLE(await utils$1.sha512(s.toRawBytes(),o,e))*r,CURVE.l);return new Signature(s,a).toRawBytes()}function prepareVerification(e,t,n){t=ensureBytes(t),n instanceof Point||(n=Point.fromHex(n,!1));const{r:r,s:o}=e instanceof Signature?e.assertValidity():Signature.fromHex(e);return{r:r,s:o,SB:ExtendedPoint.BASE.multiplyUnsafe(o),pub:n,msg:t}}function finishVerification(e,t,n,r){const o=modlLE(r),i=ExtendedPoint.fromAffine(e).multiplyUnsafe(o);return ExtendedPoint.fromAffine(t).add(i).subtract(n).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO)}async function verify(e,t,n){const{r:r,SB:o,msg:i,pub:s}=prepareVerification(e,t,n),a=await utils$1.sha512(r.toRawBytes(),s.toRawBytes(),i);return finishVerification(s,r,o,a)}Point.BASE._setWindowSize(8);const crypto$1={node:nodeCrypto,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},utils$1={bytesToHex:bytesToHex,hexToBytes:hexToBytes,concatBytes:concatBytes,getExtendedPublicKey:getExtendedPublicKey,mod:mod,invert:invert,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:e=>{if((e=ensureBytes(e)).length<40||e.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod(bytesToNumberLE(e),CURVE.l-_1n)+_1n},randomBytes:(e=32)=>{if(crypto$1.web)return crypto$1.web.getRandomValues(new Uint8Array(e));if(crypto$1.node){const{randomBytes:t}=crypto$1.node;return new Uint8Array(t(e).buffer)}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$1.randomBytes(32),sha512:async(...e)=>{const t=concatBytes(...e);if(crypto$1.web){const e=await crypto$1.web.subtle.digest("SHA-512",t.buffer);return new Uint8Array(e)}if(crypto$1.node)return Uint8Array.from(crypto$1.node.createHash("sha512").update(t).digest());throw new Error("The environment doesn't have sha512 function")},precompute(e=8,t=Point.BASE){const n=t.equals(Point.BASE)?t:new Point(t.x,t.y);return n._setWindowSize(e),n.multiply(_2n),n},sha512Sync:void 0};Object.defineProperties(utils$1,{sha512Sync:{configurable:!1,get:()=>_sha512Sync,set(e){_sha512Sync||(_sha512Sync=e)}}});const parseWith=(e,t)=>{if(e.startsWith("did:")){for(const n of t)try{return n.parse(e)}catch(e){}throw new Error(`Unsupported did ${e}`)}throw new Error(`Expected did instead got ${e}`)},or$7=(e,t)=>new Parser([e,t]);class Parser{constructor(e){this.variants=e}parse(e){return parseWith(e,this.variants)}or(e){return new Parser([...this.variants,e])}}const withDID$1=(e,t)=>new VerifierWithDID(t,e);class VerifierWithDID{constructor(e,t){this.id=e,this.key=t}did(){return this.id}toDIDKey(){return this.key.toDIDKey()}verify(e,t){return this.key.verify(e,t)}withDID(e){return withDID$1(this.key,e)}}const code$a=237,signatureCode$1=EdDSA,signatureAlgorithm$2="EdDSA",PUBLIC_TAG_SIZE$1=encodingLength$3(code$a),SIZE$1=32+PUBLIC_TAG_SIZE$1,decode$j=e=>{const[t]=decode$A(e);if(t!==code$a)throw new RangeError(`Unsupported key algorithm with multicode 0x${code$a.toString(16)}`);if(e.byteLength!==SIZE$1)throw new RangeError(`Expected Uint8Array with byteLength ${SIZE$1}, instead got Uint8Array with byteLength ${e.byteLength}`);return new Ed25519Verifier(e.buffer,e.byteOffset,e.byteLength)};class Ed25519Verifier extends Uint8Array{get code(){return code$a}get signatureCode(){return signatureCode$1}get signatureAlgorithm(){return signatureAlgorithm$2}get publicKey(){const e=new Uint8Array(this.buffer,this.byteOffset+PUBLIC_TAG_SIZE$1);return Object.defineProperties(this,{publicKey:{value:e}}),e}did(){return`did:key:${base58btc$2.encode(this)}`}verify(e,t){return t.code===signatureCode$1&&verify(t.raw,e,this.publicKey)}withDID(e){return withDID$1(this,e)}toDIDKey(){return this.did()}}const or$6=(e,t)=>new Importer([e,t]);class Importer{constructor(e){this.variants=e,this.from=create$c(e)}or(e){return new Importer([e,...this.variants])}}const create$c=e=>t=>{if(t.id.startsWith("did:key:"))return importWith(t,e);for(const[n,r]of Object.entries(t.keys)){const o=n;return importWith({id:o,keys:{[o]:r}},e).withDID(t.id)}throw new Error(`Archive ${t.id} contains no keys`)},importWith=(e,t)=>{for(const n of t)try{return n.from(e)}catch(e){}throw new Error("Unsupported signer")},withDID=({signer:e,verifier:t},n)=>new SignerWithDID(e,t.withDID(n));class SignerWithDID{constructor(e,t){this.key=e,this.verifier=t}get signer(){return this}get signatureAlgorithm(){return this.key.signatureAlgorithm}get signatureCode(){return this.key.signatureCode}did(){return this.verifier.did()}toDIDKey(){return this.verifier.toDIDKey()}withDID(e){return withDID(this.key,e)}sign(e){return this.key.sign(e)}verify(e,t){return this.verifier.verify(e,t)}toArchive(){const{keys:e}=this.key.toArchive();return{id:this.did(),keys:e}}}const code$9=4864,signatureAlgorithm$1=signatureAlgorithm$2,PRIVATE_TAG_SIZE=encodingLength$3(code$9),PUBLIC_TAG_SIZE=encodingLength$3(code$a),KEY_SIZE$1=32,SIZE=PRIVATE_TAG_SIZE+KEY_SIZE$1+PUBLIC_TAG_SIZE+KEY_SIZE$1,PUB_KEY_OFFSET=PRIVATE_TAG_SIZE+KEY_SIZE$1,generate$2=()=>derive(utils$1.randomPrivateKey()),derive=async e=>{if(e.byteLength!==KEY_SIZE$1)throw new Error(`Expected Uint8Array with byteLength of ${KEY_SIZE$1} instead not ${e.byteLength}`);const t=await getPublicKey(e),n=new Ed25519Signer(SIZE);return encodeTo$3(code$9,n,0),n.set(e,PRIVATE_TAG_SIZE),encodeTo$3(code$a,n,PRIVATE_TAG_SIZE+KEY_SIZE$1),n.set(t,PRIVATE_TAG_SIZE+KEY_SIZE$1+PUBLIC_TAG_SIZE),n},from$b=({id:e,keys:t})=>{if(e.startsWith("did:key:")){const n=t[e];if(n instanceof Uint8Array)return decode$i(n)}throw new TypeError("Unsupported archive format")},or$5=e=>or$6({from:from$b},e),decode$i=e=>{if(e.byteLength!==SIZE)throw new Error(`Expected Uint8Array with byteLength of ${SIZE} instead not ${e.byteLength}`);{const[t]=decode$A(e);if(t!==code$9)throw new Error(`Given bytes must be a multiformat with ${code$9} tag`)}{const[t]=decode$A(e.subarray(PUB_KEY_OFFSET));if(t!==code$a)throw new Error(`Given bytes must contain public key in multiformats with ${code$a} tag`)}return new Ed25519Signer(e)};class Ed25519Signer extends Uint8Array{get code(){return code$9}get signer(){return this}get verifier(){const e=new Uint8Array(this.buffer,PRIVATE_TAG_SIZE+KEY_SIZE$1),t=decode$j(e);return Object.defineProperties(this,{verifier:{value:t}}),t}get secret(){const e=new Uint8Array(this.buffer,PRIVATE_TAG_SIZE,KEY_SIZE$1);return Object.defineProperties(this,{secret:{value:e}}),e}did(){return this.verifier.did()}toDIDKey(){return this.verifier.toDIDKey()}withDID(e){return withDID(this,e)}async sign(e){const t=await sign(e,this.secret);return create$f(this.signatureCode,t)}verify(e,t){return this.verifier.verify(e,t)}get signatureAlgorithm(){return signatureAlgorithm$1}get signatureCode(){return EdDSA}encode(){return this}toArchive(){const e=this.did();return{id:e,keys:{[e]:this.encode()}}}}function isBytes$1(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function abytes(e,...t){if(!isBytes$1(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function aexists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function aoutput(e,t){abytes(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function createView(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function rotr(e,t){return e<<32-t|e>>>t}function utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes$3(e){return"string"==typeof e&&(e=utf8ToBytes(e)),abytes(e),e}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(e){const t=t=>e().update(toBytes$3(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function setBigUint64(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i),c=r?4:0,d=r?0:4;e.setUint32(t+c,s,r),e.setUint32(t+d,a,r)}function Chi(e,t,n){return e&t^~e&n}function Maj(e,t,n){return e&t^e&n^t&n}class HashMD extends Hash{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){aexists(this);const{view:t,buffer:n,blockLen:r}=this,o=(e=toBytes$3(e)).length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s!==r)n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(t,0),this.pos=0);else{const t=createView(e);for(;r<=o-i;i+=r)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),aoutput(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;setBigUint64(n,r-8,BigInt(8*this.length),o),this.process(n,0);const s=createView(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,d=this.get();if(c>d.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)s.setUint32(4*e,d[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return e.length=r,e.pos=s,e.finished=o,e.destroyed=i,r%t&&e.buffer.set(n),e}}const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);let SHA256$1=class extends HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A:e,B:t,C:n,D:r,E:o,F:i,G:s,H:a}=this;return[e,t,n,r,o,i,s,a]}set(e,t,n,r,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)SHA256_W[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=SHA256_W[e-15],n=SHA256_W[e-2],r=rotr(t,7)^rotr(t,18)^t>>>3,o=rotr(n,17)^rotr(n,19)^n>>>10;SHA256_W[e]=o+SHA256_W[e-7]+r+SHA256_W[e-16]|0}let{A:n,B:r,C:o,D:i,E:s,F:a,G:c,H:d}=this;for(let e=0;e<64;e++){const t=d+(rotr(s,6)^rotr(s,11)^rotr(s,25))+Chi(s,a,c)+SHA256_K[e]+SHA256_W[e]|0,u=(rotr(n,2)^rotr(n,13)^rotr(n,22))+Maj(n,r,o)|0;d=c,c=a,a=s,s=i+t|0,i=o,o=r,r=n,n=t+u|0}n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,d=d+this.H|0,this.set(n,r,o,i,s,a,c,d)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$3=wrapConstructor((()=>new SHA256$1));
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function isArrayOf(e,t){return!!Array.isArray(t)&&(0===t.length||(e?t.every((e=>"string"==typeof e)):t.every((e=>Number.isSafeInteger(e)))))}function afn(e){if("function"!=typeof e)throw new Error("function expected");return!0}function astr(e,t){if("string"!=typeof t)throw new Error(`${e}: string expected`);return!0}function anumber(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function aArr(e){if(!Array.isArray(e))throw new Error("array expected")}function astrArr(e,t){if(!isArrayOf(!0,t))throw new Error(`${e}: array of strings expected`)}function anumArr(e,t){if(!isArrayOf(!1,t))throw new Error(`${e}: array of numbers expected`)}function chain(...e){const t=e=>e,n=(e,t)=>n=>e(t(n));return{encode:e.map((e=>e.encode)).reduceRight(n,t),decode:e.map((e=>e.decode)).reduce(n,t)}}function alphabet(e){const t="string"==typeof e?e.split(""):e,n=t.length;astrArr("alphabet",t);const r=new Map(t.map(((e,t)=>[e,t])));return{encode:r=>(aArr(r),r.map((r=>{if(!Number.isSafeInteger(r)||r<0||r>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${r}". Allowed: ${e}`);return t[r]}))),decode:t=>(aArr(t),t.map((t=>{astr("alphabet.decode",t);const n=r.get(t);if(void 0===n)throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);return n})))}}function join$1(e=""){return astr("join",e),{encode:t=>(astrArr("join.decode",t),t.join(e)),decode:t=>(astr("join.decode",t),t.split(e))}}function padding$1(e,t="="){return anumber(e),astr("padding",t),{encode(n){for(astrArr("padding.encode",n);n.length*e%8;)n.push(t);return n},decode(n){astrArr("padding.decode",n);let r=n.length;if(r*e%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;r>0&&n[r-1]===t;r--){if((r-1)*e%8==0)throw new Error("padding: invalid, string has too much padding")}return n.slice(0,r)}}}function convertRadix(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(aArr(e),!e.length)return[];let r=0;const o=[],i=Array.from(e,(e=>{if(anumber(e),e<0||e>=t)throw new Error(`invalid integer: ${e}`);return e})),s=i.length;for(;;){let e=0,a=!0;for(let o=r;o<s;o++){const s=i[o],c=t*e,d=c+s;if(!Number.isSafeInteger(d)||c/t!==e||d-s!==c)throw new Error("convertRadix: carry overflow");const u=d/n;e=d%n;const l=Math.floor(u);if(i[o]=l,!Number.isSafeInteger(l)||l*n+e!==d)throw new Error("convertRadix: carry overflow");a&&(l?a=!1:r=o)}if(o.push(e),a)break}for(let t=0;t<e.length-1&&0===e[t];t++)o.push(0);return o.reverse()}const gcd=(e,t)=>0===t?e:gcd(t,e%t),radix2carry=(e,t)=>e+(t-gcd(e,t)),powers=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function convertRadix2(e,t,n,r){if(aArr(e),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${radix2carry(t,n)}`);let o=0,i=0;const s=powers[t],a=powers[n]-1,c=[];for(const r of e){if(anumber(r),r>=s)throw new Error(`convertRadix2: invalid data word=${r} from=${t}`);if(o=o<<t|r,i+t>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${t}`);for(i+=t;i>=n;i-=n)c.push((o>>i-n&a)>>>0);const e=powers[i];if(void 0===e)throw new Error("invalid carry");o&=e-1}if(o=o<<n-i&a,!r&&i>=t)throw new Error("Excess padding");if(!r&&o>0)throw new Error(`Non-zero padding: ${o}`);return r&&i>0&&c.push(o>>>0),c}function radix(e){anumber(e);return{encode:t=>{if(!isBytes(t))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(t),256,e)},decode:t=>(anumArr("radix.decode",t),Uint8Array.from(convertRadix(t,e,256)))}}function radix2(e,t=!1){if(anumber(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,e)>32||radix2carry(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!isBytes(n))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(n),8,e,!t)},decode:n=>(anumArr("radix2.decode",n),Uint8Array.from(convertRadix2(n,e,8,t)))}}function checksum(e,t){return anumber(e),afn(t),{encode(n){if(!isBytes(n))throw new Error("checksum.encode: input should be Uint8Array");const r=t(n).slice(0,e),o=new Uint8Array(n.length+e);return o.set(n),o.set(r,n.length),o},decode(n){if(!isBytes(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-e),o=n.slice(-e),i=t(r).slice(0,e);for(let t=0;t<e;t++)if(i[t]!==o[t])throw new Error("Invalid checksum");return r}}}const utils={alphabet:alphabet,chain:chain,checksum:checksum,convertRadix:convertRadix,convertRadix2:convertRadix2,radix:radix,radix2:radix2,join:join$1,padding:padding$1},isJapanese=e=>"あいこくしん"===e[0];
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */function nfkd(e){if("string"!=typeof e)throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function normalize(e){const t=nfkd(e),n=t.split(" ");if(![12,15,18,21,24].includes(n.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:n}}function aentropy(e){abytes(e,16,20,24,28,32)}const calcChecksum=e=>{const t=8-e.length/4;return new Uint8Array([sha256$3(e)[0]>>t<<t])};function getCoder(e){if(!Array.isArray(e)||2048!==e.length||"string"!=typeof e[0])throw new Error("Wordlist: expected array of 2048 strings");return e.forEach((e=>{if("string"!=typeof e)throw new Error("wordlist: non-string element: "+e)})),utils.chain(utils.checksum(1,calcChecksum),utils.radix2(11,!0),utils.alphabet(e))}function mnemonicToEntropy(e,t){const{words:n}=normalize(e),r=getCoder(t).decode(n);return aentropy(r),r}function entropyToMnemonic(e,t){aentropy(e);return getCoder(t).encode(e).join(isJapanese(t)?"　":" ")}const wordlist="abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo".split("\n"),Provider$1=match$1({method:"web"}),add$8=capability({can:"provider/add",with:AccountDID$1,nb:struct({provider:Provider$1,consumer:SpaceDID$1}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.provider,t.nb.provider,"provider"))||and$2(equal(e.nb.consumer,t.nb.consumer,"consumer"))||ok({})});var Provider$2=Object.freeze({__proto__:null,AccountDID:AccountDID$1,Provider:Provider$1,add:add$8});const{Provider:ProviderDID$3,AccountDID:AccountDID}=Provider$2,add$7=async(e,{account:t,consumer:n,provider:r=e.connection.id.did(),proofs:o})=>{if(!ProviderDID$3.is(r))throw new Error(`Unable to determine provider from agent.connection.id did ${r}. expected a did:web:`);const{out:i}=await e.invokeAndExecute(add$8,{with:t,nb:{provider:r,consumer:n},proofs:o});return i},generate$1=async({name:e,agent:t})=>{const{signer:n}=await generate$2();return new OwnedSpace({signer:n,name:e,agent:t})},fromMnemonic=async(e,{name:t,agent:n})=>{const r=mnemonicToEntropy(e,wordlist),o=await derive(r);return new OwnedSpace({signer:o,name:t,agent:n})},toMnemonic=({signer:e})=>entropyToMnemonic(e.secret,wordlist),createRecovery=(e,t)=>createAuthorization(e,{audience:parse$1(t),access:accountAccess$1,expiration:1/0}),SESSION_LIFETIME=31536e3,createAuthorization=async({signer:e,name:t},{audience:n,access:r=spaceAccess,expiration:o=now()+SESSION_LIFETIME})=>await delegate$3({issuer:e,audience:n,capabilities:toCapabilities({[e.did()]:r}),...o?{expiration:o}:{},facts:[{space:{name:t}}]}),toCapabilities=e=>{const t=[];for(const[n,r]of Object.entries(e)){const e=Object.entries(r);for(const[r,o]of e)o&&t.push({can:r,with:n})}return t};class OwnedSpace{constructor(e){this.model=e}get signer(){return this.model.signer}get name(){return this.model.name}did(){return this.signer.did()}withName(e){return new OwnedSpace({signer:this.signer,name:e})}async save({agent:e=this.model.agent}={}){if(!e)return fail("Please provide an agent to save the space into");const t=await createAuthorization(this,{audience:e});return await e.importSpaceFromDelegation(t),await e.setCurrentSpace(this.did()),{ok:{}}}provision({proofs:e},{agent:t=this.model.agent}={}){return t?provision(this,{proofs:e,agent:t}):fail("Please provide an agent to save the space into")}async createRecovery(e){return createRecovery(this,e)}createAuthorization(e,t){return createAuthorization(this,{...t,audience:e})}toMnemonic(){return toMnemonic(this)}}const SpaceDID=match$1({method:"key"}),fromDelegation=e=>{const t=SpaceDID.read(e.capabilities[0].with);if(t.error)throw Object.assign(new Error(`Invalid delegation, expected capabilities[0].with to be DID, ${t.error}`),{cause:t.error});const n=e.facts[0]?.space??{};return new SharedSpace({id:t.ok,delegation:e,meta:n})},provision=async(e,{proofs:t,agent:n})=>{const[r]=t[0].capabilities,{ok:o,error:i}=AccountDID.read(r.with);return i?error$1(i):await add$7(n,{consumer:e.did(),account:o,proofs:t})};class SharedSpace{constructor(e){this.model=e}get delegation(){return this.model.delegation}get meta(){return this.model.meta}get name(){return this.meta.name??""}did(){return this.model.id}withName(e){return new SharedSpace({...this.model,meta:{...this.meta,name:e}})}}function isExpired(e){return void 0===e.expiration||e.expiration<=Math.floor(Date.now()/1e3)}function isTooEarly(e){return!!e.notBefore&&e.notBefore>Math.floor(Date.now()/1e3)}function canDelegateCapability(e,t){const n=allows(e);for(const[e,r]of Object.entries(n))if(matchResource(e,t.with)){const e=Object.keys(r);for(const n of e)if(canDelegateAbility(n,t.can))return!0}return!1}const matchResource=(e,t)=>"ucan:*"===t||("string"==typeof t?e===t:t.test(e)),_globalReference=globalThis||window||self,webcrypto=_globalReference.crypto,tagWith=(e,t)=>{const n=encodingLength$3(e),r=new Uint8Array(t.byteLength+n);return encodeTo$3(e,r,0),r.set(t,n),r},untagWith=(e,t,n=0)=>{const r=0!==n?t.subarray(n):t,[o,i]=decode$A(r);if(o!==e)throw new Error(`Expected multiformat with 0x${e.toString(16)} tag instead got 0x${o.toString(16)}`);return new Uint8Array(r.buffer,r.byteOffset+i)},TAG_SIZE$1=1,INT_TAG=2,BITSTRING_TAG=3,OCTET_STRING_TAG=4,SEQUENCE_TAG=48,UNUSED_BIT_PAD=0,encodeDERLength=e=>{if(e<=127)return new Uint8Array([e]);const t=[];for(;0!==e;)t.push(255&e),e>>>=8;return t.reverse(),new Uint8Array([128|255&t.length,...t])},readDERLength=(e,t=0)=>{if(!(128&e[t]))return{number:e[t],consumed:1};const n=127&e[t];if(e.length<n+1)throw new Error(`ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${n}`);let r=0;for(let o=0;o<n;o++)r<<=8,r|=e[t+o+1];return{number:r,consumed:n+1}},skip=(e,t,n)=>{const r=into(e,t,n);return r.position+r.length},into=(e,t,n)=>{const r=e[n];if(r!==t)throw new Error(`ASN parsing error: Expected tag 0x${t.toString(16)} at position ${n}, but got 0x${r.toString(16)}.`);const o=readDERLength(e,n+TAG_SIZE$1);return{position:n+TAG_SIZE$1+o.consumed,length:o.number}},encodeBitString=e=>{const t=encodeDERLength(e.byteLength+1),n=new Uint8Array(TAG_SIZE$1+t.byteLength+1+e.byteLength);let r=0;return n[r]=BITSTRING_TAG,r+=TAG_SIZE$1,n.set(t,r),r+=t.byteLength,n[r]=UNUSED_BIT_PAD,r+=1,n.set(e,r),n},encodeOctetString=e=>{const t=encodeDERLength(e.byteLength),n=new Uint8Array(TAG_SIZE$1+t.byteLength+e.byteLength);let r=0;return n[r]=OCTET_STRING_TAG,r+=TAG_SIZE$1,n.set(t,r),r+=t.byteLength,n.set(e,r),n},encodeSequence=e=>{let t=0;for(const n of e)t+=n.byteLength;const n=encodeDERLength(t),r=new Uint8Array(TAG_SIZE$1+n.byteLength+t);let o=0;r[o]=SEQUENCE_TAG,o+=TAG_SIZE$1,r.set(n,o),o+=n.byteLength;for(const t of e)r.set(t,o),o+=t.byteLength;return r},readSequence=(e,t=0)=>{const{position:n,length:r}=into(e,SEQUENCE_TAG,t);return new Uint8Array(e.buffer,e.byteOffset+n,r)},encodeInt=e=>{const t=0===e.byteLength||128&e[0]?1:0,n=encodeDERLength(e.byteLength+t),r=new Uint8Array(TAG_SIZE$1+n.byteLength+e.byteLength+t);let o=0;return r[o]=INT_TAG,o+=TAG_SIZE$1,r.set(n,o),o+=n.byteLength,t>0&&(r[o]=UNUSED_BIT_PAD,o+=t),r.set(e,o),r},enterSequence=(e,t=0)=>into(e,SEQUENCE_TAG,t).position,skipSequence=(e,t=0)=>skip(e,SEQUENCE_TAG,t),skipInt=(e,t=0)=>skip(e,INT_TAG,t),readBitString=(e,t=0)=>{const{position:n,length:r}=into(e,BITSTRING_TAG,t),o=e[n];if(o!==UNUSED_BIT_PAD)throw new Error(`Can not read bitstring, expected length to be multiple of 8, but got ${o} unused bits in last byte.`);return new Uint8Array(e.buffer,e.byteOffset+n+1,r-1)},readInt$1=(e,t=0)=>{const{position:n,length:r}=into(e,INT_TAG,t);let o=0;for(;0===e[n+o];)o++;return new Uint8Array(e.buffer,e.byteOffset+n+o,r-o)},readOctetString=(e,t=0)=>{const{position:n,length:r}=into(e,OCTET_STRING_TAG,t);return new Uint8Array(e.buffer,e.byteOffset+n,r)},readSequenceWith=(e,t,n=0)=>{const r=[],o=readSequence(t,n);let i=0;for(const t of e){const e=t(o,i);r.push(e),i=e.byteOffset+e.byteLength-o.byteOffset}return r},SPKI_PARAMS_ENCODED=new Uint8Array([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]),encode$d=e=>encodeSequence([SPKI_PARAMS_ENCODED,encodeBitString(e)]),decode$h=e=>{const t=enterSequence(e,0),n=skipSequence(e,t);return readBitString(e,n)},PKSC8_HEADER=new Uint8Array([2,1,0,48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]),decode$g=e=>{let t=0;return t=enterSequence(e,t),t=skipInt(e,t),t=skipSequence(e,t),readOctetString(e,t)},encode$c=e=>encodeSequence([PKSC8_HEADER,encodeOctetString(e)]),encode$b=({n:e,e:t})=>encodeSequence([encodeInt(e),encodeInt(t)]),decode$f=(e,t=0)=>{const[n,r,o,i,s,a,c,d,u]=readSequenceWith([readInt$1,readInt$1,readInt$1,readInt$1,readInt$1,readInt$1,readInt$1,readInt$1,readInt$1],e,t);return{v:n,n:r,e:o,d:i,p:s,q:a,dp:c,dq:d,qi:u}},name$6="RSA",code$8=4869,verifierCode=4613,signatureCode=RS256,signatureAlgorithm="RS256",ALG="RSASSA-PKCS1-v1_5",HASH_ALG="SHA-256",KEY_SIZE=2048,SALT_LENGTH=128,IMPORT_PARAMS={name:ALG,hash:{name:HASH_ALG}},generate=async({size:e=KEY_SIZE,extractable:t=!1}={})=>{const{publicKey:n,privateKey:r}=await webcrypto.subtle.generateKey({name:ALG,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:HASH_ALG}},t,["sign","verify"]),o=await webcrypto.subtle.exportKey("spki",n),i=tagWith(verifierCode,decode$h(new Uint8Array(o))),s=new RSAVerifier({bytes:i,publicKey:n});if(t){const e=await webcrypto.subtle.exportKey("pkcs8",r),t=tagWith(code$8,decode$g(new Uint8Array(e)));return new ExtractableRSASigner({privateKey:r,bytes:t,verifier:s})}return new UnextractableRSASigner({privateKey:r,verifier:s})},from$a=({id:e,keys:t})=>{if(e.startsWith("did:key:")){const n=e,r=t[n];return r instanceof Uint8Array?decode$e(r):new UnextractableRSASigner({privateKey:r,verifier:RSAVerifier.parse(n)})}throw new TypeError(`RSA can not import from ${e} archive, try generic Signer instead`)},or$4=e=>or$6({from:from$a},e),decode$e=e=>{const t=decode$f(untagWith(code$8,e)),n=tagWith(verifierCode,encode$b(t));return new ExtractableRSASigner({bytes:e,privateKey:webcrypto.subtle.importKey("pkcs8",encode$c(untagWith(code$8,e)),IMPORT_PARAMS,!0,["sign"]),verifier:RSAVerifier.decode(n)})};class RSAVerifier{constructor({publicKey:e,bytes:t}){this.publicKey=e,this.bytes=t}withDID(e){return withDID$1(this,e)}toDIDKey(){return this.did()}static decode(e){return new this({bytes:e,publicKey:webcrypto.subtle.importKey("spki",encode$d(untagWith(verifierCode,e)),IMPORT_PARAMS,!0,["verify"])})}static parse(e){return RSAVerifier.decode(parse$1(e))}static or(e){return or$7(this,e)}get code(){return verifierCode}get signatureCode(){return signatureCode}get signatureAlgorithm(){return signatureAlgorithm}did(){return`did:key:${base58btc$2.encode(this.bytes)}`}async verify(e,t){return t.code===signatureCode&&webcrypto.subtle.verify({name:ALG,hash:{name:HASH_ALG}},await this.publicKey,t.raw,e)}}class RSASigner{constructor({privateKey:e,verifier:t}){this.verifier=t,this.privateKey=e}get signer(){return this}get code(){return code$8}get signatureCode(){return signatureCode}get signatureAlgorithm(){return signatureAlgorithm}did(){return this.verifier.did()}toDIDKey(){return this.verifier.toDIDKey()}verify(e,t){return this.verifier.verify(e,t)}async sign(e){const t=await webcrypto.subtle.sign({name:ALG,saltLength:SALT_LENGTH},await this.privateKey,e);return create$f(signatureCode,new Uint8Array(t))}}class ExtractableRSASigner extends RSASigner{constructor(e){super(e),this.bytes=e.bytes}withDID(e){return withDID(this,e)}toArchive(){const e=this.did();return{id:e,keys:{[e]:this.bytes}}}}class UnextractableRSASigner extends RSASigner{constructor(e){super(e),this.privateKey=e.privateKey}withDID(e){return withDID(this,e)}toArchive(){const e=this.did();return{id:e,keys:{[e]:this.privateKey}}}}var RSA=Object.freeze({__proto__:null,Verifier:RSAVerifier,code:code$8,decode:decode$e,from:from$a,generate:generate,name:name$6,or:or$4,signatureAlgorithm:signatureAlgorithm,signatureCode:signatureCode});const Signer=or$5(RSA),ProviderDID$2=match$1({method:"web"}),has$1=capability({can:"consumer/has",with:ProviderDID$2,nb:struct({consumer:SpaceDID$1}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.consumer,t.nb.consumer,"consumer"))||ok({})}),get$f=capability({can:"consumer/get",with:ProviderDID$2,nb:struct({consumer:SpaceDID$1}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.consumer,t.nb.consumer,"consumer"))||ok({})}),ProviderDID$1=match$1({method:"web"}),get$e=capability({can:"customer/get",with:ProviderDID$1,nb:struct({customer:AccountDID$1}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.customer,t.nb.customer,"customer"))||ok({})});capability({can:"console/*",with:match$1(),derives:equalWith}),capability({can:"console/log",with:match$1(),nb:struct({value:unknown()}),derives:equalWith}),capability({can:"console/error",with:match$1(),nb:struct({error:unknown()}),derives:equalWith});const Provider=DID,add$6=capability({can:"rate-limit/add",with:Provider,nb:struct({subject:string(),rate:number()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.subject,t.nb.subject,"subject"))||and$2(equal(e.nb.rate,t.nb.rate,"rate"))||ok({})}),remove$6=capability({can:"rate-limit/remove",with:Provider,nb:struct({id:string()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.id,t.nb.id,"id"))||ok({})}),list$7=capability({can:"rate-limit/list",with:Provider,nb:struct({subject:string()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.subject,t.nb.subject,"subject"))||ok({})}),admin=capability({can:"admin/*",with:ProviderDID$4,derives:equalWith}),upload={inspect:capability({can:"admin/upload/inspect",with:ProviderDID$4,nb:struct({root:Link}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.root,t.nb.root,"root"))||ok({})})},store={inspect:capability({can:"admin/store/inspect",with:ProviderDID$4,nb:struct({link:Link}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.link,t.nb.link,"link"))||ok({})})},ProviderDID=match$1({method:"web"}),get$d=capability({can:"subscription/get",with:ProviderDID,nb:struct({subscription:string()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.subscription,t.nb.subscription,"consumer"))||ok({})}),list$6=capability({can:"subscription/list",with:AccountDID$1,derives:equalWith}),FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE=4113,RAW_CODE=85,PieceLink=match$2({code:RAW_CODE,version:1,multihash:{code:FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE}});capability({can:"filecoin/*",with:match$1(),derives:equalWith});const filecoinOffer$1=capability({can:"filecoin/offer",with:match$1(),nb:struct({content:match$2(),piece:PieceLink}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.content,t.nb.content,"nb.content"))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||ok({})}),filecoinSubmit=capability({can:"filecoin/submit",with:match$1(),nb:struct({content:match$2(),piece:PieceLink}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.content,t.nb.content,"nb.content"))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||ok({})}),filecoinAccept=capability({can:"filecoin/accept",with:match$1(),nb:struct({content:match$2(),piece:PieceLink}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.content,t.nb.content,"nb.content"))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||ok({})}),filecoinInfo$1=capability({can:"filecoin/info",with:match$1(),nb:struct({piece:PieceLink}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||ok({})}),pieceOffer=capability({can:"piece/offer",with:match$1(),nb:struct({piece:PieceLink,group:match()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||and$2(equal(e.nb.group,t.nb.group,"nb.group"))||ok({})}),pieceAccept=capability({can:"piece/accept",with:match$1(),nb:struct({piece:PieceLink,group:match()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||and$2(equal(e.nb.group,t.nb.group,"nb.group"))||ok({})}),aggregateOffer=capability({can:"aggregate/offer",with:match$1(),nb:struct({aggregate:PieceLink,pieces:match$2({version:1})}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.aggregate,t.nb.aggregate,"nb.aggregate"))||and$2(checkLink(e.nb.pieces,t.nb.pieces,"nb.pieces"))||ok({})}),aggregateAccept=capability({can:"aggregate/accept",with:match$1(),nb:struct({aggregate:PieceLink,pieces:match$2()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.aggregate,t.nb.aggregate,"nb.aggregate"))||and$2(checkLink(e.nb.pieces,t.nb.pieces,"nb.pieces"))||ok({})}),dealInfo=capability({can:"deal/info",with:match$1(),nb:struct({piece:PieceLink}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(checkLink(e.nb.piece,t.nb.piece,"nb.piece"))||ok({})}),index=capability({can:"space/index/*",with:SpaceDID$1,derives:equalWith}),add$5=capability({can:"space/index/add",with:SpaceDID$1,nb:struct({index:match$2({code:code$c,version:1})}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.index,t.nb.index,"index"))||ok({})}),get$c=capability({can:"plan/get",with:AccountDID$1,derives:(e,t)=>and$2(equalWith(e,t))||ok({})}),set$5=capability({can:"plan/set",with:AccountDID$1,nb:struct({product:DID}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.product,t.nb.product,"product"))||ok({})}),createAdminSession$1=capability({can:"plan/create-admin-session",with:AccountDID$1,nb:struct({returnURL:string()}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.returnURL,t.nb.returnURL,"returnURL"))||ok({})}),usage=capability({can:"usage/*",with:SpaceDID$1,derives:equalWith}),report$1=capability({can:"usage/report",with:SpaceDID$1,nb:struct({period:struct({from:integer().greaterThan(-1),to:integer().greaterThan(-1)})}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equal(e.nb.period?.from,t.nb.period?.from,"period.from"))||and$2(equal(e.nb.period?.to,t.nb.period?.to,"period.to"))||ok({})}),blob$1=capability({can:"space/blob/*",with:SpaceDID$1,derives:equalWith}),content=struct({digest:bytes(),size:integer()}),add$4=capability({can:"space/blob/add",with:SpaceDID$1,nb:struct({blob:content}),derives:equalBlob}),remove$5=capability({can:"space/blob/remove",with:SpaceDID$1,nb:struct({digest:bytes()}),derives:(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):t.nb.digest&&!equals$4(t.nb.digest,e.nb.digest)?fail(`Link ${e.nb.digest?`${e.nb.digest}`:""} violates imposed ${t.nb.digest} constraint.`):ok({})}),list$5=capability({can:"space/blob/list",with:SpaceDID$1,nb:struct({cursor:string().optional(),size:integer().optional()}),derives:(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):ok({})}),get$b=capability({can:"space/blob/get/0/1",with:SpaceDID$1,nb:struct({digest:bytes()}),derives:(e,t)=>e.with!==t.with?fail(`Expected 'with: "${t.with}"' instead got '${e.with}'`):t.nb.digest&&!equals$4(t.nb.digest,e.nb.digest)?fail(`Link ${e.nb.digest?`${e.nb.digest}`:""} violates imposed ${t.nb.digest} constraint.`):ok({})}),blob=capability({can:"web3.storage/blob/*",with:SpaceDID$1,derives:equalWith}),allocate=capability({can:"web3.storage/blob/allocate",with:match$1(),nb:struct({blob:content,cause:Link,space:SpaceDID$1}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equalBlob(e,t))||and$2(checkLink(e.nb.cause,t.nb.cause,"cause"))||and$2(equal(e.nb.space,t.nb.space,"space"))||ok({})}),accept=capability({can:"web3.storage/blob/accept",with:match$1(),nb:struct({blob:content,ttl:integer().optional(),space:SpaceDID$1,_put:Await}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equalBlob(e,t))||and$2(equal(e.nb.ttl,t.nb.ttl,"ttl"))||and$2(equal(e.nb.space,t.nb.space,"space"))||ok({})}),put=capability({can:"http/put",with:SpaceDID$1,nb:struct({body:content,url:string().or(Await),headers:dictionary({value:string()}).or(Await)}),derives:(e,t)=>and$2(equalWith(e,t))||and$2(equalBody(e,t))||and$2(equal(e.nb.url,t.nb,"url"))||and$2(equal(e.nb.headers,t.nb,"headers"))||ok({})}),abilitiesAsStrings=[top.can,add$8.can,space.can,info.can,upload$1.can,add$9.can,get$g.can,remove$7.can,list$8.can,store$1.can,add$a.can,get$h.can,remove$8.can,list$9.can,access$1.can,authorize.can,attest.can,conclude$1.can,get$e.can,has$1.can,get$f.can,get$d.can,list$6.can,add$6.can,remove$6.can,list$7.can,filecoinOffer$1.can,filecoinSubmit.can,filecoinAccept.can,filecoinInfo$1.can,pieceOffer.can,pieceAccept.can,aggregateOffer.can,aggregateAccept.can,dealInfo.can,admin.can,upload.inspect.can,store.inspect.can,get$c.can,set$5.can,createAdminSession$1.can,usage.can,report$1.can,blob$1.can,add$4.can,remove$5.can,list$5.can,blob.can,allocate.can,accept.can,put.can,index.can,add$5.can];function uint8ArrayToArrayBuffer(e){return 0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:e.buffer.slice(e.byteOffset,e.byteLength+e.byteOffset)}class AgentData{#e;constructor(e,t={}){this.meta=e.meta,this.principal=e.principal,this.spaces=e.spaces,this.delegations=e.delegations,this.currentSpace=e.currentSpace,this.#e=e=>t.store?t.store.save(e):void 0}static async create(e={},t={}){const n=new AgentData({meta:{name:"agent",type:"device",...e.meta},principal:e.principal??await generate$2(),spaces:e.spaces??new Map,delegations:e.delegations??new Map,currentSpace:e.currentSpace},t);return t.store&&await t.store.save(n.export()),n}static fromExport(e,t){const n=new Map;for(const[t,r]of e.delegations)n.set(t,{delegation:importDAG(r.delegation.map((e=>({cid:CID$2.parse(e.cid).toV1(),bytes:e.bytes instanceof Uint8Array?e.bytes:new Uint8Array(e.bytes)})))),meta:r.meta});return new AgentData({meta:e.meta,principal:Signer.from(e.principal),currentSpace:e.currentSpace,spaces:e.spaces,delegations:n},t)}export(){const e={meta:this.meta,principal:this.principal.toArchive(),currentSpace:this.currentSpace,spaces:this.spaces,delegations:new Map};for(const[t,n]of this.delegations)e.delegations.set(t,{meta:n.meta,delegation:[...n.delegation.export()].map((e=>({cid:e.cid.toString(),bytes:uint8ArrayToArrayBuffer(e.bytes)})))});return e}async addSpace(e,t,n){this.spaces.set(e,t),await(n?this.addDelegation(n):this.#e(this.export()))}async setCurrentSpace(e){this.currentSpace=e,await this.#e(this.export())}async addDelegation(e,t){this.delegations.set(e.cid.toString(),{delegation:e,meta:t??{}}),await this.#e(this.export())}async removeDelegation(e){this.delegations.delete(e.toString()),await this.#e(this.export())}}const isSessionCapability=e=>e.can===attest.can,isSessionProof=e=>e.capabilities.some((e=>isSessionCapability(e)));function getSessionProofs(e){const t={};for(const{delegation:n}of e.delegations.values())if(isSessionProof(n)){const e=n.capabilities[0];if(e&&!isExpired(n)){const r=e.nb.proof;if(r){const e=r.toString(),o=n.issuer.did();t[e]=t[e]??{},t[e][o]=t[e][o]??[],t[e][o].push(n)}}}return t}match$1({method:"web"});const HOST="https://up.web3.storage",PRINCIPAL=parse$1("did:web:web3.storage"),agentToData=new WeakMap;function connection$2(e={}){return connect({id:e.principal??PRINCIPAL,codec:outbound,channel:e.channel??open$2({url:e.url??new URL(HOST),method:"POST",fetch:e.fetch??globalThis.fetch.bind(globalThis)})})}class Agent{#t;constructor(e,t={}){const n=t.connection?.channel;this.url=t.url??n?.url??new URL(HOST),this.connection=t.connection??connection$2({principal:t.servicePrincipal,url:this.url}),this.#t=e,agentToData.set(this,this.#t)}static async create(e,t={}){const n=await AgentData.create(e,t);return new Agent(n,t)}static from(e,t={}){const n=AgentData.fromExport(e,t);return new Agent(n,t)}get issuer(){return this.#t.principal}get meta(){return this.#t.meta}get spaces(){return this.#t.spaces}did(){return this.#t.principal.did()}async addProof(e){return await this.addProofs([e])}async addProofs(e){for(const t of e)await this.#t.addDelegation(t,{audience:this.meta});return await this.removeExpiredDelegations(),{}}#n(e){const t=new Set(e),n=[];for(const[,r]of this.#t.delegations)if(!isExpired(r.delegation)&&!isTooEarly(r.delegation))if(Array.isArray(e)&&e.length>0)for(const e of t)canDelegateCapability(r.delegation,e)&&n.push(r);else n.push(r);return n}async removeExpiredDelegations(){for(const[,e]of this.#t.delegations)isExpired(e.delegation)&&await this.#t.removeDelegation(e.delegation.cid)}async revoke(e,t={}){const n=t.proofs??[],r=[...this.delegations(),...n].find((t=>t.cid.equals(e)));if(!r)return{error:new Error(`could not find delegation ${e.toString()} - please include the delegation in options.proofs`)};return(await this.invokeAndExecute(revoke,{with:this.issuer.did(),nb:{ucan:r.cid},proofs:[r,...n]})).out}proofs(e,t){const n=[];for(const{delegation:t}of this.#n(e))t.audience.did()===this.issuer.did()&&n.push(t);const r=getSessionProofs(this.#t);for(const e of n){const o=r[e.asCID.toString()]??{},i=t?.sessionProofIssuer?o[t.sessionProofIssuer]??[]:Object.values(o).flat();i.length&&n.push(...i)}return n}delegations(e){const t=[];for(const{delegation:n}of this.delegationsWithMeta(e))t.push(n);return t}delegationsWithMeta(e){const t=[];for(const n of this.#n(e)){const{delegation:e}=n;e.capabilities.some((e=>e.can===attest.can))||e.audience.did()===this.issuer.did()||t.push(n)}return t}async createSpace(e){return await generate$1({name:e,agent:this})}async recoverSpace(e,{name:t}){return await fromMnemonic(e,{name:t,agent:this})}async importSpaceFromDelegation(e,{name:t=""}={}){const n=""===t?fromDelegation(e):fromDelegation(e).withName(t);return this.#t.spaces.set(n.did(),{...n.meta,name:n.name}),await this.addProof(n.delegation),this.currentSpace()||await this.setCurrentSpace(n.did()),n}async setCurrentSpace(e){if(!this.#t.spaces.has(e))throw new Error(`Agent has no proofs for ${e}.`);return await this.#t.setCurrentSpace(e),e}currentSpace(){return this.#t.currentSpace}currentSpaceWithMeta(){if(!this.#t.currentSpace)return;const e=this.proofs([{can:"space/info",with:this.#t.currentSpace}]),t=new Set;for(const n of e)for(const e of n.capabilities)t.add(e.can);return{did:this.#t.currentSpace,proofs:e,capabilities:[...t],meta:this.#t.spaces.get(this.#t.currentSpace)}}async delegate(e){const t=this.currentSpaceWithMeta();if(!t)throw new Error("no space selected.");const n=e.abilities.map((e=>({with:t.did,can:e})));for(const e of n)if(!this.proofs([e]).length)throw new Error(`cannot delegate capability ${e.can} with ${e.with}`);const r=await delegate$3({issuer:this.issuer,capabilities:n,proofs:this.proofs(n),facts:[{space:t.meta??{}}],...e});return await this.#t.addDelegation(r,{audience:e.audienceMeta}),await this.removeExpiredDelegations(),r}async invokeAndExecute(e,t){return(await this.invoke(e,t)).execute(this.connection)}execute(...e){return this.connection.execute(...e)}async invoke(e,t){const n=t.audience||this.connection.id,r=t.with||this.currentSpace();if(!r)throw new Error("No space or resource selected, you need pass a resource.");const o=[...t.proofs||[],...this.proofs([{with:r,can:e.can}],{sessionProofIssuer:n.did()})];if(0===o.length&&t.with!==this.did())throw new Error(`no proofs available for resource ${r} and ability ${e.can}`);return invoke({...t,audience:n,capability:e.create({with:r,nb:t.nb}),issuer:this.issuer,proofs:[...o],nonce:t.nonce})}async getSpaceInfo(e,t){const n=e||this.currentSpace();if(!n)throw new Error("No space selected, you need pass a resource.");const r=await this.invokeAndExecute(info,{...t,with:n});if(r.out.error)throw r.out.error;return r.out.ok}}async function addSpacesFromDelegations(e,t){const n=agentToData.get(e);if(!n)throw Object.assign(new Error("cannot determine AgentData for Agent"),{agent:e});const r=new Map,o=t.filter((t=>t.audience.did()===e.did())),i=o.filter((e=>"*"===e.capabilities[0].can&&"ucan:*"===e.capabilities[0].with));for(const e of i)for(const t of e.proofs){if(!isDelegation(t)||!t.capabilities[0].with.startsWith("did:key"))continue;const e=fromDelegation(t);r.set(e.did(),e.meta)}for(const e of o){const t=allows(e);for(const[e,n]of Object.entries(t))e.startsWith("did:key")&&Object.keys(n).length>0&&(r.has(e)||r.set(e,{}))}for(const[e,t]of r)await n.addSpace(e,t)}const importAuthorization=async(e,{proofs:t})=>{try{return await e.addProofs(t),await addSpacesFromDelegations(e,t),{ok:{}}}catch(e){return{error:e}}};function pDefer(){const e={};return e.promise=new Promise(((t,n)=>{e.resolve=t,e.reject=n})),e}const STORE_NAME="AccessStore",DATA_ID=1;class IndexedDBDriver{#r;#o;#i;#s;#a;constructor(e,t={}){this.#r=e,this.#o=t.dbVersion,this.#i=t.dbStoreName??STORE_NAME,this.#a=t.autoOpen??!0}async#c(){if(!this.#s){if(!this.#a)throw new Error("Store is not open");await this.open()}return this.#s}async open(){if(this.#s)return;const{resolve:e,reject:t,promise:n}=pDefer(),r=indexedDB.open(this.#r,this.#o);return r.addEventListener("upgradeneeded",(()=>{r.result.createObjectStore(this.#i,{keyPath:"id"})})),r.addEventListener("success",(()=>{this.#s=r.result,e()})),r.addEventListener("error",(()=>t(r.error))),n}async close(){const e=this.#s;if(!e)throw new Error("Store is not open");e.close(),this.#s=void 0}async save(e){const t=withObjectStore(await this.#c(),"readwrite",this.#i,(async t=>{const{resolve:n,reject:r,promise:o}=pDefer(),i=t.put({id:DATA_ID,...e});return i.addEventListener("success",(()=>n())),i.addEventListener("error",(()=>r(new Error("failed to query DB",{cause:i.error})))),o}));return await t()}async load(){const e=withObjectStore(await this.#c(),"readonly",this.#i,(async e=>{const{resolve:t,reject:n,promise:r}=pDefer(),o=e.get(DATA_ID);return o.addEventListener("success",(()=>t(o.result))),o.addEventListener("error",(()=>n(new Error("failed to query DB",{cause:o.error})))),r}));return await e()}async reset(){const e=withObjectStore(await this.#c(),"readwrite",this.#i,(e=>{const{resolve:t,reject:n,promise:r}=pDefer(),o=e.clear();return o.addEventListener("success",(()=>{t()})),o.addEventListener("error",(()=>n(new Error("failed to query DB",{cause:o.error})))),r}));await e()}}function withObjectStore(e,t,n,r){return async()=>{const o=e.transaction(n,t),{resolve:i,reject:s,promise:a}=pDefer();let c;o.addEventListener("complete",(()=>i(c))),o.addEventListener("abort",(()=>s(o.error||new Error("transaction aborted")))),o.addEventListener("error",(()=>s(new Error("transaction error",{cause:o.error}))));try{c=await r(o.objectStore(n)),o.commit()}catch(e){s(e),o.abort()}return a}}class StoreIndexedDB extends IndexedDBDriver{}const BITS_PER_BYTE=8,FRS_PER_QUAD=4;BigInt(FRS_PER_QUAD);const IN_BITS_FR=254,OUT_BITS_FR=256,IN_BYTES_PER_QUAD=FRS_PER_QUAD*IN_BITS_FR/BITS_PER_BYTE,OUT_BYTES_PER_QUAD=FRS_PER_QUAD*OUT_BITS_FR/BITS_PER_BYTE,PADDED_BYTES_PER_QUAD=BigInt(IN_BYTES_PER_QUAD);BigInt(OUT_BYTES_PER_QUAD);const FR_RATIO=IN_BITS_FR/OUT_BITS_FR,NODE_SIZE=OUT_BYTES_PER_QUAD/FRS_PER_QUAD,EXPANDED_BYTES_PER_NODE=BigInt(NODE_SIZE),MIN_PAYLOAD_SIZE=2*NODE_SIZE+1,from$9=e=>{if(e instanceof Uint8Array){if(e.length>NODE_SIZE)return e.subarray(0,NODE_SIZE);if(e.length==NODE_SIZE)return e}const t=new Uint8Array(NODE_SIZE);return t.set([...e]),t},empty$3=()=>EMPTY$4,EMPTY$4=from$9(new Uint8Array(NODE_SIZE).fill(0));Object.freeze(EMPTY$4.buffer);const name$5="sha2-256",code$7=18,size$2=32,prefix=new Uint8Array([18,32]);let Digest$4=class{constructor(e){this.code=code$7,this.name=name$5,this.bytes=e,this.size=size$2,this.digest=e.subarray(2)}};const digest$2=e=>{const t=new Uint8Array(prefix.length+size$2);return t.set(prefix,0),t.set(sha256$3(e),prefix.length),new Digest$4(t)},code$6=code$7;var SHA256=Object.freeze({__proto__:null,code:code$6,digest:digest$2,name:name$5,size:size$2});function truncatedHash(e,t={}){const n=t.hasher||SHA256,{digest:r}=n.digest(e);return truncate(r)}const computeNode=(e,t,n)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),truncatedHash(r,n)};function truncate(e){return e[NODE_SIZE-1]&=63,e}const MAX_LEVEL=64;class ZeroComm{constructor(){this.bytes=new Uint8Array(MAX_LEVEL*NODE_SIZE),this.bytes.set(empty$3(),0),this.node=empty$3(),this.length=NODE_SIZE}slice(e,t){for(;this.length<t;)this.node=computeNode(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=NODE_SIZE;return this.bytes.subarray(e,t)}}const ZERO_COMM=new ZeroComm,fromLevel=e=>{if(e<0||e>=MAX_LEVEL)throw new Error(`Only levels between 0 and ${MAX_LEVEL-1} inclusive are available`);return ZERO_COMM.slice(NODE_SIZE*e,NODE_SIZE*(e+1))},split$1=e=>{const t=e.length/NODE_SIZE,n=new Array(t);for(let r=0;r<t;r++){const t=r*NODE_SIZE,o=e.subarray(t,t+NODE_SIZE);n[r]=o}return n};function toZeroPaddedSize(e){const t=Math.max(e,MIN_PAYLOAD_SIZE),n=Math.floor(Math.log2(t)),r=Math.ceil(FR_RATIO*2**(n+1));return t<=r?r:Math.ceil(FR_RATIO*2**(n+2))}const toPieceSize=e=>toZeroPaddedSize(e)/FR_RATIO,pad=(e,t=new Uint8Array(toPieceSize(e.length)))=>{const n=toZeroPaddedSize(e.byteLength)/IN_BYTES_PER_QUAD;for(let r=0;r<n;r++){const n=r*IN_BYTES_PER_QUAD,o=r*OUT_BYTES_PER_QUAD;t.set(e.subarray(n,n+32),o),t[o+31]&=63;for(let r=32;r<64;r++)t[o+r]=e[n+r]<<2|e[n+r-1]>>6;t[o+63]&=63;for(let r=64;r<96;r++)t[o+r]=e[n+r]<<4|e[n+r-1]>>4;t[o+95]&=63;for(let r=96;r<127;r++)t[o+r]=e[n+r]<<6|e[n+r-1]>>2;t[o+127]=e[n+126]>>2}return t},log2Floor=e=>{let t=0n;for(;e>>=1n;)t++;return Number(t)},log2Ceil=e=>e<=1n?0:log2Floor(BigInt(e)-1n)+1,toPadding=e=>toPadded(e)-e,toPadded=e=>toQauds(e)*PADDED_BYTES_PER_QUAD,toQauds=e=>2n**BigInt(log2Ceil((e+PADDED_BYTES_PER_QUAD-1n)/PADDED_BYTES_PER_QUAD)),fromHeight=e=>fromWidth(2n**BigInt(e)),fromWidth=e=>e*EXPANDED_BYTES_PER_NODE,name$4="fr32-sha2-256-trunc254-padded-binary-tree",code$5=4113,MAX_PADDING_SIZE=9,HEIGHT_SIZE=1,ROOT_SIZE=size$2,MAX_DIGEST_SIZE=MAX_PADDING_SIZE+HEIGHT_SIZE+size$2,TAG_SIZE=encodingLength$3(code$5),MAX_SIZE=TAG_SIZE+encodingLength$3(MAX_DIGEST_SIZE)+MAX_DIGEST_SIZE,MAX_HEIGHT$1=255,MAX_PAYLOAD_SIZE$1=fromHeight(MAX_HEIGHT$1)*BigInt(IN_BITS_FR)/BigInt(OUT_BITS_FR),fromPiece=({padding:e,height:t,root:n})=>{const r=encodingLength$3(Number(e)),o=r+HEIGHT_SIZE+ROOT_SIZE,i=encodingLength$3(o);let s=0;const a=new Uint8Array(TAG_SIZE+i+o);return encodeTo$3(code$5,a,s),s+=TAG_SIZE,encodeTo$3(o,a,s),s+=i,encodeTo$3(Number(e),a,s),s+=r,a[s]=t,s+=HEIGHT_SIZE,a.set(n,s),new Digest$3(a)},fromBytes$3=e=>new Digest$3(e),toBytes$2=({digest:e})=>{const t=encodingLength$3(e.length)+TAG_SIZE;if(e.byteOffset>=t){const n=new Uint8Array(e.buffer,e.byteOffset-t,e.byteOffset+e.length),[r,o]=decode$A(n);if(r===code$5&&decode$A(n,o)[0]===e.length)return n}const n=new Uint8Array(e.length+t);return encodeTo$3(code$5,n),encodeTo$3(e.length,n,TAG_SIZE),n.set(e,t),n},height=({digest:e})=>{const[,t]=decode$A(e);return e[t]},padding=({digest:e})=>{const[t]=decode$A(e);return BigInt(t)},root=({digest:e})=>{const[,t]=decode$A(e);return e.subarray(t+HEIGHT_SIZE,t+HEIGHT_SIZE+size$2)};let Digest$3=class{constructor(e){this.bytes=e;const[t]=decode$A(e);if(t!==code$5)throw new RangeError(`Expected multihash with code ${code$5}`);let n=TAG_SIZE;const[r,o]=decode$A(e,n);n+=o;const i=e.subarray(n);if(i.length!==r)throw new RangeError(`Invalid multihash size expected ${n+r} bytes, got ${e.length} bytes`);this.digest=i}get name(){return name$4}get code(){return code$5}get size(){return this.digest.length}get padding(){return padding(this)}get height(){return height(this)}get root(){return root(this)}};var digest$1=Object.freeze({__proto__:null,HEIGHT_SIZE:HEIGHT_SIZE,MAX_DIGEST_SIZE:MAX_DIGEST_SIZE,MAX_HEIGHT:MAX_HEIGHT$1,MAX_PAYLOAD_SIZE:MAX_PAYLOAD_SIZE$1,MAX_SIZE:MAX_SIZE,ROOT_SIZE:ROOT_SIZE,TAG_SIZE:TAG_SIZE,code:code$5,fromBytes:fromBytes$3,fromPiece:fromPiece,height:height,name:name$4,padding:padding,root:root,toBytes:toBytes$2});const name$3="fr32-sha2-256-trunc254-padded-binary-tree",code$4=4113,MAX_HEIGHT=255,MAX_PAYLOAD_SIZE=fromHeight(MAX_HEIGHT)*BigInt(IN_BITS_FR)/BigInt(OUT_BITS_FR),digest=e=>{const t=new Hasher$3;return t.write(e),t.digest()},create$b=()=>new Hasher$3;let Hasher$3=class{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(IN_BYTES_PER_QUAD),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(MAX_SIZE),t=this.digestInto(e,0,!0);return fromBytes$3(e.subarray(0,t))}digestInto(e,t=0,n=!0){const{buffer:r,layers:o,offset:i,bytesWritten:s}=this;let[a,...c]=o;(i>0||0n===s)&&(a=[...a,...split$1(pad(r.fill(0,i)))]);const d=build([a,...c]),u=d.length-1,[l]=d[u],h=Number(toPadding(this.bytesWritten)),f=encodingLength$3(h);let p=t;if(n){encodeTo$3(code$4,e,p),p+=TAG_SIZE;const t=f+HEIGHT_SIZE+ROOT_SIZE,n=encodingLength$3(t);encodeTo$3(t,e,p),p+=n}return encodeTo$3(h,e,p),p+=f,e[p]=u,p+=1,e.set(l,p),p+=l.length,p-t}write(e){const{buffer:t,offset:n,layers:r}=this,o=r[0],{length:i}=e;if(0===i)return this;if(this.bytesWritten+BigInt(i)>MAX_PAYLOAD_SIZE)throw new RangeError(`Writing ${i} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE}`);if(n+i<t.length)return t.set(e,n),this.offset+=i,this.bytesWritten+=BigInt(i),this;{const r=t.length-n;t.set(e.subarray(0,r),n),o.push(...split$1(pad(t)));let s=r;for(;s+IN_BYTES_PER_QUAD<i;){const t=e.subarray(s,s+IN_BYTES_PER_QUAD);o.push(...split$1(pad(t))),s+=IN_BYTES_PER_QUAD}return this.buffer.set(e.subarray(s),0),this.offset=i-s,this.bytesWritten+=BigInt(i),prune(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return code$4}get name(){return name$3}};const prune=e=>flush$1(e,!1),build=e=>flush$1([...e],!0),flush$1=(e,t)=>{let n=0;for(;n<e.length;){let r=e[n+1];const o=e[n];t&&o.length%2>0&&r&&o.push(fromLevel(n)),n+=1,r=r?t?[...r]:r:[];let i=0;for(;i+1<o.length;){const e=computeNode(o[i],o[i+1]);delete o[i],delete o[i+1],r.push(e),i+=2}r.length&&(e[n]=r),o.splice(0,i)}return e};var PieceHasher=Object.freeze({__proto__:null,Digest:digest$1,MAX_HEIGHT:MAX_HEIGHT,MAX_PAYLOAD_SIZE:MAX_PAYLOAD_SIZE,code:code$4,create:create$b,digest:digest,name:name$3});new TextEncoder,new TextDecoder;const contentType$2="application/cbor",HEADERS=Object.freeze({"content-type":contentType$2}),encode$a=(e,t)=>{const n=[];for(const t of e.receipts.values()){const e=t.out;e.ok?n.push(e.ok):n.push({...e.error,error:!0})}const r=encode$i(n);return{headers:HEADERS,body:r}};var response=Object.freeze({__proto__:null,contentType:contentType$2,encode:encode$a});const contentType$1="application/car",decode$d=async({body:e})=>{const{roots:t,blocks:n}=decode$o(e),r=[];for(const{cid:e}of t){const t=view$2({root:e,blocks:n});r.push(t)}return await build$1({invocations:r})};var request$1=Object.freeze({__proto__:null,contentType:contentType$1,decode:decode$d});const{contentType:contentType}=request$1;inbound({decoders:{[contentType]:request$1,[contentType$3]:request$3},encoders:{"*/*;q=0.1":response,[contentType$3]:response$1}});const services={STOREFRONT:{url:new URL("https://up.web3.storage"),principal:parse$1("did:web:web3.storage")},AGGREGATOR:{url:new URL("https://aggregator.web3.storage"),principal:parse$1("did:web:web3.storage")},DEALER:{url:new URL("https://dealer.web3.storage"),principal:parse$1("did:web:web3.storage")},DEAL_TRACKER:{url:new URL("https://tracker.web3.storage"),principal:parse$1("did:web:web3.storage")}},connection$1=connect({id:services.STOREFRONT.principal,codec:outbound,channel:open$2({url:services.STOREFRONT.url,method:"POST"})});async function filecoinOffer({issuer:e,with:t,proofs:n,audience:r},o,i,s={}){const a=s.connection??connection$1,c=filecoinOffer$1.invoke({issuer:e,audience:r??services.STOREFRONT.principal,with:t,nb:{content:o,piece:i},proofs:n,expiration:1/0});return await c.execute(a)}async function filecoinInfo({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection$1,a=filecoinInfo$1.invoke({issuer:e,audience:r??services.STOREFRONT.principal,with:t,nb:{piece:o},proofs:n});return await a.execute(s)}function base$1(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==n[s])throw new TypeError(i+" is ambiguous");n[s]=o}var a=e.length,c=e.charAt(0),d=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,o=0;e[t]===c;)r++,t++;for(var i=(e.length-t)*d+1>>>0,s=new Uint8Array(i);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var l=0,h=i-1;(0!==u||l<o)&&-1!==h;h--,l++)u+=a*s[h]>>>0,s[h]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");o=l,t++}if(" "!==e[t]){for(var f=i-o;f!==i&&0===s[f];)f++;for(var p=new Uint8Array(r+(i-f)),y=r;f!==i;)p[y++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,o=0,i=t.length;o!==i&&0===t[o];)o++,n++;for(var s=(i-o)*u+1>>>0,d=new Uint8Array(s);o!==i;){for(var l=t[o],h=0,f=s-1;(0!==l||h<r)&&-1!==f;f--,h++)l+=256*d[f]>>>0,d[f]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");r=h,o++}for(var p=s-r;p!==s&&0===d[p];)p++;for(var y=c.repeat(n);p<s;++p)y+=e.charAt(d[p]);return y},decodeUnsafe:l,decode:function(e){var n=l(e);if(n)return n;throw new Error(`Non-${t} character`)}}}connect({id:services.AGGREGATOR.principal,codec:outbound,channel:open$2({url:services.AGGREGATOR.url,method:"POST"})}),connect({id:services.DEALER.principal,codec:outbound,channel:open$2({url:services.DEALER.url,method:"POST"})}),connect({id:services.DEAL_TRACKER.principal,codec:outbound,channel:open$2({url:services.DEAL_TRACKER.url,method:"POST"})});var src$1=base$1,_brrp__multiformats_scope_baseX$1=src$1;const equals$3=(e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0},coerce$1=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};let Encoder$1=class{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$1=class{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return or$3(this,e)}},ComposedDecoder$1=class{constructor(e){this.decoders=e}or(e){return or$3(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$3=(e,t)=>new ComposedDecoder$1({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});let Codec$1=class{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new Encoder$1(e,t,n),this.decoder=new Decoder$1(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$8=({name:e,prefix:t,encode:n,decode:r})=>new Codec$1(e,t,n,r),baseX$1=({prefix:e,name:t,alphabet:n})=>{const{encode:r,decode:o}=_brrp__multiformats_scope_baseX$1(n,t);return from$8({prefix:e,name:t,encode:r,decode:e=>coerce$1(o(e))})},decode$c=(e,t,n,r)=>{const o={};for(let e=0;e<t.length;++e)o[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*n/8|0);let a=0,c=0,d=0;for(let t=0;t<i;++t){const i=o[e[t]];if(void 0===i)throw new SyntaxError(`Non-${r} character`);c=c<<n|i,a+=n,a>=8&&(a-=8,s[d++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s},encode$9=(e,t,n)=>{const r="="===t[t.length-1],o=(1<<n)-1;let i="",s=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],s+=8;s>n;)s-=n,i+=t[o&a>>s];if(s&&(i+=t[o&a<<n-s]),r)for(;i.length*n&7;)i+="=";return i},rfc4648$1=({name:e,prefix:t,bitsPerChar:n,alphabet:r})=>from$8({prefix:t,name:e,encode:e=>encode$9(e,r,n),decode:t=>decode$c(t,r,n,e)}),base32$1=rfc4648$1({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$1({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rfc4648$1({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rfc4648$1({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rfc4648$1({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rfc4648$1({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rfc4648$1({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),rfc4648$1({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rfc4648$1({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const base58btc$1=baseX$1({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$1({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var encode_1$2=encode$8,MSB$4=128,MSBALL$3=-128,INT$3=Math.pow(2,31);function encode$8(e,t,n){t=t||[];for(var r=n=n||0;e>=INT$3;)t[n++]=255&e|MSB$4,e/=128;for(;e&MSBALL$3;)t[n++]=255&e|MSB$4,e>>>=7;return t[n]=0|e,encode$8.bytes=n-r+1,t}var decode$b=read$3,MSB$1$2=128,REST$1$2=127;function read$3(e,t){var n,r=0,o=0,i=t=t||0,s=e.length;do{if(i>=s)throw read$3.bytes=0,new RangeError("Could not decode varint");n=e[i++],r+=o<28?(n&REST$1$2)<<o:(n&REST$1$2)*Math.pow(2,o),o+=7}while(n>=MSB$1$2);return read$3.bytes=i-t,r}var N1$2=Math.pow(2,7),N2$2=Math.pow(2,14),N3$2=Math.pow(2,21),N4$2=Math.pow(2,28),N5$2=Math.pow(2,35),N6$2=Math.pow(2,42),N7$2=Math.pow(2,49),N8$2=Math.pow(2,56),N9$2=Math.pow(2,63),length$2=function(e){return e<N1$2?1:e<N2$2?2:e<N3$2?3:e<N4$2?4:e<N5$2?5:e<N6$2?6:e<N7$2?7:e<N8$2?8:e<N9$2?9:10},varint$2={encode:encode_1$2,decode:decode$b,encodingLength:length$2},_brrp_varint$2=varint$2;const decode$a=(e,t=0)=>[_brrp_varint$2.decode(e,t),_brrp_varint$2.decode.bytes],encodeTo$2=(e,t,n=0)=>(_brrp_varint$2.encode(e,t,n),t),encodingLength$2=e=>_brrp_varint$2.encodingLength(e),create$a=(e,t)=>{const n=t.byteLength,r=encodingLength$2(e),o=r+encodingLength$2(n),i=new Uint8Array(o+n);return encodeTo$2(e,i,0),encodeTo$2(n,i,r),i.set(t,o),new Digest$2(e,n,t,i)},decode$9=e=>{const t=coerce$1(e),[n,r]=decode$a(t),[o,i]=decode$a(t.subarray(r)),s=t.subarray(r+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest$2(n,o,s,t)},equals$2=(e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&equals$3(e.bytes,n.bytes)}};let Digest$2=class{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}};const format$1=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?toStringV0$1(n,baseCache$1(e),t||base58btc$1.encoder):toStringV1$1(n,baseCache$1(e),t||base32$1.encoder)},cache$2=new WeakMap,baseCache$1=e=>{const t=cache$2.get(e);if(null==t){const t=new Map;return cache$2.set(e,t),t}return t};let CID$1=class e{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==DAG_PB_CODE$1)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==SHA_256_CODE$1)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return e.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=create$a(t,n);return e.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return e.equals(this,t)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&equals$2(e.multihash,n.multihash)}toString(e){return format$1(this,e)}toJSON(){return{"/":format$1(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(null==t)return null;const n=t;if(n instanceof e)return n;if(null!=n["/"]&&n["/"]===n.bytes||n.asCID===n){const{version:t,code:r,multihash:o,bytes:i}=n;return new e(t,r,o,i||encodeCID$1(t,r,o.bytes))}if(!0===n[cidSymbol$1]){const{version:t,multihash:r,code:o}=n,i=decode$9(r);return e.create(t,o,i)}return null}static create(t,n,r){if("number"!=typeof n)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:if(n!==DAG_PB_CODE$1)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);return new e(t,n,r,r.bytes);case 1:{const o=encodeCID$1(t,n,r.bytes);return new e(t,n,r,o)}default:throw new Error("Invalid version")}}static createV0(t){return e.create(0,DAG_PB_CODE$1,t)}static createV1(t,n){return e.create(1,t,n)}static decode(t){const[n,r]=e.decodeFirst(t);if(r.length)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=e.inspectBytes(t),r=n.size-n.multihashSize,o=coerce$1(t.subarray(r,r+n.multihashSize));if(o.byteLength!==n.multihashSize)throw new Error("Incorrect length");const i=o.subarray(n.multihashSize-n.digestSize),s=new Digest$2(n.multihashCode,n.digestSize,i,o);return[0===n.version?e.createV0(s):e.createV1(n.codec,s),t.subarray(n.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=decode$a(e.subarray(t));return t+=r,n};let r=n(),o=DAG_PB_CODE$1;if(18===r?(r=0,t=0):o=n(),0!==r&&1!==r)throw new RangeError(`Invalid CID version ${r}`);const i=t,s=n(),a=n(),c=t+a;return{version:r,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(t,n){const[r,o]=parseCIDtoBytes$1(t,n),i=e.decode(o);if(0===i.version&&"Q"!==t[0])throw Error("Version 0 CID string must not include multibase prefix");return baseCache$1(i).set(r,t),i}};const parseCIDtoBytes$1=(e,t)=>{switch(e[0]){case"Q":{const n=t||base58btc$1;return[base58btc$1.prefix,n.decode(`${base58btc$1.prefix}${e}`)]}case base58btc$1.prefix:{const n=t||base58btc$1;return[base58btc$1.prefix,n.decode(e)]}case base32$1.prefix:{const n=t||base32$1;return[base32$1.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},toStringV0$1=(e,t,n)=>{const{prefix:r}=n;if(r!==base58btc$1.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const o=t.get(r);if(null==o){const o=n.encode(e).slice(1);return t.set(r,o),o}return o},toStringV1$1=(e,t,n)=>{const{prefix:r}=n,o=t.get(r);if(null==o){const o=n.encode(e);return t.set(r,o),o}return o},DAG_PB_CODE$1=112,SHA_256_CODE$1=18,encodeCID$1=(e,t,n)=>{const r=encodingLength$2(e),o=r+encodingLength$2(t),i=new Uint8Array(o+n.byteLength);return encodeTo$2(e,i,0),encodeTo$2(t,i,r),i.set(n,o),i},cidSymbol$1=Symbol.for("@ipld/js-cid/CID"),create$9=(e,t)=>CID$1.create(1,e,t),name$2="raw",code$3=85,encode$7=e=>coerce$1(e),decode$8=e=>coerce$1(e);var raw=Object.freeze({__proto__:null,code:code$3,decode:decode$8,encode:encode$7,name:name$2});const from$7=({name:e,code:t,encode:n})=>new Hasher$2(e,t,n);let Hasher$2=class{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?create$a(this.code,t):t.then((e=>create$a(this.code,e)))}throw Error("Unknown type, must be binary type")}};const sha$2=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),sha256$2=from$7({name:"sha2-256",code:18,encode:sha$2("SHA-256")});var retry$2={},retry_operation,hasRequiredRetry_operation,hasRequiredRetry$1,retry$1,hasRequiredRetry;function requireRetry_operation(){if(hasRequiredRetry_operation)return retry_operation;function e(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return hasRequiredRetry_operation=1,retry_operation=e,e.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},e.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},e.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(void 0===n){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1)}var r=this;return this._timer=setTimeout((function(){r._attempts++,r._operationTimeoutCb&&(r._timeout=setTimeout((function(){r._operationTimeoutCb(r._attempts)}),r._operationTimeout),r._options.unref&&r._timeout.unref()),r._fn(r._attempts)}),n),this._options.unref&&this._timer.unref(),!0},e.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout((function(){n._operationTimeoutCb()}),n._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},e.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},e.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},e.prototype.start=e.prototype.try,e.prototype.errors=function(){return this._errors},e.prototype.attempts=function(){return this._attempts},e.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,n=0,r=0;r<this._errors.length;r++){var o=this._errors[r],i=o.message,s=(e[i]||0)+1;e[i]=s,s>=n&&(t=o,n=s)}return t},retry_operation}function requireRetry$1(){return hasRequiredRetry$1||(hasRequiredRetry$1=1,e=retry$2,t=requireRetry_operation(),e.operation=function(n){var r=e.timeouts(n);return new t(r,{forever:n&&(n.forever||n.retries===1/0),unref:n&&n.unref,maxRetryTime:n&&n.maxRetryTime})},e.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var n in e)t[n]=e[n];if(t.minTimeout>t.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var r=[],o=0;o<t.retries;o++)r.push(this.createTimeout(o,t));return e&&e.forever&&!r.length&&r.push(this.createTimeout(o,t)),r.sort((function(e,t){return e-t})),r},e.createTimeout=function(e,t){var n=t.randomize?Math.random()+1:1,r=Math.round(n*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return r=Math.min(r,t.maxTimeout)},e.wrap=function(t,n,r){if(n instanceof Array&&(r=n,n=null),!r)for(var o in r=[],t)"function"==typeof t[o]&&r.push(o);for(var i=0;i<r.length;i++){var s=r[i],a=t[s];t[s]=function(r){var o=e.operation(n),i=Array.prototype.slice.call(arguments,1),s=i.pop();i.push((function(e){o.retry(e)||(e&&(arguments[0]=o.mainError()),s.apply(this,arguments))})),o.attempt((function(){r.apply(t,i)}))}.bind(t,a),t[s].options=n}}),retry$2;var e,t}function requireRetry(){return hasRequiredRetry?retry$1:(hasRequiredRetry=1,retry$1=requireRetry$1())}var retryExports=requireRetry(),retry=getDefaultExportFromCjs(retryExports);const networkErrorMsgs=new Set(["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed"]);class AbortError extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const decorateErrorWithCounts=(e,t,n)=>{const r=n.retries-(t-1);return e.attemptNumber=t,e.retriesLeft=r,e},isNetworkError=e=>networkErrorMsgs.has(e),getDOMException=e=>void 0===globalThis.DOMException?new Error(e):new DOMException(e);async function pRetry(e,t){return new Promise(((n,r)=>{t={onFailedAttempt(){},retries:10,...t};const o=retry.operation(t);o.attempt((async i=>{try{n(await e(i))}catch(e){if(!(e instanceof Error))return void r(new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`));if(e instanceof AbortError)o.stop(),r(e.originalError);else if(e instanceof TypeError&&!isNetworkError(e.message))o.stop(),r(e);else{decorateErrorWithCounts(e,i,t);try{await t.onFailedAttempt(e)}catch(e){return void r(e)}o.retry(e)||r(o.mainError())}}})),t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",(()=>{o.stop();const e=void 0===t.signal.reason?getDOMException("The operation was aborted."):t.signal.reason;r(e instanceof Error?e:getDOMException(e))}),{once:!0})}))}const serviceURL=new URL("https://up.web3.storage"),servicePrincipal=parse$1("did:web:web3.storage"),receiptsEndpoint="https://up.web3.storage/receipt/",connection=connect({id:servicePrincipal,codec:outbound,channel:open$2({url:serviceURL,method:"POST"})}),REQUEST_RETRIES=3;function createUploadProgressHandler$1(e,t){return function({total:n,loaded:r,lengthComputable:o}){return t({total:n,loaded:r,lengthComputable:o,url:e})}}async function add$3({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=o instanceof Uint8Array?o:new Uint8Array(await o.arrayBuffer()),a=await link$2(s),c=i.connection??connection,d=await pRetry((async()=>await add$a.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:{link:a,size:s.length},proofs:n,nonce:i.nonce}).execute(c)),{onFailedAttempt:console.warn,retries:i.retries??REQUEST_RETRIES});if(!d.out.ok)throw new Error(`failed ${add$a.can} invocation`,{cause:d.out.error});if("done"===d.out.ok.status)return a;const u=d.out.ok,l=i.fetchWithUploadProgress||i.fetch||globalThis.fetch.bind(globalThis);let h=!1;const f=await pRetry((async()=>{try{const e=await l(u.url,{method:"PUT",body:o,headers:u.headers,signal:i.signal,onUploadProgress:e=>{h=!0,i.onUploadProgress&&createUploadProgressHandler$1(u.url,i.onUploadProgress)(e)},duplex:"half"});if(e.status>=400&&e.status<500)throw new AbortError(`upload failed: ${e.status}`);return e}catch(e){if(!0===i.signal?.aborted)throw new AbortError("upload aborted");throw e}}),{retries:i.retries??REQUEST_RETRIES});if(!h&&i.onUploadProgress){const e=new Blob([o]);i.onUploadProgress({total:e.size,loaded:e.size,lengthComputable:!1})}if(!f.ok)throw new Error(`upload failed: ${f.status}`);return a}async function get$a({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await pRetry((async()=>await get$h.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:{link:o},proofs:n,nonce:i.nonce}).execute(s)),{onFailedAttempt:console.warn,retries:i.retries??REQUEST_RETRIES});if(!a.out.ok)throw new Error(`failed ${get$h.can} invocation`,{cause:a.out.error});return a.out.ok}async function list$4({issuer:e,with:t,proofs:n,audience:r},o={}){const i=o.connection??connection,s=await list$9.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),proofs:n,nb:{cursor:o.cursor,size:o.size,pre:o.pre},nonce:o.nonce}).execute(i);if(!s.out.ok)throw new Error(`failed ${list$9.can} invocation`,{cause:s.out.error});return s.out.ok}async function remove$4({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await remove$8.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:{link:o},proofs:n,nonce:i.nonce}).execute(s);if(!a.out.ok)throw new Error(`failed ${remove$8.can} invocation`,{cause:a.out.error});return a.out}class ReceiptNotFound extends Error{constructor(e){super(),this.taskCid=e}get reason(){return`receipt not found for task ${this.taskCid} in the indexed workflow`}get name(){return"ReceiptNotFound"}}class ReceiptMissing extends Error{constructor(e){super(),this.taskCid=e}get reason(){return`receipt missing for task ${this.taskCid}`}get name(){return"ReceiptMissing"}}async function poll(e,t={}){return await pRetry((async()=>{const n=await get$9(e,t);if(n.error)throw"ReceiptNotFound"===n.error.name?n.error:new AbortError(new Error("failed to fetch blob/accept receipt",{cause:n.error}));return n.ok}),{onFailedAttempt:console.warn,retries:t.retries??REQUEST_RETRIES})}function receiptEndpointFromChannel(e){if("url"in e&&e.url instanceof URL){const t=e.url;return new URL("/receipt/",t.toString())}return null}async function get$9(e,t={}){const n=t.connection?.channel,r=t.receiptsEndpoint??(n&&receiptEndpointFromChannel(n))??receiptsEndpoint,o=new URL(e.toString(),r),i=t.fetch??globalThis.fetch.bind(globalThis),s=await i(o);if(404===s.status)return{error:new ReceiptNotFound(e)};const a=new Uint8Array(await s.arrayBuffer()),c=(await decode$m({body:a,headers:{}})).receipts.get(e.toString());return c?{ok:c}:{error:new ReceiptMissing(e)}}const isCloudflareWorkers="undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator?.userAgent;function createUploadProgressHandler(e,t){return({total:n,loaded:r,lengthComputable:o})=>t({total:n,loaded:r,lengthComputable:o,url:e})}function getConcludeReceipt(e){const t=new Map;for(const n of e.iterateIPLDBlocks())t.set(`${n.cid}`,n);return view$1({root:e.capabilities[0].nb.receipt,blocks:t})}function parseBlobAddReceiptNext(e){const t=e.fx.fork,n=t.find((e=>e.capabilities[0].can===allocate.can)),r=t.filter((e=>e.capabilities[0].can===conclude$1.can)),o=t.find((e=>e.capabilities[0].can===put.can)),i=t.find((e=>e.capabilities[0].can===accept.can));if(!(n&&r.length&&o&&i))throw new Error("mandatory effects not received");const s=r.map((e=>getConcludeReceipt(e))),a=s.find((e=>e.ran.link().equals(n.cid))),c=s.find((e=>e.ran.link().equals(o.cid))),d=s.find((e=>e.ran.link().equals(i.cid)));if(!a)throw new Error("mandatory effects not received");return{allocate:{task:n,receipt:a},put:{task:o,receipt:c},accept:{task:i,receipt:d}}}function createConcludeInvocation(e,t,n){const r=[],o=[];for(const e of n.iterateIPLDBlocks())r.push(e),o.push(e.cid);const i=conclude$1.invoke({issuer:e,audience:t,with:e.toDIDKey(),nb:{receipt:n.link()},expiration:1/0,facts:[{...o}]});for(const e of r)i.attach(e);return i}async function add$2({issuer:e,with:t,proofs:n,audience:r},o,i,s={}){const a=i instanceof Uint8Array?i:new Uint8Array(await i.arrayBuffer()),c=a.length,d=s.connection??connection,u=await pRetry((async()=>await add$4.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$8(o,c),proofs:n,nonce:s.nonce}).execute(d)),{onFailedAttempt:console.warn,retries:s.retries??REQUEST_RETRIES});if(!u.out.ok)throw new Error(`failed ${add$4.can} invocation`,{cause:u.out.error});const l=parseBlobAddReceiptNext(u),{receipt:h}=l.allocate;if(!h.out.ok)throw new Error(`failed ${add$4.can} invocation`,{cause:h.out.error});const{address:f}=h.out.ok;if(f){const e=s.fetchWithUploadProgress||s.fetch||globalThis.fetch.bind(globalThis);let t=!1;if(await pRetry((async()=>{try{const n=await e(f.url,{method:"PUT",...!isCloudflareWorkers&&{mode:"cors"},body:a,headers:f.headers,signal:s.signal,onUploadProgress:e=>{t=!0,s.onUploadProgress&&createUploadProgressHandler(f.url,s.onUploadProgress)(e)},duplex:"half"});if(n.status>=400&&n.status<500)throw new AbortError(`upload failed: ${n.status}`);if(!n.ok)throw new Error(`upload failed: ${n.status}`)}catch(e){if(!0===s.signal?.aborted)throw new AbortError("upload aborted");throw e}}),{retries:s.retries??REQUEST_RETRIES}),!t&&s.onUploadProgress){const e=new Blob([a]);s.onUploadProgress({total:e.size,loaded:e.size,lengthComputable:!1})}}let{receipt:p}=l.put;if(!p?.out.ok){const t=from$b(l.put.task.facts[0].keys);p=await issue$1({issuer:t,ran:l.put.task.cid,result:{ok:{}}});const n=createConcludeInvocation(e,r??servicePrincipal,p);if(!(await n.execute(d)).out.ok)throw new Error(`failed ${add$4.can} invocation`,{cause:u.out.error})}let{receipt:y}=l.accept;y?.out.ok||(y=await poll(l.accept.task.link(),s));const g=new Map([...y.iterateIPLDBlocks()].map((e=>[`${e.cid}`,e])));return{site:view$3({root:y.out.ok?.site,blocks:g})}}const ability$2=add$4.can,input$8=(e,t)=>({blob:{digest:e.bytes,size:t}});async function get$8({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await get$b.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$7(o),proofs:n,nonce:i.nonce}).execute(s);if(!a.out.ok)throw new Error(`failed ${get$b.can} invocation`,{cause:a.out.error});return a.out}get$b.can;const input$7=e=>({digest:e.bytes});async function list$3({issuer:e,with:t,proofs:n,audience:r},o={}){const i=o.connection??connection,s=await list$5.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),proofs:n,nb:input$6(o.cursor,o.size),nonce:o.nonce}).execute(i);if(!s.out.ok)throw new Error(`failed ${list$5.can} invocation`,{cause:s.out.error});return s.out.ok}list$5.can;const input$6=(e,t)=>({cursor:e,size:t});async function remove$3({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await remove$5.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$5(o),proofs:n,nonce:i.nonce}).execute(s);if(!a.out.ok)throw new Error(`failed ${remove$5.can} invocation`,{cause:a.out.error});return a.out}remove$5.can;const input$5=e=>({digest:e.bytes});async function add$1({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await pRetry((async()=>await add$5.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$4(o),proofs:n}).execute(s)),{onFailedAttempt:console.warn,retries:i.retries??REQUEST_RETRIES});if(!a.out.ok)throw new Error(`failed ${add$5.can} invocation`,{cause:a.out.error});return a.out.ok}const ability$1=add$5.can,input$4=e=>({index:e});async function add({issuer:e,with:t,proofs:n,audience:r},o,i,s={}){const a=s.connection??connection,c=await pRetry((async()=>await add$9.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$3(o,i),proofs:n,nonce:s.nonce}).execute(a)),{onFailedAttempt:console.warn,retries:s.retries??REQUEST_RETRIES});if(!c.out.ok)throw new Error(`failed ${add$9.can} invocation`,{cause:c.out.error});return c.out.ok}const ability=add$9.can,input$3=(e,t)=>({root:e,shards:t});async function get$7({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await pRetry((async()=>await get$g.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input$2(o),proofs:n,nonce:i.nonce}).execute(s)),{onFailedAttempt:console.warn,retries:i.retries??REQUEST_RETRIES});if(!a.out.ok)throw new Error(`failed ${get$g.can} invocation`,{cause:a.out.error});return a.out.ok}get$g.can;const input$2=e=>({root:e});async function list$2({issuer:e,with:t,proofs:n,audience:r},o={}){const i=o.connection??connection,s=await list$8.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),proofs:n,nb:input$1(o.cursor,o.size,o.pre),nonce:o.nonce}).execute(i);if(!s.out.ok)throw new Error(`failed ${list$8.can} invocation`,{cause:s.out.error});return s.out.ok}list$8.can;const input$1=(e,t,n)=>({cursor:e,size:t,pre:n});async function remove$2({issuer:e,with:t,proofs:n,audience:r},o,i={}){const s=i.connection??connection,a=await remove$7.invoke({issuer:e,audience:r??servicePrincipal,with:SpaceDID$1.from(t),nb:input(o),proofs:n,nonce:i.nonce}).execute(s);if(!a.out.ok)throw new Error(`failed ${remove$7.can} invocation`,{cause:a.out.error});return a.out.ok}remove$7.can;const input=e=>({root:e}),textDecoder=new TextDecoder;function decodeVarint(e,t){let n=0;for(let r=0;;r+=7){if(r>=64)throw new Error("protobuf: varint overflow");if(t>=e.length)throw new Error("protobuf: unexpected end of data");const o=e[t++];if(n+=r<28?(127&o)<<r:(127&o)*2**r,o<128)break}return[n,t]}function decodeBytes(e,t){let n;[n,t]=decodeVarint(e,t);const r=t+n;if(n<0||r<0)throw new Error("protobuf: invalid length");if(r>e.length)throw new Error("protobuf: unexpected end of data");return[e.subarray(t,r),r]}function decodeKey(e,t){let n;return[n,t]=decodeVarint(e,t),[7&n,n>>3,t]}function decodeLink(e){const t={},n=e.length;let r=0;for(;r<n;){let n,o;if([n,o,r]=decodeKey(e,r),1===o){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(2!==n)throw new Error(`protobuf: (PBLink) wrong wireType (${n}) for Hash`);if(void 0!==t.Name)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,r]=decodeBytes(e,r)}else if(2===o){if(void 0!==t.Name)throw new Error("protobuf: (PBLink) duplicate Name section");if(2!==n)throw new Error(`protobuf: (PBLink) wrong wireType (${n}) for Name`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,r]=decodeBytes(e,r),t.Name=textDecoder.decode(o)}else{if(3!==o)throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(0!==n)throw new Error(`protobuf: (PBLink) wrong wireType (${n}) for Tsize`);[t.Tsize,r]=decodeVarint(e,r)}}if(r>n)throw new Error("protobuf: (PBLink) unexpected end of data");return t}function decodeNode(e){const t=e.length;let n,r,o=0,i=!1;for(;o<t;){let t,s;if([t,s,o]=decodeKey(e,o),2!==t)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);if(1===s){if(r)throw new Error("protobuf: (PBNode) duplicate Data section");[r,o]=decodeBytes(e,o),n&&(i=!0)}else{if(2!==s)throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${s}`);{if(i)throw new Error("protobuf: (PBNode) duplicate Links section");let t;n||(n=[]),[t,o]=decodeBytes(e,o),n.push(decodeLink(t))}}}if(o>t)throw new Error("protobuf: (PBNode) unexpected end of data");const s={};return r&&(s.Data=r),s.Links=n||[],s}const textEncoder$1=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink$1(e,t){let n=t.length;if("number"==typeof e.Tsize){if(e.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(e.Tsize))throw new Error("Tsize too large for encoding");n=encodeVarint(t,n,e.Tsize)-1,t[n]=24}if("string"==typeof e.Name){const r=textEncoder$1.encode(e.Name);n-=r.length,t.set(r,n),n=encodeVarint(t,n,r.length)-1,t[n]=18}return e.Hash&&(n-=e.Hash.length,t.set(e.Hash,n),n=encodeVarint(t,n,e.Hash.length)-1,t[n]=10),t.length-n}function encodeNode(e){const t=sizeNode(e),n=new Uint8Array(t);let r=t;if(e.Data&&(r-=e.Data.length,n.set(e.Data,r),r=encodeVarint(n,r,e.Data.length)-1,n[r]=10),e.Links)for(let t=e.Links.length-1;t>=0;t--){const o=encodeLink$1(e.Links[t],n.subarray(0,r));r-=o,r=encodeVarint(n,r,o)-1,n[r]=18}return n}function sizeLink(e){let t=0;if(e.Hash){const n=e.Hash.length;t+=1+n+sov(n)}if("string"==typeof e.Name){const n=textEncoder$1.encode(e.Name).length;t+=1+n+sov(n)}return"number"==typeof e.Tsize&&(t+=1+sov(e.Tsize)),t}function sizeNode(e){let t=0;if(e.Data){const n=e.Data.length;t+=1+n+sov(n)}if(e.Links)for(const n of e.Links){const e=sizeLink(n);t+=1+e+sov(e)}return t}function encodeVarint(e,t,n){const r=t-=sov(n);for(;n>=maxUInt32;)e[t++]=127&n|128,n/=128;for(;n>=128;)e[t++]=127&n|128,n>>>=7;return e[t]=n,r}function sov(e){return e%2==0&&e++,Math.floor((len64(e)+6)/7)}function len64(e){let t=0;return e>=maxInt32&&(e=Math.floor(e/maxInt32),t=32),e>=65536&&(e>>>=16,t+=16),e>=256&&(e>>>=8,t+=8),t+len8tab[e]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder=new TextEncoder;function linkComparator(e,t){if(e===t)return 0;const n=e.Name?textEncoder.encode(e.Name):[],r=t.Name?textEncoder.encode(t.Name):[];let o=n.length,i=r.length;for(let e=0,t=Math.min(o,i);e<t;++e)if(n[e]!==r[e]){o=n[e],i=r[e];break}return o<i?-1:i<o?1:0}function hasOnlyProperties(e,t){return!Object.keys(e).some((e=>!t.includes(e)))}function asLink(e){if("object"==typeof e.asCID){const t=CID$2.asCID(e);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if("object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(e.Hash){let n=CID$2.asCID(e.Hash);try{n||("string"==typeof e.Hash?n=CID$2.parse(e.Hash):e.Hash instanceof Uint8Array&&(n=CID$2.decode(e.Hash)))}catch(e){throw new TypeError(`Invalid DAG-PB form: ${e.message}`)}n&&(t.Hash=n)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return"string"==typeof e.Name&&(t.Name=e.Name),"number"==typeof e.Tsize&&(t.Tsize=e.Tsize),t}function prepare(e){if((e instanceof Uint8Array||"string"==typeof e)&&(e={Data:e}),"object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(void 0!==e.Data)if("string"==typeof e.Data)t.Data=textEncoder.encode(e.Data);else{if(!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form");t.Data=e.Data}if(void 0!==e.Links){if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form");t.Links=e.Links.map(asLink),t.Links.sort(linkComparator)}else t.Links=[];return t}function validate(e){if(!e||"object"!=typeof e||Array.isArray(e)||e instanceof Uint8Array||e["/"]&&e["/"]===e.bytes)throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(e,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==e.Data&&!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be bytes)");if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form (Links must be a list)");for(let t=0;t<e.Links.length;t++){const n=e.Links[t];if(!n||"object"!=typeof n||Array.isArray(n)||n instanceof Uint8Array||n["/"]&&n["/"]===n.bytes)throw new TypeError("Invalid DAG-PB form (bad link)");if(!hasOnlyProperties(n,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");if(void 0===n.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(null==n.Hash||!n.Hash["/"]||n.Hash["/"]!==n.Hash.bytes)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==n.Name&&"string"!=typeof n.Name)throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==n.Tsize){if("number"!=typeof n.Tsize||n.Tsize%1!=0)throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(n.Tsize<0)throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)")}if(t>0&&-1===linkComparator(n,e.Links[t-1]))throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function toByteView(e){return e instanceof ArrayBuffer?new Uint8Array(e,0,e.byteLength):e}const code$2=112;function encode$6(e){validate(e);const t={};return e.Links&&(t.Links=e.Links.map((e=>{const t={};return e.Hash&&(t.Hash=e.Hash.bytes),void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),e.Data&&(t.Data=e.Data),encodeNode(t)}function decode$7(e){const t=decodeNode(toByteView(e)),n={};return t.Data&&(n.Data=t.Data),t.Links&&(n.Links=t.Links.map((e=>{const t={};try{t.Hash=CID$2.decode(e.Hash)}catch(e){}if(!t.Hash)throw new Error("Invalid Hash field found in link, expected CID");return void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),n}var indexMinimal={},minimal$1={},aspromise,hasRequiredAspromise;function requireAspromise(){if(hasRequiredAspromise)return aspromise;return hasRequiredAspromise=1,aspromise=function(e,t){var n=new Array(arguments.length-1),r=0,o=2,i=!0;for(;o<arguments.length;)n[r++]=arguments[o++];return new Promise((function(o,s){n[r]=function(e){if(i)if(i=!1,e)s(e);else{for(var t=new Array(arguments.length-1),n=0;n<t.length;)t[n++]=arguments[n];o.apply(null,t)}};try{e.apply(t||null,n)}catch(e){i&&(i=!1,s(e))}}))},aspromise}var base64={},hasRequiredBase64,eventemitter,hasRequiredEventemitter,float,hasRequiredFloat,inquire_1,hasRequiredInquire;function requireBase64(){return hasRequiredBase64||(hasRequiredBase64=1,function(e){var t=e;t.length=function(e){var t=e.length;if(!t)return 0;for(var n=0;--t%4>1&&"="===e.charAt(t);)++n;return Math.ceil(3*e.length)/4-n};for(var n=new Array(64),r=new Array(123),o=0;o<64;)r[n[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;t.encode=function(e,t,r){for(var o,i=null,s=[],a=0,c=0;t<r;){var d=e[t++];switch(c){case 0:s[a++]=n[d>>2],o=(3&d)<<4,c=1;break;case 1:s[a++]=n[o|d>>4],o=(15&d)<<2,c=2;break;case 2:s[a++]=n[o|d>>6],s[a++]=n[63&d],c=0}a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,s)),a=0)}return c&&(s[a++]=n[o],s[a++]=61,1===c&&(s[a++]=61)),i?(a&&i.push(String.fromCharCode.apply(String,s.slice(0,a))),i.join("")):String.fromCharCode.apply(String,s.slice(0,a))};var i="invalid encoding";t.decode=function(e,t,n){for(var o,s=n,a=0,c=0;c<e.length;){var d=e.charCodeAt(c++);if(61===d&&a>1)break;if(void 0===(d=r[d]))throw Error(i);switch(a){case 0:o=d,a=1;break;case 1:t[n++]=o<<2|(48&d)>>4,o=d,a=2;break;case 2:t[n++]=(15&o)<<4|(60&d)>>2,o=d,a=3;break;case 3:t[n++]=(3&o)<<6|d,a=0}}if(1===a)throw Error(i);return n-s},t.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}}(base64)),base64}function requireEventemitter(){if(hasRequiredEventemitter)return eventemitter;function e(){this._listeners={}}return hasRequiredEventemitter=1,eventemitter=e,e.prototype.on=function(e,t,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:n||this}),this},e.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var n=this._listeners[e],r=0;r<n.length;)n[r].fn===t?n.splice(r,1):++r;return this},e.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,n)}return this},eventemitter}function requireFloat(){if(hasRequiredFloat)return float;function e(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),n=new Uint8Array(t.buffer),r=128===n[3];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3]}function i(e,r,o){t[0]=e,r[o]=n[3],r[o+1]=n[2],r[o+2]=n[1],r[o+3]=n[0]}function s(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],t[0]}function a(e,r){return n[3]=e[r],n[2]=e[r+1],n[1]=e[r+2],n[0]=e[r+3],t[0]}e.writeFloatLE=r?o:i,e.writeFloatBE=r?i:o,e.readFloatLE=r?s:a,e.readFloatBE=r?a:s}():function(){function i(e,t,n,r){var o=t<0?1:0;if(o&&(t=-t),0===t)e(1/t>0?0:2147483648,n,r);else if(isNaN(t))e(2143289344,n,r);else if(t>34028234663852886e22)e((o<<31|2139095040)>>>0,n,r);else if(t<11754943508222875e-54)e((o<<31|Math.round(t/1401298464324817e-60))>>>0,n,r);else{var i=Math.floor(Math.log(t)/Math.LN2);e((o<<31|i+127<<23|8388607&Math.round(t*Math.pow(2,-i)*8388608))>>>0,n,r)}}function s(e,t,n){var r=e(t,n),o=2*(r>>31)+1,i=r>>>23&255,s=8388607&r;return 255===i?s?NaN:o*(1/0):0===i?1401298464324817e-60*o*s:o*Math.pow(2,i-150)*(s+8388608)}e.writeFloatLE=i.bind(null,t),e.writeFloatBE=i.bind(null,n),e.readFloatLE=s.bind(null,r),e.readFloatBE=s.bind(null,o)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),n=new Uint8Array(t.buffer),r=128===n[7];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3],r[o+4]=n[4],r[o+5]=n[5],r[o+6]=n[6],r[o+7]=n[7]}function i(e,r,o){t[0]=e,r[o]=n[7],r[o+1]=n[6],r[o+2]=n[5],r[o+3]=n[4],r[o+4]=n[3],r[o+5]=n[2],r[o+6]=n[1],r[o+7]=n[0]}function s(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],n[4]=e[r+4],n[5]=e[r+5],n[6]=e[r+6],n[7]=e[r+7],t[0]}function a(e,r){return n[7]=e[r],n[6]=e[r+1],n[5]=e[r+2],n[4]=e[r+3],n[3]=e[r+4],n[2]=e[r+5],n[1]=e[r+6],n[0]=e[r+7],t[0]}e.writeDoubleLE=r?o:i,e.writeDoubleBE=r?i:o,e.readDoubleLE=r?s:a,e.readDoubleBE=r?a:s}():function(){function i(e,t,n,r,o,i){var s=r<0?1:0;if(s&&(r=-r),0===r)e(0,o,i+t),e(1/r>0?0:2147483648,o,i+n);else if(isNaN(r))e(0,o,i+t),e(2146959360,o,i+n);else if(r>17976931348623157e292)e(0,o,i+t),e((s<<31|2146435072)>>>0,o,i+n);else{var a;if(r<22250738585072014e-324)e((a=r/5e-324)>>>0,o,i+t),e((s<<31|a/4294967296)>>>0,o,i+n);else{var c=Math.floor(Math.log(r)/Math.LN2);1024===c&&(c=1023),e(4503599627370496*(a=r*Math.pow(2,-c))>>>0,o,i+t),e((s<<31|c+1023<<20|1048576*a&1048575)>>>0,o,i+n)}}}function s(e,t,n,r,o){var i=e(r,o+t),s=e(r,o+n),a=2*(s>>31)+1,c=s>>>20&2047,d=4294967296*(1048575&s)+i;return 2047===c?d?NaN:a*(1/0):0===c?5e-324*a*d:a*Math.pow(2,c-1075)*(d+4503599627370496)}e.writeDoubleLE=i.bind(null,t,0,4),e.writeDoubleBE=i.bind(null,n,4,0),e.readDoubleLE=s.bind(null,r,0,4),e.readDoubleBE=s.bind(null,o,4,0)}(),e}function t(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function n(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16&255,t[n+2]=e>>>8&255,t[n+3]=255&e}function r(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function o(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}return hasRequiredFloat=1,float=e(e)}function requireInquire(){if(hasRequiredInquire)return inquire_1;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}return hasRequiredInquire=1,inquire_1=inquire,inquire_1}var utf8$3={},hasRequiredUtf8,pool_1,hasRequiredPool,longbits,hasRequiredLongbits,hasRequiredMinimal$1,writer,hasRequiredWriter,writer_buffer,hasRequiredWriter_buffer,reader,hasRequiredReader,reader_buffer,hasRequiredReader_buffer;function requireUtf8(){return hasRequiredUtf8||(hasRequiredUtf8=1,function(){var e=utf8$3;e.length=function(e){for(var t=0,n=0,r=0;r<e.length;++r)(n=e.charCodeAt(r))<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},e.read=function(e,t,n){if(n-t<1)return"";for(var r,o=null,i=[],s=0;t<n;)(r=e[t++])<128?i[s++]=r:r>191&&r<224?i[s++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,i[s++]=55296+(r>>10),i[s++]=56320+(1023&r)):i[s++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),s=0);return o?(s&&o.push(String.fromCharCode.apply(String,i.slice(0,s))),o.join("")):String.fromCharCode.apply(String,i.slice(0,s))},e.write=function(e,t,n){for(var r,o,i=n,s=0;s<e.length;++s)(r=e.charCodeAt(s))<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(o=e.charCodeAt(s+1)))?(r=65536+((1023&r)<<10)+(1023&o),++s,t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=63&r|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=63&r|128);return n-i}}()),utf8$3}function requirePool(){if(hasRequiredPool)return pool_1;return hasRequiredPool=1,pool_1=function(e,t,n){var r=n||8192,o=r>>>1,i=null,s=r;return function(n){if(n<1||n>o)return e(n);s+n>r&&(i=e(r),s=0);var a=t.call(i,s,s+=n);return 7&s&&(s=1+(7|s)),a}},pool_1}function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=t;var e=requireMinimal$1();function t(e,t){this.lo=e>>>0,this.hi=t>>>0}var n=t.zero=new t(0,0);n.toNumber=function(){return 0},n.zzEncode=n.zzDecode=function(){return this},n.length=function(){return 1};var r=t.zeroHash="\0\0\0\0\0\0\0\0";t.fromNumber=function(e){if(0===e)return n;var r=e<0;r&&(e=-e);var o=e>>>0,i=(e-o)/4294967296>>>0;return r&&(i=~i>>>0,o=~o>>>0,++o>4294967295&&(o=0,++i>4294967295&&(i=0))),new t(o,i)},t.from=function(r){if("number"==typeof r)return t.fromNumber(r);if(e.isString(r)){if(!e.Long)return t.fromNumber(parseInt(r,10));r=e.Long.fromString(r)}return r.low||r.high?new t(r.low>>>0,r.high>>>0):n},t.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,n=~this.hi>>>0;return t||(n=n+1>>>0),-(t+4294967296*n)}return this.lo+4294967296*this.hi},t.prototype.toLong=function(t){return e.Long?new e.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var o=String.prototype.charCodeAt;return t.fromHash=function(e){return e===r?n:new t((o.call(e,0)|o.call(e,1)<<8|o.call(e,2)<<16|o.call(e,3)<<24)>>>0,(o.call(e,4)|o.call(e,5)<<8|o.call(e,6)<<16|o.call(e,7)<<24)>>>0)},t.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},t.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},t.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},t.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10},longbits}function requireMinimal$1(){return hasRequiredMinimal$1||(hasRequiredMinimal$1=1,function(){var e=minimal$1;function t(e,t,n){for(var r=Object.keys(t),o=0;o<r.length;++o)void 0!==e[r[o]]&&n||(e[r[o]]=t[r[o]]);return e}function n(e){function n(e,r){if(!(this instanceof n))return new n(e,r);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),r&&t(this,r)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return e},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}e.asPromise=requireAspromise(),e.base64=requireBase64(),e.EventEmitter=requireEventemitter(),e.float=requireFloat(),e.inquire=requireInquire(),e.utf8=requireUtf8(),e.pool=requirePool(),e.LongBits=requireLongbits(),e.isNode=Boolean(void 0!==commonjsGlobal&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),e.global=e.isNode&&commonjsGlobal||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||minimal$1,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},e.isString=function(e){return"string"==typeof e||e instanceof String},e.isObject=function(e){return e&&"object"==typeof e},e.isset=e.isSet=function(e,t){var n=e[t];return!(null==n||!e.hasOwnProperty(t))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},e.Buffer=function(){try{var t=e.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(e){return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(t){return"number"==typeof t?e.Buffer?e._Buffer_allocUnsafe(t):new e.Array(t):e.Buffer?e._Buffer_from(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},e.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(t){return t?e.LongBits.from(t).toHash():e.LongBits.zeroHash},e.longFromHash=function(t,n){var r=e.LongBits.fromHash(t);return e.Long?e.Long.fromBits(r.lo,r.hi,n):r.toNumber(Boolean(n))},e.merge=t,e.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},e.newError=n,e.ProtocolError=n("ProtocolError"),e.oneOfGetter=function(e){for(var t={},n=0;n<e.length;++n)t[e[n]]=1;return function(){for(var e=Object.keys(this),n=e.length-1;n>-1;--n)if(1===t[e[n]]&&void 0!==this[e[n]]&&null!==this[e[n]])return e[n]}},e.oneOfSetter=function(e){return function(t){for(var n=0;n<e.length;++n)e[n]!==t&&delete this[e[n]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var t=e.Buffer;t?(e._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},e._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):e._Buffer_from=e._Buffer_allocUnsafe=null}}()),minimal$1}function requireWriter(){if(hasRequiredWriter)return writer;hasRequiredWriter=1,writer=c;var e,t=requireMinimal$1(),n=t.LongBits,r=t.base64,o=t.utf8;function i(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}function s(){}function a(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function c(){this.len=0,this.head=new i(s,0,0),this.tail=this.head,this.states=null}var d=function(){return t.Buffer?function(){return(c.create=function(){return new e})()}:function(){return new c}};function u(e,t,n){t[n]=255&e}function l(e,t){this.len=e,this.next=void 0,this.val=t}function h(e,t,n){for(;e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function f(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}c.create=d(),c.alloc=function(e){return new t.Array(e)},t.Array!==Array&&(c.alloc=t.pool(c.alloc,t.Array.prototype.subarray)),c.prototype._push=function(e,t,n){return this.tail=this.tail.next=new i(e,t,n),this.len+=t,this},l.prototype=Object.create(i.prototype),l.prototype.fn=function(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e},c.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new l((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},c.prototype.int32=function(e){return e<0?this._push(h,10,n.fromNumber(e)):this.uint32(e)},c.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},c.prototype.uint64=function(e){var t=n.from(e);return this._push(h,t.length(),t)},c.prototype.int64=c.prototype.uint64,c.prototype.sint64=function(e){var t=n.from(e).zzEncode();return this._push(h,t.length(),t)},c.prototype.bool=function(e){return this._push(u,1,e?1:0)},c.prototype.fixed32=function(e){return this._push(f,4,e>>>0)},c.prototype.sfixed32=c.prototype.fixed32,c.prototype.fixed64=function(e){var t=n.from(e);return this._push(f,4,t.lo)._push(f,4,t.hi)},c.prototype.sfixed64=c.prototype.fixed64,c.prototype.float=function(e){return this._push(t.float.writeFloatLE,4,e)},c.prototype.double=function(e){return this._push(t.float.writeDoubleLE,8,e)};var p=t.Array.prototype.set?function(e,t,n){t.set(e,n)}:function(e,t,n){for(var r=0;r<e.length;++r)t[n+r]=e[r]};return c.prototype.bytes=function(e){var n=e.length>>>0;if(!n)return this._push(u,1,0);if(t.isString(e)){var o=c.alloc(n=r.length(e));r.decode(e,o,0),e=o}return this.uint32(n)._push(p,n,e)},c.prototype.string=function(e){var t=o.length(e);return t?this.uint32(t)._push(o.write,t,e):this._push(u,1,0)},c.prototype.fork=function(){return this.states=new a(this),this.head=this.tail=new i(s,0,0),this.len=0,this},c.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new i(s,0,0),this.len=0),this},c.prototype.ldelim=function(){var e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this},c.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t},c._configure=function(t){e=t,c.create=d(),e._configure()},writer}function requireWriter_buffer(){if(hasRequiredWriter_buffer)return writer_buffer;hasRequiredWriter_buffer=1,writer_buffer=n;var e=requireWriter();(n.prototype=Object.create(e.prototype)).constructor=n;var t=requireMinimal$1();function n(){e.call(this)}function r(e,n,r){e.length<40?t.utf8.write(e,n,r):n.utf8Write?n.utf8Write(e,r):n.write(e,r)}return n._configure=function(){n.alloc=t._Buffer_allocUnsafe,n.writeBytesBuffer=t.Buffer&&t.Buffer.prototype instanceof Uint8Array&&"set"===t.Buffer.prototype.set.name?function(e,t,n){t.set(e,n)}:function(e,t,n){if(e.copy)e.copy(t,n,0,e.length);else for(var r=0;r<e.length;)t[n++]=e[r++]}},n.prototype.bytes=function(e){t.isString(e)&&(e=t._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(n.writeBytesBuffer,r,e),this},n.prototype.string=function(e){var n=t.Buffer.byteLength(e);return this.uint32(n),n&&this._push(r,n,e),this},n._configure(),writer_buffer}function requireReader(){if(hasRequiredReader)return reader;hasRequiredReader=1,reader=i;var e,t=requireMinimal$1(),n=t.LongBits,r=t.utf8;function o(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function i(e){this.buf=e,this.pos=0,this.len=e.length}var s,a="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new i(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new i(e);throw Error("illegal buffer")},c=function(){return t.Buffer?function(n){return(i.create=function(n){return t.Buffer.isBuffer(n)?new e(n):a(n)})(n)}:a};function d(){var e=new n(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw o(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw o(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function u(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function l(){if(this.pos+8>this.len)throw o(this,8);return new n(u(this.buf,this.pos+=4),u(this.buf,this.pos+=4))}return i.create=c(),i.prototype._slice=t.Array.prototype.subarray||t.Array.prototype.slice,i.prototype.uint32=(s=4294967295,function(){if(s=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return s;if(s=(s|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return s;if(s=(s|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return s;if(s=(s|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return s;if(s=(s|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return s;if((this.pos+=5)>this.len)throw this.pos=this.len,o(this,10);return s}),i.prototype.int32=function(){return 0|this.uint32()},i.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)},i.prototype.bool=function(){return 0!==this.uint32()},i.prototype.fixed32=function(){if(this.pos+4>this.len)throw o(this,4);return u(this.buf,this.pos+=4)},i.prototype.sfixed32=function(){if(this.pos+4>this.len)throw o(this,4);return 0|u(this.buf,this.pos+=4)},i.prototype.float=function(){if(this.pos+4>this.len)throw o(this,4);var e=t.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},i.prototype.double=function(){if(this.pos+8>this.len)throw o(this,4);var e=t.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},i.prototype.bytes=function(){var e=this.uint32(),n=this.pos,r=this.pos+e;if(r>this.len)throw o(this,e);if(this.pos+=e,Array.isArray(this.buf))return this.buf.slice(n,r);if(n===r){var i=t.Buffer;return i?i.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,n,r)},i.prototype.string=function(){var e=this.bytes();return r.read(e,0,e.length)},i.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw o(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw o(this)}while(128&this.buf[this.pos++]);return this},i.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},i._configure=function(n){e=n,i.create=c(),e._configure();var r=t.Long?"toLong":"toNumber";t.merge(i.prototype,{int64:function(){return d.call(this)[r](!1)},uint64:function(){return d.call(this)[r](!0)},sint64:function(){return d.call(this).zzDecode()[r](!1)},fixed64:function(){return l.call(this)[r](!0)},sfixed64:function(){return l.call(this)[r](!1)}})},reader}function requireReader_buffer(){if(hasRequiredReader_buffer)return reader_buffer;hasRequiredReader_buffer=1,reader_buffer=n;var e=requireReader();(n.prototype=Object.create(e.prototype)).constructor=n;var t=requireMinimal$1();function n(t){e.call(this,t)}return n._configure=function(){t.Buffer&&(n.prototype._slice=t.Buffer.prototype.slice)},n.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},n._configure(),reader_buffer}var rpc={},service,hasRequiredService,hasRequiredRpc,roots,hasRequiredRoots,hasRequiredIndexMinimal,minimal,hasRequiredMinimal;function requireService(){if(hasRequiredService)return service;hasRequiredService=1,service=t;var e=requireMinimal$1();function t(t,n,r){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");e.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(n),this.responseDelimited=Boolean(r)}return(t.prototype=Object.create(e.EventEmitter.prototype)).constructor=t,t.prototype.rpcCall=function t(n,r,o,i,s){if(!i)throw TypeError("request must be specified");var a=this;if(!s)return e.asPromise(t,a,n,r,o,i);if(a.rpcImpl)try{return a.rpcImpl(n,r[a.requestDelimited?"encodeDelimited":"encode"](i).finish(),(function(e,t){if(e)return a.emit("error",e,n),s(e);if(null!==t){if(!(t instanceof o))try{t=o[a.responseDelimited?"decodeDelimited":"decode"](t)}catch(e){return a.emit("error",e,n),s(e)}return a.emit("data",t,n),s(null,t)}a.end(!0)}))}catch(e){return a.emit("error",e,n),void setTimeout((function(){s(e)}),0)}else setTimeout((function(){s(Error("already ended"))}),0)},t.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this},service}function requireRpc(){return hasRequiredRpc||(hasRequiredRpc=1,rpc.Service=requireService()),rpc}function requireRoots(){return hasRequiredRoots?roots:(hasRequiredRoots=1,roots={})}function requireIndexMinimal(){return hasRequiredIndexMinimal||(hasRequiredIndexMinimal=1,function(){var e=indexMinimal;function t(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}e.build="minimal",e.Writer=requireWriter(),e.BufferWriter=requireWriter_buffer(),e.Reader=requireReader(),e.BufferReader=requireReader_buffer(),e.util=requireMinimal$1(),e.rpc=requireRpc(),e.roots=requireRoots(),e.configure=t,t()}()),indexMinimal}function requireMinimal(){return hasRequiredMinimal?minimal:(hasRequiredMinimal=1,minimal=requireIndexMinimal())}var minimalExports=requireMinimal(),$protobuf=getDefaultExportFromCjs(minimalExports);const $Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots.unixfs||($protobuf.roots.unixfs={}),Data=$root.Data=(()=>{function e(e){if(this.blocksizes=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.Type=0,e.prototype.Data=$util.newBuffer([]),e.prototype.filesize=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.blocksizes=$util.emptyArray,e.prototype.hashType=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.fanout=$util.Long?$util.Long.fromBits(0,0,!0):0,e.prototype.mode=0,e.prototype.mtime=null,e.encode=function(e,t){if(t||(t=$Writer.create()),t.uint32(8).int32(e.Type),null!=e.Data&&Object.hasOwnProperty.call(e,"Data")&&t.uint32(18).bytes(e.Data),null!=e.filesize&&Object.hasOwnProperty.call(e,"filesize")&&t.uint32(24).uint64(e.filesize),null!=e.blocksizes&&e.blocksizes.length)for(var n=0;n<e.blocksizes.length;++n)t.uint32(32).uint64(e.blocksizes[n]);return null!=e.hashType&&Object.hasOwnProperty.call(e,"hashType")&&t.uint32(40).uint64(e.hashType),null!=e.fanout&&Object.hasOwnProperty.call(e,"fanout")&&t.uint32(48).uint64(e.fanout),null!=e.mode&&Object.hasOwnProperty.call(e,"mode")&&t.uint32(56).uint32(e.mode),null!=e.mtime&&Object.hasOwnProperty.call(e,"mtime")&&$root.UnixTime.encode(e.mtime,t.uint32(66).fork()).ldelim(),t},e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new $root.Data;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.Type=e.int32();break;case 2:r.Data=e.bytes();break;case 3:r.filesize=e.uint64();break;case 4:if(r.blocksizes&&r.blocksizes.length||(r.blocksizes=[]),2==(7&o))for(var i=e.uint32()+e.pos;e.pos<i;)r.blocksizes.push(e.uint64());else r.blocksizes.push(e.uint64());break;case 5:r.hashType=e.uint64();break;case 6:r.fanout=e.uint64();break;case 7:r.mode=e.uint32();break;case 8:r.mtime=$root.UnixTime.decode(e,e.uint32());break;default:e.skipType(7&o)}}if(!r.hasOwnProperty("Type"))throw $util.ProtocolError("missing required 'Type'",{instance:r});return r},e.fromObject=function(e){if(e instanceof $root.Data)return e;var t=new $root.Data;switch(e.Type){case"Raw":case 0:t.Type=0;break;case"Directory":case 1:t.Type=1;break;case"File":case 2:t.Type=2;break;case"Metadata":case 3:t.Type=3;break;case"Symlink":case 4:t.Type=4;break;case"HAMTShard":case 5:t.Type=5}if(null!=e.Data&&("string"==typeof e.Data?$util.base64.decode(e.Data,t.Data=$util.newBuffer($util.base64.length(e.Data)),0):e.Data.length&&(t.Data=e.Data)),null!=e.filesize&&($util.Long?(t.filesize=$util.Long.fromValue(e.filesize)).unsigned=!0:"string"==typeof e.filesize?t.filesize=parseInt(e.filesize,10):"number"==typeof e.filesize?t.filesize=e.filesize:"object"==typeof e.filesize&&(t.filesize=new $util.LongBits(e.filesize.low>>>0,e.filesize.high>>>0).toNumber(!0))),e.blocksizes){if(!Array.isArray(e.blocksizes))throw TypeError(".Data.blocksizes: array expected");t.blocksizes=[];for(var n=0;n<e.blocksizes.length;++n)$util.Long?(t.blocksizes[n]=$util.Long.fromValue(e.blocksizes[n])).unsigned=!0:"string"==typeof e.blocksizes[n]?t.blocksizes[n]=parseInt(e.blocksizes[n],10):"number"==typeof e.blocksizes[n]?t.blocksizes[n]=e.blocksizes[n]:"object"==typeof e.blocksizes[n]&&(t.blocksizes[n]=new $util.LongBits(e.blocksizes[n].low>>>0,e.blocksizes[n].high>>>0).toNumber(!0))}if(null!=e.hashType&&($util.Long?(t.hashType=$util.Long.fromValue(e.hashType)).unsigned=!0:"string"==typeof e.hashType?t.hashType=parseInt(e.hashType,10):"number"==typeof e.hashType?t.hashType=e.hashType:"object"==typeof e.hashType&&(t.hashType=new $util.LongBits(e.hashType.low>>>0,e.hashType.high>>>0).toNumber(!0))),null!=e.fanout&&($util.Long?(t.fanout=$util.Long.fromValue(e.fanout)).unsigned=!0:"string"==typeof e.fanout?t.fanout=parseInt(e.fanout,10):"number"==typeof e.fanout?t.fanout=e.fanout:"object"==typeof e.fanout&&(t.fanout=new $util.LongBits(e.fanout.low>>>0,e.fanout.high>>>0).toNumber(!0))),null!=e.mode&&(t.mode=e.mode>>>0),null!=e.mtime){if("object"!=typeof e.mtime)throw TypeError(".Data.mtime: object expected");t.mtime=$root.UnixTime.fromObject(e.mtime)}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.blocksizes=[]),t.defaults){if(n.Type=t.enums===String?"Raw":0,t.bytes===String?n.Data="":(n.Data=[],t.bytes!==Array&&(n.Data=$util.newBuffer(n.Data))),$util.Long){var r=new $util.Long(0,0,!0);n.filesize=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.filesize=t.longs===String?"0":0;if($util.Long){r=new $util.Long(0,0,!0);n.hashType=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.hashType=t.longs===String?"0":0;if($util.Long){r=new $util.Long(0,0,!0);n.fanout=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.fanout=t.longs===String?"0":0;n.mode=0,n.mtime=null}if(null!=e.Type&&e.hasOwnProperty("Type")&&(n.Type=t.enums===String?$root.Data.DataType[e.Type]:e.Type),null!=e.Data&&e.hasOwnProperty("Data")&&(n.Data=t.bytes===String?$util.base64.encode(e.Data,0,e.Data.length):t.bytes===Array?Array.prototype.slice.call(e.Data):e.Data),null!=e.filesize&&e.hasOwnProperty("filesize")&&("number"==typeof e.filesize?n.filesize=t.longs===String?String(e.filesize):e.filesize:n.filesize=t.longs===String?$util.Long.prototype.toString.call(e.filesize):t.longs===Number?new $util.LongBits(e.filesize.low>>>0,e.filesize.high>>>0).toNumber(!0):e.filesize),e.blocksizes&&e.blocksizes.length){n.blocksizes=[];for(var o=0;o<e.blocksizes.length;++o)"number"==typeof e.blocksizes[o]?n.blocksizes[o]=t.longs===String?String(e.blocksizes[o]):e.blocksizes[o]:n.blocksizes[o]=t.longs===String?$util.Long.prototype.toString.call(e.blocksizes[o]):t.longs===Number?new $util.LongBits(e.blocksizes[o].low>>>0,e.blocksizes[o].high>>>0).toNumber(!0):e.blocksizes[o]}return null!=e.hashType&&e.hasOwnProperty("hashType")&&("number"==typeof e.hashType?n.hashType=t.longs===String?String(e.hashType):e.hashType:n.hashType=t.longs===String?$util.Long.prototype.toString.call(e.hashType):t.longs===Number?new $util.LongBits(e.hashType.low>>>0,e.hashType.high>>>0).toNumber(!0):e.hashType),null!=e.fanout&&e.hasOwnProperty("fanout")&&("number"==typeof e.fanout?n.fanout=t.longs===String?String(e.fanout):e.fanout:n.fanout=t.longs===String?$util.Long.prototype.toString.call(e.fanout):t.longs===Number?new $util.LongBits(e.fanout.low>>>0,e.fanout.high>>>0).toNumber(!0):e.fanout),null!=e.mode&&e.hasOwnProperty("mode")&&(n.mode=e.mode),null!=e.mtime&&e.hasOwnProperty("mtime")&&(n.mtime=$root.UnixTime.toObject(e.mtime,t)),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e.DataType=function(){const e={},t=Object.create(e);return t[e[0]="Raw"]=0,t[e[1]="Directory"]=1,t[e[2]="File"]=2,t[e[3]="Metadata"]=3,t[e[4]="Symlink"]=4,t[e[5]="HAMTShard"]=5,t}(),e})();$root.UnixTime=(()=>{function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.Seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,e.prototype.FractionalNanoseconds=0,e.encode=function(e,t){return t||(t=$Writer.create()),t.uint32(8).int64(e.Seconds),null!=e.FractionalNanoseconds&&Object.hasOwnProperty.call(e,"FractionalNanoseconds")&&t.uint32(21).fixed32(e.FractionalNanoseconds),t},e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new $root.UnixTime;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.Seconds=e.int64();break;case 2:r.FractionalNanoseconds=e.fixed32();break;default:e.skipType(7&o)}}if(!r.hasOwnProperty("Seconds"))throw $util.ProtocolError("missing required 'Seconds'",{instance:r});return r},e.fromObject=function(e){if(e instanceof $root.UnixTime)return e;var t=new $root.UnixTime;return null!=e.Seconds&&($util.Long?(t.Seconds=$util.Long.fromValue(e.Seconds)).unsigned=!1:"string"==typeof e.Seconds?t.Seconds=parseInt(e.Seconds,10):"number"==typeof e.Seconds?t.Seconds=e.Seconds:"object"==typeof e.Seconds&&(t.Seconds=new $util.LongBits(e.Seconds.low>>>0,e.Seconds.high>>>0).toNumber())),null!=e.FractionalNanoseconds&&(t.FractionalNanoseconds=e.FractionalNanoseconds>>>0),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults){if($util.Long){var r=new $util.Long(0,0,!1);n.Seconds=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.Seconds=t.longs===String?"0":0;n.FractionalNanoseconds=0}return null!=e.Seconds&&e.hasOwnProperty("Seconds")&&("number"==typeof e.Seconds?n.Seconds=t.longs===String?String(e.Seconds):e.Seconds:n.Seconds=t.longs===String?$util.Long.prototype.toString.call(e.Seconds):t.longs===Number?new $util.LongBits(e.Seconds.low>>>0,e.Seconds.high>>>0).toNumber():e.Seconds),null!=e.FractionalNanoseconds&&e.hasOwnProperty("FractionalNanoseconds")&&(n.FractionalNanoseconds=e.FractionalNanoseconds),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e})(),$root.Metadata=(()=>{function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.MimeType="",e.encode=function(e,t){return t||(t=$Writer.create()),null!=e.MimeType&&Object.hasOwnProperty.call(e,"MimeType")&&t.uint32(10).string(e.MimeType),t},e.decode=function(e,t){e instanceof $Reader||(e=$Reader.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new $root.Metadata;e.pos<n;){var o=e.uint32();if(o>>>3==1)r.MimeType=e.string();else e.skipType(7&o)}return r},e.fromObject=function(e){if(e instanceof $root.Metadata)return e;var t=new $root.Metadata;return null!=e.MimeType&&(t.MimeType=String(e.MimeType)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.MimeType=""),null!=e.MimeType&&e.hasOwnProperty("MimeType")&&(n.MimeType=e.MimeType),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e})();const NodeType=Data.DataType,EMPTY$3=Object.freeze([]),EMPTY_BUFFER$1=new Uint8Array(0),BLANK$2=Object.freeze({}),DEFAULT_FILE_MODE=parseInt("0644",8),DEFAULT_DIRECTORY_MODE=parseInt("0755",8),code$1=code$2,name$1="UnixFS",encodePB=(e,t)=>(Object(globalThis).debug&&console.log({data:e,links:t}),encode$6(prepare({Data:Data.encode(e).finish(),Links:t}))),createRaw=e=>({type:NodeType.Raw,content:e}),createEmptyFile=e=>createSimpleFile(EMPTY_BUFFER$1,e),createSimpleFile=(e,t)=>({type:NodeType.File,layout:"simple",content:e,metadata:decodeMetadata(t)}),createFileChunk=e=>({type:NodeType.File,layout:"simple",content:e}),createAdvancedFile=(e,t)=>({type:NodeType.File,layout:"advanced",parts:e,metadata:decodeMetadata(t)}),createFileShard=e=>({type:NodeType.File,layout:"advanced",parts:e}),createComplexFile=(e,t,n)=>({type:NodeType.File,layout:"complex",content:e,parts:t,metadata:decodeMetadata(n)}),createFlatDirectory=(e,t)=>({type:NodeType.Directory,metadata:decodeMetadata(t),entries:e}),createShardedDirectory=(e,t,n,r,o=BLANK$2)=>({type:NodeType.HAMTShard,bitfield:t,fanout:readFanout(n),hashType:readInt(r),entries:e,metadata:decodeMetadata(o)}),createDirectoryShard=(e,t,n,r)=>({type:NodeType.HAMTShard,bitfield:t,fanout:readFanout(n),hashType:readInt(r),entries:e}),encodeRaw=e=>encodePB({Type:NodeType.Raw,Data:e.byteLength>0?e:void 0,filesize:e.byteLength,blocksizes:EMPTY$3},[]),encodeFile=(e,t=!1)=>{const n=t?BLANK$2:Object(e).metadata;switch(e.layout){case"simple":return encodeSimpleFile(e.content,n);case"advanced":return encodeAdvancedFile(e.parts,n);case"complex":return encodeComplexFile(e.content,e.parts,n);default:throw new TypeError(`File with unknown layout "${Object(e).layout}" was passed`)}},encodeFileChunk=e=>encodeSimpleFile(e,BLANK$2),encodeFileShard=e=>encodePB({Type:NodeType.File,blocksizes:e.map(contentByteLength),filesize:cumulativeContentByteLength(e)},e.map(encodeLink)),encodeAdvancedFile=(e,t=BLANK$2)=>encodePB({Type:NodeType.File,blocksizes:e.map(contentByteLength),filesize:cumulativeContentByteLength(e),...encodeMetadata(t)},e.map(encodeLink)),encodeLink=e=>({Name:"",Tsize:e.dagByteLength,Hash:e.cid}),encodeSimpleFile=(e,t=BLANK$2)=>encodePB({Type:NodeType.File,Data:e.byteLength>0?e:void 0,filesize:e.byteLength,blocksizes:[],...encodeMetadata(t)},[]),encodeComplexFile=(e,t,n=BLANK$2)=>encodePB({Type:NodeType.File,Data:e,filesize:e.byteLength+cumulativeContentByteLength(t),blocksizes:t.map(contentByteLength)},t.map(encodeLink)),encodeDirectory=e=>encodePB({Type:e.type,...encodeDirectoryMetadata(e.metadata||BLANK$2)},e.entries.map(encodeNamedLink)),encodeHAMTShard=({bitfield:e,fanout:t,hashType:n,entries:r,metadata:o=BLANK$2})=>encodePB({Type:NodeType.HAMTShard,Data:e.byteLength>0?e:void 0,fanout:readFanout(t),hashType:readInt(n),...encodeDirectoryMetadata(o)},r.map(encodeNamedLink)),readFanout=e=>{if(Math.log2(e)%1==0)return e;throw new TypeError(`Expected hamt size to be a power of two instead got ${e}`)},readInt=e=>{if(Number.isInteger(e))return e;throw new TypeError(`Expected an integer value instead got ${e}`)},createSymlink=(e,t=BLANK$2)=>({type:NodeType.Symlink,content:e,metadata:decodeMetadata(t)}),encodeSymlink=(e,t=!1)=>{const n=t?BLANK$2:Object(e).metadata;return encodePB({Type:NodeType.Symlink,Data:e.content,...encodeMetadata(n||BLANK$2)},[])},encode$5=(e,t=!0)=>{switch(e.type){case NodeType.Raw:return encodeRaw(e.content);case NodeType.File:return encodeFile(e);case NodeType.Directory:return encodeDirectory(e);case NodeType.HAMTShard:return encodeHAMTShard(e);case NodeType.Symlink:return encodeSymlink(e);default:throw new Error(`Unknown node type ${Object(e).type}`)}},decode$6=e=>{const t=decode$7(e),n=Data.decode(t.Data),{Type:r,Data:o,mtime:i,mode:s,blocksizes:a,...c}=Data.toObject(n,{defaults:!1,arrays:!0,longs:Number,objects:!1}),d={...s&&{mode:s},...decodeMtime(i)},u=t.Links;switch(n.Type){case NodeType.Raw:return createRaw(o);case NodeType.File:return 0===u.length?new SimpleFileView(o,d):0===o.byteLength?new AdvancedFileView(decodeFileLinks(c.blocksizes,u),d):new ComplexFileView(o,decodeFileLinks(c.blocksizes,u),d);case NodeType.Directory:return createFlatDirectory(decodeDirectoryLinks(u),d);case NodeType.HAMTShard:return createShardedDirectory(decodeDirectoryLinks(u),o||EMPTY_BUFFER$1,c.fanout,c.hashType,d);case NodeType.Symlink:return createSymlink(o,d);default:throw new TypeError(`Unsupported node type ${n.Type}`)}},decodeMtime=e=>null==e?void 0:{mtime:{secs:e.Seconds,nsecs:e.FractionalNanoseconds||0}},decodeFileLinks=(e,t)=>{const n=[],r=e.length;for(;0<r;)n.push({cid:t[0].Hash,dagByteLength:t[0].Tsize||0,contentByteLength:e[0]});return n},decodeDirectoryLinks=e=>e.map((e=>({cid:e.Hash,name:e.Name||"",dagByteLength:e.Tsize||0}))),cumulativeContentByteLength=e=>e.reduce(((e,t)=>e+t.contentByteLength),0),cumulativeDagByteLength=(e,t)=>t.reduce(((e,t)=>e+t.dagByteLength),e.byteLength),contentByteLength=e=>e.contentByteLength,encodeNamedLink=({name:e,dagByteLength:t,cid:n})=>({Name:e,Tsize:t,Hash:n}),encodeDirectoryMetadata=e=>encodeMetadata(e,DEFAULT_DIRECTORY_MODE),encodeMetadata=({mode:e,mtime:t},n=DEFAULT_FILE_MODE)=>({mode:null!=e?encodeMode(e,n):void 0,mtime:null!=t?encodeMTime(t):void 0}),decodeMetadata=e=>null==e?BLANK$2:{...null==e.mode?void 0:{mode:decodeMode(e.mode)},...null==e.mtime?void 0:{mtime:e.mtime}},encodeMTime=e=>null==e?void 0:0!==e.nsecs?{Seconds:e.secs,FractionalNanoseconds:e.nsecs}:{Seconds:e.secs},encodeMode=(e,t)=>{const n=null==e?void 0:decodeMode(e);return n===t||null==n?void 0:n},decodeMode=e=>4095&e|4294963200&e,matchFile=({content:e=EMPTY_BUFFER$1,parts:t=EMPTY$3,metadata:n=BLANK$2,...r})=>0===t.length?new SimpleFileView(e,n):0===e.byteLength?new AdvancedFileView(t,n):new ComplexFileView(e,t,n);class SimpleFileView{constructor(e,t){this.content=e,this.metadata=t,this.layout="simple",this.type=NodeType.File}get filesize(){return this.content.byteLength}encode(){return encodeSimpleFile(this.content,this.metadata)}}class AdvancedFileView{constructor(e,t){this.parts=e,this.metadata=t}get layout(){return"advanced"}get type(){return NodeType.File}get fileSize(){return cumulativeContentByteLength(this.parts)}get blockSizes(){return this.parts.map(contentByteLength)}encode(){return encodeAdvancedFile(this.parts,this.metadata)}}class ComplexFileView{constructor(e,t,n){this.content=e,this.parts=t,this.metadata=n}get layout(){return"complex"}get type(){return NodeType.File}get fileSize(){return this.content.byteLength+cumulativeContentByteLength(this.parts)}get blockSizes(){return this.parts.map(contentByteLength)}encode(){return encodeComplexFile(this.content,this.parts,this.metadata)}}const filesize=e=>{switch(e.type){case NodeType.Raw:case NodeType.Symlink:return e.content.byteLength;case NodeType.File:switch(e.layout){case"simple":return e.content.byteLength;case"advanced":return cumulativeContentByteLength(e.parts);case"complex":return e.content.byteLength+cumulativeContentByteLength(e.parts)}default:return 0}};var UnixFS=Object.freeze({__proto__:null,DEFAULT_DIRECTORY_MODE:DEFAULT_DIRECTORY_MODE,DEFAULT_FILE_MODE:DEFAULT_FILE_MODE,NodeType:NodeType,code:code$1,createAdvancedFile:createAdvancedFile,createComplexFile:createComplexFile,createDirectoryShard:createDirectoryShard,createEmptyFile:createEmptyFile,createFileChunk:createFileChunk,createFileShard:createFileShard,createFlatDirectory:createFlatDirectory,createRaw:createRaw,createShardedDirectory:createShardedDirectory,createSimpleFile:createSimpleFile,createSymlink:createSymlink,cumulativeContentByteLength:cumulativeContentByteLength,cumulativeDagByteLength:cumulativeDagByteLength,decode:decode$6,decodeMetadata:decodeMetadata,encode:encode$5,encodeAdvancedFile:encodeAdvancedFile,encodeComplexFile:encodeComplexFile,encodeDirectory:encodeDirectory,encodeDirectoryMetadata:encodeDirectoryMetadata,encodeFile:encodeFile,encodeFileChunk:encodeFileChunk,encodeFileShard:encodeFileShard,encodeHAMTShard:encodeHAMTShard,encodeLink:encodeLink,encodeMetadata:encodeMetadata,encodeMode:encodeMode,encodeRaw:encodeRaw,encodeSimpleFile:encodeSimpleFile,encodeSymlink:encodeSymlink,filesize:filesize,matchFile:matchFile,name:name$1});const effect=function*(e){const t=yield*e;yield*send(t)};function*current(){return yield CURRENT}const suspend=function*(){yield SUSPEND},wait=function*(e){const t=yield*current();if(isAsync(e)){let n,r=!1;if(e.then((e=>{r=!1,n=e,enqueue(t)}),(e=>{r=!0,n=e,enqueue(t)})),yield*suspend(),r)throw n;return n}return main(wake(t)),yield*suspend(),e};function*wake(e){enqueue(e)}const isAsync=e=>null!=e&&"function"==typeof e.then,send=function*(e){yield e},listen=function*(e){const t=[];for(const n of Object.entries(e)){const[e,r]=n;r!==NONE&&t.push(yield*fork$3(tag(r,e)))}yield*group(t)},effects=e=>e.length>0?batch(e.map(effect)):NONE;function*batch(e){const t=[];for(const n of e)t.push(yield*fork$3(n));yield*group(t)}const tag=(e,t)=>e===NONE?NONE:e instanceof Tagger?new Tagger([...e.tags,t],e.source):new Tagger([t],e);class Tagger{constructor(e,t){this.tags=e,this.source=t,this.controller}[Symbol.iterator](){return this.controller||(this.controller=this.source[Symbol.iterator]()),this}box(e){if(e.done)return e;switch(e.value){case SUSPEND:case CURRENT:return e;default:{const t=e;let{value:n}=t;for(const e of this.tags)n=withTag(e,n);return t.value=n,t}}}next(e){return this.box(this.controller.next(e))}throw(e){return this.box(this.controller.throw(e))}return(e){return this.box(this.controller.return(e))}get[Symbol.toStringTag](){return"TaggedEffect"}}const none=()=>NONE,withTag=(e,t)=>({type:e,[e]:t}),CURRENT=Symbol("current"),SUSPEND=Symbol("suspend");class Group{static of(e){return e.group||MAIN}static enqueue(e,t){e.group=t,t.stack.active.push(e)}constructor(e,t=[],n=new Set,r=new Stack(t,n)){this.driver=e,this.parent=Group.of(e),this.stack=r,this.id=++ID}}class Main{constructor(){this.status=IDLE,this.stack=new Stack,this.id=0}}class Stack{constructor(e=[],t=new Set){this.active=e,this.idle=t}static size({active:e,idle:t}){return e.length+t.size}}const main=e=>enqueue(e[Symbol.iterator]()),enqueue=e=>{let t=Group.of(e);for(t.stack.active.push(e),t.stack.idle.delete(e);t.parent;){const{idle:e,active:n}=t.parent.stack;if(!e.has(t.driver))break;e.delete(t.driver),n.push(t.driver),t=t.parent}if(MAIN.status===IDLE)for(MAIN.status=ACTIVE;;)try{for(const e of step(MAIN));MAIN.status=IDLE;break}catch(e){MAIN.stack.active.shift()}},resume=e=>enqueue(e),step=function*(e){const{active:t}=e.stack;let n=t[0];for(e.stack.idle.delete(n);n;){let r=INIT;e:for(;!r.done&&n===t[0];){const t=r.value;switch(t){case SUSPEND:e.stack.idle.add(n);break e;case CURRENT:r=n.next(n);break;default:r=n.next(yield t)}}t.shift(),n=t[0],e.stack.idle.delete(n)}},fork$3=(e,t)=>new Fork(e,t),exit=(e,t)=>conclude(e,{ok:!0,value:t}),abort=(e,t)=>conclude(e,{ok:!1,error:t});function*conclude(e,t){try{const n=e,r=t.ok?n.return(t.value):n.throw(t.error);if(!r.done)if(r.value===SUSPEND){const{idle:e}=Group.of(n).stack;e.add(n)}else enqueue(n)}catch(e){}}function*group(e){if(0===e.length)return;const t=yield*current(),n=new Group(t);let r=null;for(const t of e){const{result:e}=t;e?e.ok||r||(r=e):move(t,n)}try{if(r)throw r.error;for(;yield*step(n),Stack.size(n.stack)>0;)yield*suspend()}catch(e){for(const t of n.stack.active)yield*abort(t,e);for(const t of n.stack.idle)yield*abort(t,e),enqueue(t);throw e}}const move=(e,t)=>{const n=Group.of(e);if(n!==t){const{active:r,idle:o}=n.stack,i=t.stack;if(e.group=t,o.has(e))o.delete(e),i.idle.add(e);else{const t=r.indexOf(e);t>=0&&(r.splice(t,1),i.active.push(e))}}};function*join(e){e.status===IDLE&&(yield*e),e.result||(yield*group([e]));const t=e.result;if(t.ok)return t.value;throw t.error}class Future{constructor(e){this.handler=e,this.result}get promise(){const{result:e}=this,t=null==e?new Promise(((e,t)=>{this.handler.onsuccess=e,this.handler.onfailure=t})):e.ok?Promise.resolve(e.value):Promise.reject(e.error);return Object.defineProperty(this,"promise",{value:t}),t}then(e,t){return this.activate().promise.then(e,t)}catch(e){return this.activate().promise.catch(e)}finally(e){return this.activate().promise.finally(e)}activate(){return this}}class Fork extends Future{constructor(e,t=BLANK$1,n={},r=INIT){super(n),this.id=++ID,this.name=t.name||"",this.task=e,this.state=r,this.status=IDLE,this.result,this.handler=n,this.controller}*resume(){resume(this)}join(){return join(this)}abort(e){return abort(this,e)}exit(e){return exit(this,e)}get[Symbol.toStringTag](){return"Fork"}*[Symbol.iterator](){return this.activate()}activate(){return this.controller=this.task[Symbol.iterator](),this.status=ACTIVE,enqueue(this),this}panic(e){this.result={ok:!1,error:e},this.status=FINISHED;const{handler:t}=this;throw t.onfailure&&t.onfailure(e),e}step(e){if(this.state=e,e.done){this.result={ok:!0,value:e.value},this.status=FINISHED;const{handler:t}=this;t.onsuccess&&t.onsuccess(e.value)}return e}next(e){try{return this.step(this.controller.next(e))}catch(e){return this.panic(e)}}return(e){try{return this.step(this.controller.return(e))}catch(e){return this.panic(e)}}throw(e){try{return this.step(this.controller.throw(e))}catch(e){return this.panic(e)}}}const loop=function*(e,t){const n=yield*current(),r=new Group(n);for(Group.enqueue(e[Symbol.iterator](),r);;){for(const e of step(r))Group.enqueue(t(e)[Symbol.iterator](),r);if(!(Stack.size(r.stack)>0))break;yield*suspend()}};let ID=0;const IDLE="idle",ACTIVE="active",FINISHED="finished",INIT={done:!1,value:CURRENT},BLANK$1={},NONE=function*(){}(),MAIN=new Main;function Indexed(){}Object.defineProperties(Indexed,{prototype:{value:new Proxy(Object.prototype,{get:(e,t,n)=>"symbol"==typeof t?Reflect.get(e,t,n):n.get(t)})}});const empty$2=()=>new BufferView,slice=(e,t=0,n=e.byteLength)=>{const r=[],o=t<0?e.byteLength-t:t,i=n<0?e.byteLength-n:n;if(0===o&&i>=e.byteLength)return e;if(o>i||o>e.byteLength||i<=0)return empty$2();let s=0,a=0;for(const t of e.segments){const e=a+t.byteLength;if(0===s){if(i<=e){const e=t.subarray(o-a,i-a);r.push(e),s=e.byteLength;break}if(o<e){const e=o===a?t:t.subarray(o-a);r.push(e),s=e.byteLength}}else{if(i<=e){const n=i===e?t:t.subarray(0,i-a);r.push(n),s+=n.byteLength;break}r.push(t),s+=t.byteLength}a=e}return new BufferView(r,e.byteOffset+o,s)},push=(e,t)=>t.byteLength>0?(e.segments.push(t),new BufferView(e.segments,e.byteOffset,e.byteLength+t.byteLength)):e,get$6=(e,t)=>{if(t<e.byteLength){let n=0;for(const r of e.segments){if(t<n+r.byteLength)return r[t-n];n+=r.byteLength}}},copyTo=(e,t,n)=>{let r=n;for(const n of e.segments)t.set(n,r),r+=n.byteLength;return t};function*iterate$1(e){for(const t of e.segments)yield*t}class BufferView extends Indexed{constructor(e=[],t=0,n=0){super(),this.segments=e,this.byteLength=n,this.length=n,this.byteOffset=t}[Symbol.iterator](){return iterate$1(this)}slice(e,t){return slice(this,e,t)}subarray(e,t){return slice(this,e,t)}push(e){return push(this,e)}get(e){return get$6(this,e)}copyTo(e,t){return copyTo(this,e,t)}}const panic=e=>{throw new Error(e)},unreachable=(e,t,...n)=>panic(String.raw(e,JSON.stringify(t),...n)),EMPTY_BUFFER=new Uint8Array(0),EMPTY$2=[],open$1=e=>({config:e,buffer:empty$2()}),write$3=(e,t)=>t.byteLength>0?split(e.config,e.buffer.push(t),!1):{...e,chunks:EMPTY$2},close$6=e=>split(e.config,e.buffer,!0),split=(e,t,n)=>{const r=e.chunker,o=[];let i=0;for(const e of r.cut(r.context,t,n))if(e>0){const n=t.subarray(i,i+e);o.push(n),i+=e}return{config:e,chunks:o,buffer:t.subarray(i)}},mutable=()=>({mutable:!0,needs:{},nodes:{},links:{},linked:EMPTY$1}),addNodes=(e,t)=>{let n=patch(t,{});for(const t of e){const{ready:e,has:r,wants:o}=collect(t.children,n.links);n=0===o.length?patch(n,{links:assign(void 0,r),linked:[{id:t.id,links:e}]}):patch(n,{needs:assign(t.id,o),nodes:{[t.id]:{children:t.children,count:o.length}}})}return n},addLink=(e,t,n)=>{const r=n.needs[e],o=n.nodes[r];if(null!=o){if(1===o.count){const{ready:i,has:s}=collect(o.children,{...n.links,[e]:t});return patch(n,{needs:{[e]:void 0},links:assign(void 0,s),nodes:{[r]:void 0},linked:[{id:r,links:i}]})}return patch(n,{needs:{[e]:void 0},links:{[e]:t},nodes:{[r]:{...o,count:o.count-1}}})}return patch(n,{links:{[e]:t}})},patch=(e,{needs:t,nodes:n,links:r,linked:o})=>{const i=e.mutable?e:{...e},s=e.mutable?BLANK:void 0;return t&&(i.needs=patchDict(e.needs,t,s)),n&&(i.nodes=patchDict(e.nodes,n,s)),r&&(i.links=patchDict(e.links,r,s)),i.linked=o?append(e.linked||EMPTY$1,o,EMPTY$1):e.linked||[],i},assign=(e,t)=>{const n={};for(const r of t)n[r]=e;return n},patchDict=(e,t,n=e)=>{const r=e===n?{...e}:e;for(const e of Object.entries(t)){const[t,n]=e;null==n?delete r[t]:r[t]=n}return r},append=(e,t,n=e)=>{if(e===n)return[...e,...t];for(const n of t)e.push(n);return e},collect=(e,t)=>{const n=[],r=[],o=[];for(const i of e){const e=t[i];e?(n.push(i),o.push(e)):r.push(i)}return{has:n,wants:r,ready:o}},EMPTY$1=Object.freeze([]),BLANK=Object.freeze({}),update=(e,t)=>{switch(e.type){case"write":return write$2(t,e.bytes);case"link":return link(t,e.link);case"block":case"end":return{state:t,effect:none()};case"close":return close$5(t);default:return unreachable`File Writer got unknown message ${e}`}},init=(e,t,n)=>({status:"open",metadata:t,config:n,writer:e,chunker:open$1({chunker:n.chunker}),layout:n.fileLayout.open(),nodeQueue:mutable()}),write$2=(e,t)=>{if("open"===e.status){const{chunks:n,...r}=write$3(e.chunker,t),{nodes:o,leaves:i,layout:s}=e.config.fileLayout.write(e.layout,n),{linked:a,...c}=addNodes(o,e.nodeQueue),d=[...encodeLeaves(i,e.config),...encodeBranches(a,e.config)];return{state:{...e,chunker:r,layout:s,nodeQueue:c},effect:listen({link:effects(d)})}}return panic("Unable to perform write on closed file")},link=(e,{id:t,link:n,block:r})=>{let{linked:o,...i}=addLink(t,n,e.nodeQueue);const s=encodeBranches(o,e.config),a="closed"===e.status&&t===e.rootID?{...e,status:"linked",link:n,nodeQueue:i}:{...e,nodeQueue:i},c="closed"===e.status&&t===e.rootID&&e.end?e.end.resume():none();return{state:a,effect:listen({link:effects(s),block:writeBlock(e.writer,r),end:c})}},close$5=e=>{if("open"===e.status){const{chunks:t}=close$6(e.chunker),{layout:n,...r}=e.config.fileLayout.write(e.layout,t),{root:o,...i}=e.config.fileLayout.close(n,e.metadata),[s,a]=isLeafNode(o)?[[...r.nodes,...i.nodes],[...r.leaves,...i.leaves,o]]:[[...r.nodes,...i.nodes,o],[...r.leaves,...i.leaves]],{linked:c,...d}=addNodes(s,e.nodeQueue),u=[...encodeLeaves(a,e.config),...encodeBranches(c,e.config)],l=fork$3(suspend());return{state:{...e,chunker:null,layout:null,rootID:o.id,status:"closed",end:l,nodeQueue:d},effect:listen({link:effects(u),end:join(l)})}}return{state:e,effect:none()}},encodeLeaves=(e,t)=>e.map((e=>encodeLeaf(t,e,t.fileChunkEncoder))),encodeLeaf=function*({hasher:e,linker:t},{id:n,content:r},o){const i=o.encode(r?asUint8Array(r):EMPTY_BUFFER),s=yield*wait(e.digest(i)),a=t.createLink(o.code,s);return{id:n,block:{cid:a,bytes:i},link:{cid:a,contentByteLength:r?r.byteLength:0,dagByteLength:i.byteLength}}},encodeBranches=(e,t)=>e.map((e=>encodeBranch(t,e))),encodeBranch=function*(e,{id:t,links:n},r){const o=e.fileEncoder.encode({type:NodeType.File,layout:"advanced",parts:n,metadata:r}),i=yield*wait(Promise.resolve(e.hasher.digest(o))),s=e.linker.createLink(e.fileEncoder.code,i);return{id:t,block:{bytes:o,cid:s},link:{cid:s,contentByteLength:cumulativeContentByteLength(n),dagByteLength:cumulativeDagByteLength(o,n)}}},writeBlock=function*(e,t){(e.desiredSize||0)<=0&&(yield*wait(e.ready)),e.write(t)},asUint8Array=e=>e instanceof Uint8Array?e:e.copyTo(new Uint8Array(e.byteLength),0),isLeafNode=e=>null==e.children,name="fixed",context={maxChunkSize:262144},type="Stateless",withMaxChunkSize=e=>({type:"Stateless",context:{maxChunkSize:e},name:name,cut:cut}),cut=({maxChunkSize:e},{byteLength:t},n)=>{const r=t/e|0,o=new Array(r).fill(e),i=n?t-r*e:0;return i>0&&o.push(i),o};var FixedSize=Object.freeze({__proto__:null,context:context,cut:cut,name:name,type:type,withMaxChunkSize:withMaxChunkSize});const equals$1=(e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0},coerce=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};var encode_1$1=encode$4,MSB$3=128,MSBALL$2=-128,INT$2=Math.pow(2,31);function encode$4(e,t,n){t=t||[];for(var r=n=n||0;e>=INT$2;)t[n++]=255&e|MSB$3,e/=128;for(;e&MSBALL$2;)t[n++]=255&e|MSB$3,e>>>=7;return t[n]=0|e,encode$4.bytes=n-r+1,t}var decode$5=read$2,MSB$1$1=128,REST$1$1=127;function read$2(e,t){var n,r=0,o=0,i=t=t||0,s=e.length;do{if(i>=s)throw read$2.bytes=0,new RangeError("Could not decode varint");n=e[i++],r+=o<28?(n&REST$1$1)<<o:(n&REST$1$1)*Math.pow(2,o),o+=7}while(n>=MSB$1$1);return read$2.bytes=i-t,r}var N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),length$1=function(e){return e<N1$1?1:e<N2$1?2:e<N3$1?3:e<N4$1?4:e<N5$1?5:e<N6$1?6:e<N7$1?7:e<N8$1?8:e<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$5,encodingLength:length$1},_brrp_varint$1=varint$1;const decode$4=(e,t=0)=>[_brrp_varint$1.decode(e,t),_brrp_varint$1.decode.bytes],encodeTo$1=(e,t,n=0)=>(_brrp_varint$1.encode(e,t,n),t),encodingLength$1=e=>_brrp_varint$1.encodingLength(e),create$8=(e,t)=>{const n=t.byteLength,r=encodingLength$1(e),o=r+encodingLength$1(n),i=new Uint8Array(o+n);return encodeTo$1(e,i,0),encodeTo$1(n,i,r),i.set(t,o),new Digest$1(e,n,t,i)},decode$3=e=>{const t=coerce(e),[n,r]=decode$4(t),[o,i]=decode$4(t.subarray(r)),s=t.subarray(r+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest$1(n,o,s,t)},equals=(e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&equals$1(e.bytes,n.bytes)}};let Digest$1=class{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}};const from$6=({name:e,code:t,encode:n})=>new Hasher$1(e,t,n);let Hasher$1=class{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?create$8(this.code,t):t.then((e=>create$8(this.code,e)))}throw Error("Unknown type, must be binary type")}};const sha$1=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),sha256$1=from$6({name:"sha2-256",code:18,encode:sha$1("SHA-256")});function base(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==n[s])throw new TypeError(i+" is ambiguous");n[s]=o}var a=e.length,c=e.charAt(0),d=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,o=0;e[t]===c;)r++,t++;for(var i=(e.length-t)*d+1>>>0,s=new Uint8Array(i);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var l=0,h=i-1;(0!==u||l<o)&&-1!==h;h--,l++)u+=a*s[h]>>>0,s[h]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");o=l,t++}if(" "!==e[t]){for(var f=i-o;f!==i&&0===s[f];)f++;for(var p=new Uint8Array(r+(i-f)),y=r;f!==i;)p[y++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,o=0,i=t.length;o!==i&&0===t[o];)o++,n++;for(var s=(i-o)*u+1>>>0,d=new Uint8Array(s);o!==i;){for(var l=t[o],h=0,f=s-1;(0!==l||h<r)&&-1!==f;f--,h++)l+=256*d[f]>>>0,d[f]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");r=h,o++}for(var p=s-r;p!==s&&0===d[p];)p++;for(var y=c.repeat(n);p<s;++p)y+=e.charAt(d[p]);return y},decodeUnsafe:l,decode:function(e){var n=l(e);if(n)return n;throw new Error(`Non-${t} character`)}}}var src=base,_brrp__multiformats_scope_baseX=src;class Encoder{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return or$2(this,e)}}class ComposedDecoder{constructor(e){this.decoders=e}or(e){return or$2(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or$2=(e,t)=>new ComposedDecoder({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class Codec{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new Encoder(e,t,n),this.decoder=new Decoder(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$5=({name:e,prefix:t,encode:n,decode:r})=>new Codec(e,t,n,r),baseX=({prefix:e,name:t,alphabet:n})=>{const{encode:r,decode:o}=_brrp__multiformats_scope_baseX(n,t);return from$5({prefix:e,name:t,encode:r,decode:e=>coerce(o(e))})},decode$2=(e,t,n,r)=>{const o={};for(let e=0;e<t.length;++e)o[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*n/8|0);let a=0,c=0,d=0;for(let t=0;t<i;++t){const i=o[e[t]];if(void 0===i)throw new SyntaxError(`Non-${r} character`);c=c<<n|i,a+=n,a>=8&&(a-=8,s[d++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s},encode$3=(e,t,n)=>{const r="="===t[t.length-1],o=(1<<n)-1;let i="",s=0,a=0;for(let r=0;r<e.length;++r)for(a=a<<8|e[r],s+=8;s>n;)s-=n,i+=t[o&a>>s];if(s&&(i+=t[o&a<<n-s]),r)for(;i.length*n&7;)i+="=";return i},rfc4648=({name:e,prefix:t,bitsPerChar:n,alphabet:r})=>from$5({prefix:t,name:e,encode:e=>encode$3(e,r,n),decode:t=>decode$2(t,r,n,e)}),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const format=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?toStringV0(n,baseCache(e),t||base58btc.encoder):toStringV1(n,baseCache(e),t||base32.encoder)},cache$1=new WeakMap,baseCache=e=>{const t=cache$1.get(e);if(null==t){const t=new Map;return cache$1.set(e,t),t}return t};class CID{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=create$8(e,t);return CID.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return CID.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&equals(e.multihash,n.multihash)}toString(e){return format(this,e)}toJSON(){return{"/":format(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof CID)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:o}=t;return new CID(e,n,r,o||encodeCID(e,n,r.bytes))}if(!0===t[cidSymbol]){const{version:e,multihash:n,code:r}=t,o=decode$3(n);return CID.create(e,r,o)}return null}static create(e,t,n){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(e,t,n,n.bytes);case 1:{const r=encodeCID(e,t,n.bytes);return new CID(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return CID.create(0,DAG_PB_CODE,e)}static createV1(e,t){return CID.create(1,e,t)}static decode(e){const[t,n]=CID.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=CID.inspectBytes(e),n=t.size-t.multihashSize,r=coerce(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=r.subarray(t.multihashSize-t.digestSize),i=new Digest$1(t.multihashCode,t.digestSize,o,r);return[0===t.version?CID.createV0(i):CID.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=decode$4(e.subarray(t));return t+=r,n};let r=n(),o=DAG_PB_CODE;if(18===r?(r=0,t=0):o=n(),0!==r&&1!==r)throw new RangeError(`Invalid CID version ${r}`);const i=t,s=n(),a=n(),c=t+a;return{version:r,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[n,r]=parseCIDtoBytes(e,t),o=CID.decode(r);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return baseCache(o).set(n,e),o}}const parseCIDtoBytes=(e,t)=>{switch(e[0]){case"Q":{const n=t||base58btc;return[base58btc.prefix,n.decode(`${base58btc.prefix}${e}`)]}case base58btc.prefix:{const n=t||base58btc;return[base58btc.prefix,n.decode(e)]}case base32.prefix:{const n=t||base32;return[base32.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},toStringV0=(e,t,n)=>{const{prefix:r}=n;if(r!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const o=t.get(r);if(null==o){const o=n.encode(e).slice(1);return t.set(r,o),o}return o},toStringV1=(e,t,n)=>{const{prefix:r}=n,o=t.get(r);if(null==o){const o=n.encode(e);return t.set(r,o),o}return o},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(e,t,n)=>{const r=encodingLength$1(e),o=r+encodingLength$1(t),i=new Uint8Array(o+n.byteLength);return encodeTo$1(e,i,0),encodeTo$1(t,i,r),i.set(n,o),i},cidSymbol=Symbol.for("@ipld/js-cid/CID");class Node{constructor(e,t,n){this.id=e,this.children=t,this.metadata=n}}const withWidth=e=>({open:()=>open({width:e}),write:write$1,close:close$4}),defaults$3={width:174},open=({width:e}=defaults$3)=>({width:e,head:null,leafIndex:[],nodeIndex:[],lastID:0}),write$1=(e,t)=>{if(0===t.length)return{layout:e,nodes:EMPTY,leaves:EMPTY};{let{lastID:n}=e;const[r,o]=e.head?[null,(t.unshift(e.head),t)]:1===t.length&&0===e.leafIndex.length?[t[0],EMPTY]:[null,t];if(0===o.length)return{layout:{...e,head:r},nodes:EMPTY,leaves:EMPTY};{const t=[...e.leafIndex],i=[];for(const e of o){const r={id:++n,content:e};i.push(r),t.push(r.id)}return t.length>e.width?flush({...e,leafIndex:t,head:r,lastID:n},i):{layout:{...e,head:r,leafIndex:t,lastID:n},leaves:i,nodes:EMPTY}}}},flush=(e,t=EMPTY,n=[],r=!1)=>{let{lastID:o}=e;const i=e.nodeIndex.map((e=>[...e])),s=[...e.leafIndex],{width:a}=e;for(;s.length>a||s.length>0&&r;){grow(i,1);const e=new Node(++o,s.splice(0,a));i[0].push(e.id),n.push(e)}let c=0;for(;c<i.length;){const e=i[c];for(c++;e.length>a||e.length>0&&r&&c<i.length;){const t=new Node(++o,e.splice(0,a));grow(i,c+1),i[c].push(t.id),n.push(t)}}return{layout:{...e,lastID:o,leafIndex:s,nodeIndex:i},leaves:t,nodes:n}},close$4=(e,t)=>{const n=e;if(e.head)return{root:{id:1,content:e.head,metadata:t},leaves:EMPTY,nodes:EMPTY};if(0===e.leafIndex.length)return{root:{id:1,metadata:t},leaves:EMPTY,nodes:EMPTY};{const{nodes:e,layout:r}=flush(n,EMPTY,[],!0),{nodeIndex:o}=r,i=o[o.length-1];if(1===i.length){const t=e[e.length-1];return e.length=e.length-1,{root:t,nodes:e,leaves:EMPTY}}return{root:new Node(r.lastID+1,i,t),nodes:e,leaves:EMPTY}}},grow=(e,t)=>{for(;e.length<t;)e.push([]);return e},EMPTY=[],defaults$2=()=>({chunker:FixedSize,fileChunkEncoder:UnixFSLeaf,smallFileEncoder:UnixFSLeaf,fileEncoder:UnixFS,fileLayout:withWidth(174),hasher:sha256$1,linker:{createLink:CID.createV1}}),configure$4=e=>({...defaults$2(),...e}),UnixFSLeaf={code:code$1,name:name$1,encode:encodeFileChunk},create$7=({writer:e,metadata:t={},settings:n=defaults$2()})=>new FileWriterView(init(e,t,configure$4(n))),write=async(e,t)=>(await perform(e,send({type:"write",bytes:t})),e),close$3=async(e,{releaseLock:t=!1,closeWriter:n=!1}={})=>{await perform(e,send({type:"close"}));const{state:r}=e;if("linked"===r.status)return n?await e.state.writer.close():t&&e.state.writer.releaseLock(),r.link;panic(`Expected writer to be in 'linked' state after close, but it is in "${r.status}" instead`)},perform=(e,t)=>fork$3(loop(t,(t=>{const{state:n,effect:r}=update(t,e.state);return e.state=n,r})));class FileWriterView{constructor(e){this.state=e}get writer(){return this.state.writer}get settings(){return this.state.config}write(e){return write(this,e)}close(e){return close$3(this,e)}}const defaults$1=defaults$2,create$6=({writer:e,settings:t=defaults$1(),metadata:n={}})=>new DirectoryWriter({writer:e,metadata:n,settings:t,entries:new Map,closed:!1}),set$4=(e,t,n,{overwrite:r=!1}={})=>{const o=asWritable$1(e.state);if(t.includes("/"))throw new Error(`Directory entry name "${t}" contains forbidden "/" character`);if(!r&&o.entries.has(t))throw new Error(`Directory already contains entry with name "${t}"`);return o.entries.set(t,n),e},remove$1=(e,t)=>(asWritable$1(e.state).entries.delete(t),e),asWritable$1=e=>{if(e.closed)throw new Error("Can not change written directory, but you can .fork() and make changes to it");return e},close$2=async(e,{closeWriter:t=!1,releaseLock:n=!1}={})=>{const{writer:r,settings:o,metadata:i}=asWritable$1(e.state);e.state.closed=!0;const s=[...links$1(e)],a=createFlatDirectory(s,i),c=encodeDirectory(a),d=await o.hasher.digest(c),u=o.linker.createLink(code$1,d);return(r.desiredSize||0)<=0&&await r.ready,r.write({cid:u,bytes:c}),t?await r.close():n&&r.releaseLock(),{cid:u,dagByteLength:cumulativeDagByteLength(c,s)}},links$1=function*({state:e}){for(const[t,{dagByteLength:n,cid:r}]of e.entries)yield{name:t,dagByteLength:n,cid:r}},fork$2=({state:e},{writer:t=e.writer,metadata:n=e.metadata,settings:r=e.settings}={})=>new DirectoryWriter({writer:t,metadata:n,settings:r,entries:new Map(e.entries.entries()),closed:!1});class DirectoryWriter{constructor(e){this.state=e}get writer(){return this.state.writer}get settings(){return this.state.settings}links(){return links$1(this)}set(e,t,n){return set$4(this,e,t,n)}remove(e){return remove$1(this,e)}fork(e){return fork$2(this,e)}close(e){return close$2(this,e)}entries(){return this.state.entries.entries()}has(e){return this.state.entries.has(e)}get size(){return this.state.entries.size}}var api=Object.freeze({__proto__:null});const empty$1=(e=32)=>{if(32!==e)throw new Error(`Uint32 BitField does not support size: ${e}`);return 0},from$4=(e,t)=>{let n=empty$1(t);for(const t of e)n=set$3(n,t);return n},size$1=e=>32,mask=(e,t)=>e>>>t&31,offset=(e,t)=>1<<mask(e,t),popcount$1=(e,t=31)=>bitCount(e&offset(t,0)-1),set$3=(e,t)=>e|1<<t,unset$1=(e,t)=>e&(255^1<<t),get$5=(e,t)=>!!(e>>t&1),bitCount=e=>{const t=e-(e>>1&1431655765),n=(858993459&t)+(t>>2&858993459);return 16843009*(n+(n>>4)&252645135)>>24},and$1=(e,t)=>e&t,or$1=(e,t)=>e|t,toBytes$1=e=>Uint8Array.of(e>>24&255,e>>16&255,e>>8&255,255&e),fromBytes$2=e=>{if(4!==e.length)throw new Error(`Expected 4 bytes instead got ${e.length}`);return(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3]};var Uint32BitField=Object.freeze({__proto__:null,API:api,and:and$1,bitCount:bitCount,empty:empty$1,from:from$4,fromBytes:fromBytes$2,get:get$5,or:or$1,popcount:popcount$1,set:set$3,size:size$1,toBytes:toBytes$1,unset:unset$1}),murmurHash3js={exports:{}},hasRequiredMurmurHash3js,murmurhash3jsRevisited,hasRequiredMurmurhash3jsRevisited;function requireMurmurHash3js(){return hasRequiredMurmurHash3js||(hasRequiredMurmurHash3js=1,e=murmurHash3js,t=murmurHash3js.exports,function(n,r){var o={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(e){if(!Array.isArray(e)&&!ArrayBuffer.isView(e))return!1;for(var t=0;t<e.length;t++)if(!Number.isInteger(e[t])||e[t]<0||e[t]>255)return!1;return!0}function s(e,t){return(65535&e)*t+(((e>>>16)*t&65535)<<16)}function a(e,t){return e<<t|e>>>32-t}function c(e){return e=s(e^=e>>>16,2246822507),e=s(e^=e>>>13,3266489909),e^=e>>>16}function d(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var n=[0,0,0,0];return n[3]+=e[3]+t[3],n[2]+=n[3]>>>16,n[3]&=65535,n[2]+=e[2]+t[2],n[1]+=n[2]>>>16,n[2]&=65535,n[1]+=e[1]+t[1],n[0]+=n[1]>>>16,n[1]&=65535,n[0]+=e[0]+t[0],n[0]&=65535,[n[0]<<16|n[1],n[2]<<16|n[3]]}function u(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var n=[0,0,0,0];return n[3]+=e[3]*t[3],n[2]+=n[3]>>>16,n[3]&=65535,n[2]+=e[2]*t[3],n[1]+=n[2]>>>16,n[2]&=65535,n[2]+=e[3]*t[2],n[1]+=n[2]>>>16,n[2]&=65535,n[1]+=e[1]*t[3],n[0]+=n[1]>>>16,n[1]&=65535,n[1]+=e[2]*t[2],n[0]+=n[1]>>>16,n[1]&=65535,n[1]+=e[3]*t[1],n[0]+=n[1]>>>16,n[1]&=65535,n[0]+=e[0]*t[3]+e[1]*t[2]+e[2]*t[1]+e[3]*t[0],n[0]&=65535,[n[0]<<16|n[1],n[2]<<16|n[3]]}function l(e,t){return 32==(t%=64)?[e[1],e[0]]:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t|e[0]>>>32-t]:(t-=32,[e[1]<<t|e[0]>>>32-t,e[0]<<t|e[1]>>>32-t])}function h(e,t){return 0==(t%=64)?e:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t]:[e[1]<<t-32,0]}function f(e,t){return[e[0]^t[0],e[1]^t[1]]}function p(e){return e=f(e,[0,e[0]>>>1]),e=f(e=u(e,[4283543511,3981806797]),[0,e[0]>>>1]),e=f(e=u(e,[3301882366,444984403]),[0,e[0]>>>1])}o.x86.hash32=function(e,t){if(o.inputValidation&&!i(e))return r;t=t||0;for(var n=e.length%4,d=e.length-n,u=t,l=0,h=3432918353,f=461845907,p=0;p<d;p+=4)l=s(l=e[p]|e[p+1]<<8|e[p+2]<<16|e[p+3]<<24,h),l=s(l=a(l,15),f),u=s(u=a(u^=l,13),5)+3864292196;switch(l=0,n){case 3:l^=e[p+2]<<16;case 2:l^=e[p+1]<<8;case 1:l=s(l^=e[p],h),u^=l=s(l=a(l,15),f)}return(u=c(u^=e.length))>>>0},o.x86.hash128=function(e,t){if(o.inputValidation&&!i(e))return r;t=t||0;for(var n=e.length%16,d=e.length-n,u=t,l=t,h=t,f=t,p=0,y=0,g=0,b=0,w=597399067,m=2869860233,$=951274213,v=2716044179,E=0;E<d;E+=16)p=e[E]|e[E+1]<<8|e[E+2]<<16|e[E+3]<<24,y=e[E+4]|e[E+5]<<8|e[E+6]<<16|e[E+7]<<24,g=e[E+8]|e[E+9]<<8|e[E+10]<<16|e[E+11]<<24,b=e[E+12]|e[E+13]<<8|e[E+14]<<16|e[E+15]<<24,p=a(p=s(p,w),15),u=a(u^=p=s(p,m),19),u=s(u+=l,5)+1444728091,y=a(y=s(y,m),16),l=a(l^=y=s(y,$),17),l=s(l+=h,5)+197830471,g=a(g=s(g,$),17),h=a(h^=g=s(g,v),15),h=s(h+=f,5)+2530024501,b=a(b=s(b,v),18),f=a(f^=b=s(b,w),13),f=s(f+=u,5)+850148119;switch(p=0,y=0,g=0,b=0,n){case 15:b^=e[E+14]<<16;case 14:b^=e[E+13]<<8;case 13:b=s(b^=e[E+12],v),f^=b=s(b=a(b,18),w);case 12:g^=e[E+11]<<24;case 11:g^=e[E+10]<<16;case 10:g^=e[E+9]<<8;case 9:g=s(g^=e[E+8],$),h^=g=s(g=a(g,17),v);case 8:y^=e[E+7]<<24;case 7:y^=e[E+6]<<16;case 6:y^=e[E+5]<<8;case 5:y=s(y^=e[E+4],m),l^=y=s(y=a(y,16),$);case 4:p^=e[E+3]<<24;case 3:p^=e[E+2]<<16;case 2:p^=e[E+1]<<8;case 1:p=s(p^=e[E],w),u^=p=s(p=a(p,15),m)}return u^=e.length,u+=l^=e.length,u+=h^=e.length,l+=u+=f^=e.length,h+=u,f+=u,u=c(u),u+=l=c(l),u+=h=c(h),l+=u+=f=c(f),h+=u,f+=u,("00000000"+(u>>>0).toString(16)).slice(-8)+("00000000"+(l>>>0).toString(16)).slice(-8)+("00000000"+(h>>>0).toString(16)).slice(-8)+("00000000"+(f>>>0).toString(16)).slice(-8)},o.x64.hash128=function(e,t){if(o.inputValidation&&!i(e))return r;t=t||0;for(var n=e.length%16,s=e.length-n,a=[0,t],c=[0,t],y=[0,0],g=[0,0],b=[2277735313,289559509],w=[1291169091,658871167],m=0;m<s;m+=16)y=[e[m+4]|e[m+5]<<8|e[m+6]<<16|e[m+7]<<24,e[m]|e[m+1]<<8|e[m+2]<<16|e[m+3]<<24],g=[e[m+12]|e[m+13]<<8|e[m+14]<<16|e[m+15]<<24,e[m+8]|e[m+9]<<8|e[m+10]<<16|e[m+11]<<24],y=l(y=u(y,b),31),a=d(a=l(a=f(a,y=u(y,w)),27),c),a=d(u(a,[0,5]),[0,1390208809]),g=l(g=u(g,w),33),c=d(c=l(c=f(c,g=u(g,b)),31),a),c=d(u(c,[0,5]),[0,944331445]);switch(y=[0,0],g=[0,0],n){case 15:g=f(g,h([0,e[m+14]],48));case 14:g=f(g,h([0,e[m+13]],40));case 13:g=f(g,h([0,e[m+12]],32));case 12:g=f(g,h([0,e[m+11]],24));case 11:g=f(g,h([0,e[m+10]],16));case 10:g=f(g,h([0,e[m+9]],8));case 9:g=u(g=f(g,[0,e[m+8]]),w),c=f(c,g=u(g=l(g,33),b));case 8:y=f(y,h([0,e[m+7]],56));case 7:y=f(y,h([0,e[m+6]],48));case 6:y=f(y,h([0,e[m+5]],40));case 5:y=f(y,h([0,e[m+4]],32));case 4:y=f(y,h([0,e[m+3]],24));case 3:y=f(y,h([0,e[m+2]],16));case 2:y=f(y,h([0,e[m+1]],8));case 1:y=u(y=f(y,[0,e[m]]),b),a=f(a,y=u(y=l(y,31),w))}return a=d(a=f(a,[0,e.length]),c=f(c,[0,e.length])),c=d(c,a),a=d(a=p(a),c=p(c)),c=d(c,a),("00000000"+(a[0]>>>0).toString(16)).slice(-8)+("00000000"+(a[1]>>>0).toString(16)).slice(-8)+("00000000"+(c[0]>>>0).toString(16)).slice(-8)+("00000000"+(c[1]>>>0).toString(16)).slice(-8)},e.exports&&(t=e.exports=o),t.murmurHash3=o}()),murmurHash3js.exports;var e,t}function requireMurmurhash3jsRevisited(){return hasRequiredMurmurhash3jsRevisited?murmurhash3jsRevisited:(hasRequiredMurmurhash3jsRevisited=1,murmurhash3jsRevisited=requireMurmurHash3js())}var murmurhash3jsRevisitedExports=requireMurmurhash3jsRevisited(),mur=getDefaultExportFromCjs(murmurhash3jsRevisitedExports);const utf8$2=new TextEncoder,hash32=mur.x64.hash126,configure$3=({bitWidth:e=5,hash:t=hash32})=>{if(e>32)throw new RangeError(`Can not use bitWidth ${e} which exceeds the hashSize 4`);const n=4294967295>>>32-e;return{at:(t,r)=>t>>>r*e&n,from:e=>t(utf8$2.encode(e)),size:Math.ceil(32/e)}};class BitmapIndexedNode{constructor(e,t,n,r,o){this.edit=e,this.config=o,this.datamap=t,this.nodemap=n,this.children=r}get nodeArity(){return this.config.BitField.popcount(this.nodemap)}get dataArity(){return this.config.BitField.popcount(this.datamap)}empty(){return create$5(this.config)}lookup(e,t,n,r){return lookup(this,e,t,n,r)}associate(e,t,n,r,o,i){return associate(this,e,t,n,r,o,i)}dissociate(e,t,n,r,o){return dissociate(this,e,t,n,r,o)}fork(e=null){return fork$1(this,e)}entries(){return entries(this)}keys(){return keys(this)}values(){return values(this)}}class HashCollisionNode{constructor(e,t,n,r){this.edit=e,this.count=t,this.children=n,this.config=r}get nodeArity(){return 0}get dataArity(){return this.count}lookup(e,t,n,r){return lookupCollision(this,n,r)}associate(e,t,n,r,o,i){return associateCollision(this,e,n,r,o,i)}dissociate(e,t,n,r,o){return dissociateCollision(this,e,n,r,o)}fork(e=null){return forkCollision(this,e)}entries(){return entries(this)}keys(){return keys(this)}values(){return values(this)}}const lookupCollision=(e,t,n)=>{const{children:r,count:o}=e,i=findHashCollisionNodeIndex(r,o,t);return r[i]===t?r[i+1]:n},associateCollision=(e,t,n,r,o,i)=>{const{children:s,count:a}=e,c=findHashCollisionNodeIndex(s,a,r);if(s[c]!==r){const r=e.fork(t);return i.value=!0,r.count+=1,r.children.splice(c,n,o),r}if(s[c+1]!==o){const n=e.fork(t);return n.children[c+1]=o,n}return e},dissociateCollision=(e,t,n,r,o)=>{const{children:i,count:s,config:a}=e,c=findHashCollisionNodeIndex(i,s,r);if(i[c]!==r)return e;if(o.value=!0,2===s){const e=0===c?2:0;return associate(create$5(a),t,0,n,i[e],i[e+1],o)}{const n=e.fork(t);return n.children.splice(c,2),n.count-=1,n}},forkCollision=(e,t=null)=>canEdit(e.edit,t)?e:new HashCollisionNode(t,e.count,e.children.slice(),e.config),findHashCollisionNodeIndex=(e,t,n)=>{let r=0;for(;r<t&&e[r]>n;)r+=2;return r},create$5=(e,t=null)=>new BitmapIndexedNode(t,e.BitField.empty(Math.pow(2,e.bitWidth)),e.BitField.empty(Math.pow(2,e.bitWidth)),[],e),get$4=(e,t,n)=>lookup(e,0,e.config.Path.from(t),t,n),lookup=(e,t,n,r,o)=>{const{datamap:i,nodemap:s,config:a}=e,{Path:c,BitField:d}=a,u=c.at(n,t);if(d.get(i,u)){const t=d.popcount(i,u);return keyAt(e,t)===r?valueAt(e,t):o}if(d.get(s,u)){return resolveNode(e,u).lookup(t+1,n,r,o)}return o},set$2=(e,t,n,r,o)=>associate(e,t,0,e.config.Path.from(n),n,r,o),associate=(e,t,n,r,o,i,s)=>{const{datamap:a,nodemap:c,config:d}=e,{Path:u,BitField:l}=d,h=u.at(r,n);if(l.get(a,h)){const c=l.popcount(a,h),f=keyAt(e,c);if(o===f)return valueAt(e,c)===i?e:forkAndSet(e,t,c,i);{const a=mergeTwoLeaves(d,t,n+1,u.from(f),f,valueAt(e,c),r,o,i);return s.value=!0,migrateLeafToBranch(e,t,h,a)}}if(l.get(c,h)){const a=resolveNode(e,h),c=a.associate(t,n+1,r,o,i,s);return a===c?e:copyAndSetChild(e,t,h,c)}{const n=l.popcount(a,h);s.value=!0;const r=e.fork(t);return r.datamap=l.set(a,h),r.children.splice(keyPosition(n),0,o,i),r}},remove=(e,t,n,r)=>dissociate(e,t,0,e.config.Path.from(n),n,r),dissociate=(e,t,n,r,o,i)=>{const{datamap:s,nodemap:a,config:c}=e,{BitField:d,Path:u}=c,l=u.at(r,n);if(d.get(s,l)){const n=d.popcount(s,l);if(o===keyAt(e,n)){i.value=!0;const r=fork$1(e,t);return r.datamap=d.unset(e.datamap,l),r.children.splice(keyPosition(n),2),r}return e}if(d.get(a,l)){const s=resolveNode(e,l),a=s.dissociate(t,n+1,r,o,i);return hasSingleLeaf(a)?hasSingleNode(e)?a:inlineChild(e,t,l,a):s===a?e:copyAndSetChild(e,t,l,a)}return e},entries=function*({children:e}){let t=0;const n=e.length;for(;t<n;){const n=e[t];if("string"!=typeof n)break;{t+=1;const r=e[t];yield[n,r],t+=1}}for(;t<n;){const n=e[t];yield*n.entries(),t+=1}},fork$1=(e,t)=>{if(canEdit(e.edit,t))return e;return new BitmapIndexedNode(t,e.datamap,e.nodemap,e.children.slice(),e.config)},keys=function*({children:e}){let t=0;const n=e.length;for(;t<n;){const n=e[t];if("string"!=typeof n)break;yield n,t+=2}for(;t<n;){const n=e[t];yield*n.keys(),t+=1}},values=function*({children:e}){let t=0;const n=e.length;for(;t<n;){if("string"!=typeof e[t])break;t+=1,yield e[t],t+=1}for(;t<n;){const n=e[t];yield*n.values(),t+=1}},forkAndSet=(e,t,n,r)=>{const o=e.fork(t);return o.children[valuePosition(n)]=r,o},inlineChild=(e,t,n,r)=>{const{datamap:o,nodemap:i,config:s}=e,{BitField:a}=s,c=fork$1(e,t);return c.children.splice(nodePosition(e,n),1),c.children.splice(keyPosition(a.popcount(o,n)),0,r.children[0],r.children[1]),c.datamap=a.set(o,n),c.nodemap=a.unset(i,n),c},copyAndSetChild=(e,t,n,r)=>{const o=fork$1(e,t);return o.children[nodePosition(e,n)]=r,o},migrateLeafToBranch=(e,t,n,r)=>{const{nodemap:o,datamap:i,config:s}=e,{BitField:a}=s,c=a.popcount(i,n),d=keyPosition(c),u=nodePosition(e,n),l=fork$1(e,t);return l.datamap=a.unset(i,n),l.children.splice(d,2),l.nodemap=a.set(o,n),l.children.splice(u-1,0,r),l},mergeTwoLeaves=(e,t,n,r,o,i,s,a,c)=>{const{BitField:d,Path:u}=e;if(u.size<n)return new HashCollisionNode(t,2,[o,i,a,c],e);{const l=u.at(r,n),h=u.at(s,n);return l===h?new BitmapIndexedNode(t,d.empty(Math.pow(2,e.bitWidth)),d.from([l],Math.pow(2,e.bitWidth)),[mergeTwoLeaves(e,t,n+1,r,o,i,s,a,c)],e):new BitmapIndexedNode(t,d.from([l,h],Math.pow(2,e.bitWidth)),d.empty(Math.pow(2,e.bitWidth)),l<h?[o,i,a,c]:[a,c,o,i],e)}},keyAt=({children:e},t)=>e[keyPosition(t)],keyPosition=e=>2*e,valueAt=({children:e},t)=>e[valuePosition(t)],valuePosition=e=>2*e+1,resolveNode=(e,t)=>e.children[nodePosition(e,t)],nodePosition=({children:e,nodemap:t,config:n},r)=>e.length-1-n.BitField.popcount(t,r),canEdit=(e,t)=>null!=e&&e===t,hasSingleLeaf=e=>0===e.nodeArity&&1===e.dataArity,hasSingleNode=({config:{BitField:e},datamap:t,nodemap:n})=>0===e.popcount(t)&&1===e.popcount(n),murmur364=from$f({name:"murmur3-x64-64",code:34,encode:e=>fromHex(mur.x64.hash128(e)).subarray(0,8)}),utf8$1=new TextEncoder,hash64$1=e=>murmur364.encode(e),configure$2=({bitWidth:e=8,hash:t=hash64$1}={})=>{const n=t(new Uint8Array).byteLength;return{from:e=>t(utf8$1.encode(e)),at:(t,r)=>{const o=r*e;if(o>n)throw new RangeError("Out of bounds");return toInt(t,o,e)},size:Math.ceil(8*n/e)}},toInt=(e,t,n)=>{let r=t/8|0,o=t%8,i=n,s=0;for(;i>0&&r<e.byteLength;){const t=8-o,n=t<i?t:i;s=(s<<n)+((255>>o&e[r])>>8-o-n),i-=n,r++,o=0}return s},empty=(e=256)=>{if(e%8!=0)throw new Error("Must be multiple of 8");return new Uint8Array(e/8)},from$3=(e,t)=>{let n=empty(t);for(const t of e){const{byte:e,byteOffset:r,bitOffset:o}=at(n,t);n[r]=e|1<<o}return n},size=e=>8*e.byteLength,at=(e,t)=>{const n=e.byteLength-1-(t/8|0),r=t%8;return{byte:e[n],byteOffset:n,bitOffset:r}},setByte=(e,t,n)=>{if(e[t]!==n){const r=e.slice(0);return r[t]=n,r}return e},set$1=(e,t)=>{const{byte:n,byteOffset:r,bitOffset:o}=at(e,t);return setByte(e,r,n|1<<o)},unset=(e,t)=>{const{byte:n,byteOffset:r,bitOffset:o}=at(e,t);return setByte(e,r,n&(255^1<<o))},get$3=(e,t)=>{var{byte:n,bitOffset:r}=at(e,t);return!!(n>>r&1)},toBytes=e=>e,fromBytes$1=e=>e,popcount=(e,t=8*e.byteLength)=>{const{byteOffset:n,bitOffset:r,byte:o}=at(e,t);let i=popcount$1(o,r),s=e.byteLength-1;for(;s>n;){const t=e[s];i+=bitCount(t),s--}return i},or=(e,t)=>{const n=e.slice();let r=0;for(;r<e.length;)n[r]|=t[r],r++;return n},and=(e,t)=>{const n=e.slice();let r=0;for(;r<e.length;)n[r]&=t[r],r++;return n};var Uint8ArrayBitField=Object.freeze({__proto__:null,API:api,and:and,empty:empty,from:from$3,fromBytes:fromBytes$1,get:get$3,or:or,popcount:popcount,set:set$1,size:size,toBytes:toBytes,unset:unset});const NOT_FOUND=new RangeError("Not Found"),configure$1=({bitWidth:e=5,BitField:t=(5===e?Uint32BitField:Uint8ArrayBitField),Path:n=(5===e?configure$3({bitWidth:e}):configure$2({bitWidth:e}))}={})=>({bitWidth:e,BitField:t,Path:n}),from$2=(e,t)=>{const n=builder$1(t);for(const[t,r]of e)n.set(t,r);return n.build()},has=(e,t)=>get$4(e.root,t,NOT_FOUND)!==NOT_FOUND,get$2=(e,t,n=void 0)=>get$4(e.root,t,n),builder$1=e=>{const t={},n=configure$1(e);return new HashMapBuilder(t,0,create$5(n,t),n)};class PersistentHashMap{constructor(e=0,t,n){this.count=e,this.root=t,this.config=n}get size(){return this.count}clone(){return new PersistentHashMap(this.count,this.root,this.config)}empty(){return new PersistentHashMap(0,create$5(this.config,null),this.config)}has(e){return has(this,e)}get(e){return get$4(this.root,e,void 0)}set(e,t){const n={value:!1},r=set$2(this.root,null,e,t,n);return r===this.root?this:new PersistentHashMap(n.value?this.count+1:this.count,r,this.config)}delete(e){const t=remove(this.root,null,e,{value:!1});return t===this.root?this:new PersistentHashMap(this.count-1,t,this.config)}get bitField(){return this.config.BitField.or(this.root.datamap,this.root.nodemap)}[Symbol.iterator](){return this.entries()}entries(){return this.root.entries()}keys(){return this.root.keys()}values(){return this.root.values()}createBuilder(){return new HashMapBuilder({},this.count,this.root,this.config)}}class HashMapBuilder{constructor(e,t,n,r){this.edit=e,this.count=t,this.root=n,this.config=r}get size(){if(this.edit)return this.count;throw new Error(".size was accessed on the finalized builder")}set(e,t){if(this.edit){const n={value:!1},r=set$2(this.root,this.edit,e,t,n);return this.root!==r&&(this.root=r),n.value&&(this.count+=1),this}throw new Error(".set was called on the finalized builder")}delete(e){if(this.edit){if(0===this.count)return this;const t={value:!1},n=remove(this.root,this.edit,e,t);return n!==this.root&&(this.root=n),t.value&&(this.count-=1),this}throw new Error(".delete was called on the finalized builder")}build(){if(this.edit)return this.edit=null,new PersistentHashMap(this.count,this.root,this.config);throw new Error(".build was called on the finalized builder")}}const utf8=new TextEncoder,hash64=e=>murmur364.encode(e),configure=({bitWidth:e=8,hash:t=hash64})=>{const n=t(new Uint8Array).byteLength,r={bitWidth:e,hash:t,hashSize:n};return{at:(e,t)=>read$1(e,t,r),from:e=>utf8.encode(e),size:1/0}},read$1=(e,t=0,{bitWidth:n=8,hash:r,hashSize:o})=>{const i=8*o;let s=0,a=n,c=n*t;for(;a>0;){const t=c/i|0,n=r(0===t?e:appendByte(e,t)),o=i<=c?c%i:c,d=i-o,u=d<a?d:a;s=(s<<u)+toInt(n,o,u),a-=u,c+=u}return s},appendByte=(e,t)=>{const n=new Uint8Array(e.byteLength+1).fill(t,e.byteLength);return n.set(e),n},bitWidth=8,config={bitWidth:bitWidth,Path:configure({bitWidth:bitWidth})},tableSize=e=>Math.pow(2,e.config.bitWidth),builder=(e=config)=>builder$1(e),from$1=(e,t=config)=>from$2(e,t),bitField=({datamap:e,nodemap:t,config:{BitField:n}})=>withoutLeadingZeros(n.toBytes(n.or(e,t))),withoutLeadingZeros=e=>{let t=0;for(;t<e.byteLength;){if(0!==e[t])return e.subarray(t);t+=1}return e.subarray(t)},iterate=function*(e){const{config:t,datamap:n,nodemap:r}=e,{BitField:o}=t,i=o.size(n);let s=0,a=0;for(;s<i;){const t=s.toString(16).toUpperCase().padStart(2,"0");if(o.get(n,s)){const n=keyAt(e,a);yield{prefix:t,key:n,value:valueAt(e,a)},a++}else o.get(r,s)&&(yield{prefix:t,node:resolveNode(e,s)});s++}};function readonly({enumerable:e=!0,configurable:t=!1}={}){return{enumerable:e,configurable:t,writable:!1}}function*linksWithin(e,t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))for(const[n,r]of t.entries()){const t=[...e,n],o=CID.asCID(r);o?yield[t.join("/"),o]:"object"==typeof r&&(yield*links(r,t))}else{const n=CID.asCID(t);n?yield[e.join("/"),n]:yield*links(t,e)}}function*links(e,t){if(null==e||e instanceof Uint8Array)return;const n=CID.asCID(e);n&&(yield[t.join("/"),n]);for(const[n,r]of Object.entries(e)){const e=[...t,n];yield*linksWithin(e,r)}}function*treeWithin(e,t){if(Array.isArray(t))for(const[n,r]of t.entries()){const t=[...e,n];yield t.join("/"),"object"!=typeof r||CID.asCID(r)||(yield*tree(r,t))}else yield*tree(t,e)}function*tree(e,t){if(null!=e&&"object"==typeof e)for(const[n,r]of Object.entries(e)){const e=[...t,n];yield e.join("/"),null==r||r instanceof Uint8Array||"object"!=typeof r||CID.asCID(r)||(yield*treeWithin(e,r))}}function get$1(e,t){let n=e;for(const[e,r]of t.entries()){if(n=n[r],null==n)throw new Error(`Object has no property at ${t.slice(0,e+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const o=CID.asCID(n);if(o)return{value:o,remaining:t.slice(e+1).join("/")}}return{value:n}}class Block{constructor({cid:e,bytes:t,value:n}){if(!e||!t||void 0===n)throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:readonly(),bytes:readonly(),value:readonly(),asBlock:readonly()})}links(){return links(this.value,[])}tree(){return tree(this.value,[])}get(e="/"){return get$1(this.value,e.split("/").filter(Boolean))}}const defaults=defaults$2,create$4=({writer:e,settings:t=defaults(),metadata:n={}})=>new HAMTDirectoryWriter({writer:e,metadata:n,settings:t,entries:new HashMap,closed:!1}),asWritable=e=>{if(e.closed)throw new Error("Can not change written HAMT directory, but you can .fork() and make changes to it");return e},close$1=async(e,{closeWriter:t=!1,releaseLock:n=!1}={})=>{const{writer:r,settings:o,metadata:i}=asWritable(e.state);e.state.closed=!0;const{entries:s}=e.state;if(!(s instanceof HashMap))throw new Error(`not a HAMT: ${s}`);const a=s.builder.build(),c=iterateBlocks(a,a.root,o);let d=null;for await(const e of c)d=e,(r.desiredSize||0)<=0&&await r.ready,r.write(e);if(null==d)throw new Error("no root block yielded");return t?await r.close():n&&r.releaseLock(),{cid:d.cid,dagByteLength:cumulativeDagByteLength(d.bytes,d.value.entries)}},iterateBlocks=async function*(e,t,n){const r=[];for(const o of iterate(t))if("key"in o)r.push({name:`${o.prefix??""}${o.key??""}`,dagByteLength:o.value.dagByteLength,cid:o.value.cid});else{let t=null;for await(const r of iterateBlocks(e,o.node,n))yield r,t=r;if(null==t)throw new Error("no root block yielded");r.push({name:o.prefix,dagByteLength:cumulativeDagByteLength(t.bytes,t.value.entries),cid:t.cid})}const o=createDirectoryShard(r,bitField(t),tableSize(e),murmur364.code);yield await encodeHAMTShardBlock(o,n)};async function encodeHAMTShardBlock(e,t){const n=encodeHAMTShard(e),r=await t.hasher.digest(n),o=t.linker.createLink(code$2,r);return new Block({cid:o,bytes:n,value:e})}const fork=({state:e},{writer:t=e.writer,metadata:n=e.metadata,settings:r=e.settings}={})=>new HAMTDirectoryWriter({writer:t,metadata:n,settings:r,entries:new HashMap(from$1(e.entries.entries()).createBuilder()),closed:!1});class HAMTDirectoryWriter{constructor(e){this.state=e}get writer(){return this.state.writer}get settings(){return this.state.settings}set(e,t,n){return set$4(this,e,t,n)}remove(e){return remove$1(this,e)}fork(e){return fork(this,e)}close(e){return close$1(this,e)}entries(){return this.state.entries.entries()}has(e){return this.state.entries.has(e)}get size(){return this.state.entries.size}}class HashMap extends Map{constructor(e=builder()){super(),this.builder=e}clear(){this.builder=builder()}delete(e){const{root:t}=this.builder;return this.builder.delete(e),this.builder.root!==t}forEach(e,t=this){for(const[n,r]of this.builder.root.entries())e.call(t,r,n,this)}get(e){return get$2(this.builder,e)}has(e){return has(this.builder,e)}set(e,t){return this.builder.set(e,t),this}get size(){return this.builder.size}[Symbol.iterator](){return this.builder.root.entries()}entries(){return this.builder.root.entries()}keys(){return this.builder.root.keys()}values(){return this.builder.root.values()}}const createWriter=({writable:e,settings:t=defaults$2()})=>new FileSystemWriter({writer:e.getWriter(),settings:t}),close=async(e,{releaseLock:t=!0,closeWriter:n=!0}={})=>(n?await e.writer.close():t&&e.writer.releaseLock(),e);class FileSystemWriter{constructor({writer:e,settings:t}){this.writer=e,this.settings=configure$4(t)}createFileWriter({settings:e=this.settings,metadata:t}={}){return create$7({writer:this.writer,settings:e,metadata:t})}createDirectoryWriter({settings:e=this.settings,metadata:t}={}){return create$6({writer:this.writer,settings:e,metadata:t})}close(e){return close(this,e)}}const BLOCK_SIZE_LIMIT=1048576,defaultCapacity=100*BLOCK_SIZE_LIMIT,withCapacity=(e=defaultCapacity)=>({highWaterMark:e,size:e=>e.bytes.length}),SHARD_THRESHOLD=1e3,queuingStrategy=withCapacity(),defaultSettings=configure$4({fileChunkEncoder:raw,smallFileEncoder:raw,chunker:withMaxChunkSize(1048576),fileLayout:withWidth(1024)});function createFileEncoderStream(e,t){const{readable:n,writable:r}=new TransformStream({},queuingStrategy),o=createWriter({writable:r,settings:t?.settings??defaultSettings}),i=new UnixFSFileBuilder("",e);return(async()=>{await i.finalize(o),await o.close()})(),n}class UnixFSFileBuilder{#d;constructor(e,t){this.name=e,this.#d=t}async finalize(e){const t=create$7(e);return await this.#d.stream().pipeTo(new WritableStream({async write(e){await t.write(e)}})),await t.close()}}class UnixFSDirectoryBuilder{#u;entries=new Map;constructor(e,t){this.name=e,this.#u=t}async finalize(e){const t=this.entries.size<=SHARD_THRESHOLD?create$6(e):create$4(e);for(const[n,r]of this.entries){const o=await r.finalize(e);this.#u?.onDirectoryEntryLink&&this.#u.onDirectoryEntryLink({name:r.name,...o}),t.set(n,o)}return await t.close()}}function createDirectoryEncoderStream(e,t){const n=new UnixFSDirectoryBuilder("",t);for(const r of e){const e=r.name.split("/");""!==e[0]&&"."!==e[0]||e.shift();let o=n;for(const[i,s]of e.entries()){if(i===e.length-1){o.entries.set(s,new UnixFSFileBuilder(e.join("/"),r));break}let a=o.entries.get(s);if(null==a){const e=o===n?s:`${o.name}/${s}`;a=new UnixFSDirectoryBuilder(e,t),o.entries.set(s,a)}if(!(a instanceof UnixFSDirectoryBuilder))throw new Error(`"${r.name}" cannot be a file and a directory`);o=a}}const{readable:r,writable:o}=new TransformStream({},queuingStrategy),i=createWriter({writable:o,settings:t?.settings??defaultSettings});return(async()=>{const e=await n.finalize(i);t?.onDirectoryEntryLink&&t.onDirectoryEntryLink({name:"",...e}),await i.close()})(),r}async function readHeader(e,t){const n=decodeVarint$1(await e.upTo(8),e);if(0===n)throw new Error("Invalid CAR header (zero length)");const r=await e.exactly(n,!0),o=decode$y(r);if(void 0===CarV1HeaderOrV2Pragma.toTyped(o))throw new Error("Invalid CAR header format");if(1!==o.version&&2!==o.version||void 0!==t&&o.version!==t)throw new Error(`Invalid CAR version: ${o.version}${void 0!==t?` (expected ${t})`:""}`);if(1===o.version){if(!Array.isArray(o.roots))throw new Error("Invalid CAR header format");return o}if(void 0!==o.roots)throw new Error("Invalid CAR header format");const i=decodeV2Header(await e.exactly(V2_HEADER_LENGTH,!0));e.seek(i.dataOffset-e.pos);const s=await readHeader(e,1);return Object.assign(s,i)}async function readCid(e){const t=await e.exactly(2,!1);if(t[0]===CIDV0_BYTES$1.SHA2_256&&t[1]===CIDV0_BYTES$1.LENGTH){const t=decode$z(await e.exactly(34,!0));return CID$2.create(0,CIDV0_BYTES$1.DAG_PB,t)}const n=decodeVarint$1(await e.upTo(8),e);if(1!==n)throw new Error(`Unexpected CID version (${n})`);const r=decodeVarint$1(await e.upTo(8),e),o=decode$z(await e.exactly(getMultihashLength$1(await e.upTo(8)),!0));return CID$2.create(n,r,o)}async function readBlockHead(e){const t=e.pos;let n=decodeVarint$1(await e.upTo(8),e);if(0===n)throw new Error("Invalid CAR section (zero length)");n+=e.pos-t;return{cid:await readCid(e),length:n,blockLength:n-Number(e.pos-t)}}async function readBlock(e){const{cid:t,blockLength:n}=await readBlockHead(e);return{bytes:await e.exactly(n,!0),cid:t}}async function readBlockIndex(e){const t=e.pos,{cid:n,length:r,blockLength:o}=await readBlockHead(e),i={cid:n,length:r,blockLength:o,offset:t,blockOffset:e.pos};return e.seek(i.blockLength),i}function createDecoder(e){const t=(async()=>{const t=await readHeader(e);if(2===t.version){const n=e.pos-t.dataOffset;e=limitReader(e,t.dataSize-n)}return t})();return{header:()=>t,async*blocks(){for(await t;(await e.upTo(8)).length>0;)yield await readBlock(e)},async*blocksIndex(){for(await t;(await e.upTo(8)).length>0;)yield await readBlockIndex(e)}}}function bytesReader(e){let t=0;return{upTo:async n=>e.subarray(t,t+Math.min(n,e.length-t)),async exactly(n,r=!1){if(n>e.length-t)throw new Error("Unexpected end of data");const o=e.subarray(t,t+n);return r&&(t+=n),o},seek(e){t+=e},get pos(){return t}}}function chunkReader(e){let t=0,n=0,r=0,o=new Uint8Array(0);const i=async t=>{n=o.length-r;const i=[o.subarray(r)];for(;n<t;){const t=await e();if(null==t)break;n<0?t.length>n&&i.push(t.subarray(-n)):i.push(t),n+=t.length}o=new Uint8Array(i.reduce(((e,t)=>e+t.length),0));let s=0;for(const e of i)o.set(e,s),s+=e.length;r=0};return{upTo:async e=>(o.length-r<e&&await i(e),o.subarray(r,r+Math.min(o.length-r,e))),async exactly(e,n=!1){if(o.length-r<e&&await i(e),o.length-r<e)throw new Error("Unexpected end of data");const s=o.subarray(r,r+e);return n&&(t+=e,r+=e),s},seek(e){t+=e,r+=e},get pos(){return t}}}function asyncIterableReader(e){const t=e[Symbol.asyncIterator]();return chunkReader((async function(){const e=await t.next();return e.done?null:e.value}))}function limitReader(e,t){let n=0;return{async upTo(r){let o=await e.upTo(r);return o.length+n>t&&(o=o.subarray(0,t-n)),o},async exactly(r,o=!1){const i=await e.exactly(r,o);if(i.length+n>t)throw new Error("Unexpected end of data");return o&&(n+=r),i},seek(t){n+=t,e.seek(t)},get pos(){return e.pos}}}class CarIteratorBase{constructor(e,t,n){this._version=e,this._roots=t,this._iterable=n,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class CarBlockIterator extends CarIteratorBase{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(e){const{version:t,roots:n,iterator:r}=await fromBytes(e);return new CarBlockIterator(t,n,r)}static async fromIterable(e){const{version:t,roots:n,iterator:r}=await fromIterable(e);return new CarBlockIterator(t,n,r)}}async function fromBytes(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return decodeIterator(bytesReader(e))}async function fromIterable(e){if(!e||"function"!=typeof e[Symbol.asyncIterator])throw new TypeError("fromIterable() requires an async iterable");return decodeIterator(asyncIterableReader(e))}async function decodeIterator(e){const t=createDecoder(e),{version:n,roots:r}=await t.header();return{version:n,roots:r,iterator:t.blocks()}}const CAR_V1_VERSION=1;function createHeader(e){const t=encode$q({version:CAR_V1_VERSION,roots:e}),n=varint$3.encode(t.length),r=new Uint8Array(n.length+t.length);return r.set(n,0),r.set(t,n.length),r}function createEncoder(e){return{async setRoots(t){const n=createHeader(t);await e.write(n)},async writeBlock(t){const{cid:n,bytes:r}=t;await e.write(new Uint8Array(varint$3.encode(n.bytes.length+r.length))),await e.write(n.bytes),r.length&&await e.write(r)},async close(){await e.end()},version:()=>CAR_V1_VERSION}}function noop(){}function create$3(){const e=[];let t=null,n=noop,r=!1,o=null,i=noop;const s=()=>(t||(t=new Promise((e=>{n=()=>{t=null,n=noop,e()}}))),t),a={write(t){e.push(t);const n=s();return i(),n},async end(){r=!0;const e=s();i(),await e}},c={async next(){const t=e.shift();return t?(0===e.length&&n(),{done:!1,value:t}):r?(n(),{done:!0,value:void 0}):(o||(o=new Promise((e=>{i=()=>(o=null,i=noop,e(c.next()))}))),o)}};return{writer:a,iterator:c}}class CarWriter{constructor(e,t){this._encoder=t,this._mutex=t.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array&&e.cid))throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const t=CID$2.asCID(e.cid);if(!t)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then((()=>this._encoder.writeBlock({cid:t,bytes:e.bytes}))),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}version(){return this._encoder.version()}static create(e){e=toRoots(e);const{encoder:t,iterator:n}=encodeWriter();return{writer:new CarWriter(e,t),out:new CarWriterOut(n)}}static createAppender(){const{encoder:e,iterator:t}=encodeWriter();e.setRoots=()=>Promise.resolve();return{writer:new CarWriter([],e),out:new CarWriterOut(t)}}static async updateRootsInBytes(e,t){const n=bytesReader(e);await readHeader(n);const r=createHeader(t);if(Number(n.pos)!==r.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${n.pos} bytes, new header is ${r.length} bytes)`);return e.set(r,0),e}}class CarWriterOut{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function encodeWriter(){const e=create$3(),{writer:t,iterator:n}=e;return{encoder:createEncoder(t),iterator:n}}function toRoots(e){if(void 0===e)return[];if(!Array.isArray(e)){const t=CID$2.asCID(e);if(!t)throw new TypeError("roots must be a single CID or an array of CIDs");return[t]}const t=[];for(const n of e){const e=CID$2.asCID(n);if(!e)throw new TypeError("roots must be a single CID or an array of CIDs");t.push(e)}return t}const code=514,NO_ROOTS_HEADER_LENGTH=18;function headerEncodingLength(e){if(!e)return NO_ROOTS_HEADER_LENGTH;const t=encode$q({version:1,roots:[e]}).length;return varint$3.encodingLength(t)+t}function blockHeaderEncodingLength(e){const t=e.cid.bytes.length+e.bytes.length;return varint$3.encodingLength(t)+e.cid.bytes.length}function blockEncodingLength(e){return blockHeaderEncodingLength(e)+e.bytes.length}async function encode$2(e,t){const{writer:n,out:r}=CarWriter.create(t);let o;(async()=>{try{for await(const t of e)await n.put(t)}catch(e){o=e}finally{await n.close()}})();const i=[];for await(const e of r)i.push(e);if(null!=o)throw o;const s=null!=t?[t]:[];return Object.assign(new Blob(i),{version:1,roots:s})}class BlockStream extends ReadableStream{constructor(e){let t=null;const n=()=>t||(t=CarBlockIterator.fromIterable(toIterable(e.stream())),t);let r=null;super({async start(){const e=await n();r=e[Symbol.asyncIterator]()},async pull(e){if(!r)throw new Error("missing blocks iterator");const{value:t,done:n}=await r.next();if(n)return e.close();e.enqueue(t)}}),this.getRoots=async()=>{const e=await n();return await e.getRoots()}}}function toIterable(e){return Symbol.asyncIterator in e?e:async function*(){const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)return;yield n}}finally{t.releaseLock()}}()}const cache=new WeakMap,toBase58String=e=>{let t=cache.get(e.bytes);return t||(t=base58btc$2.encode(e.bytes),cache.set(e.bytes,t)),t};class DigestMap{#t;constructor(e){this.#t=new Map;for(const[t,n]of e??[])this.set(t,n)}get[Symbol.toStringTag](){return"DigestMap"}clear(){this.#t.clear()}delete(e){const t=toBase58String(e);return this.#t.delete(t)}forEach(e,t){for(const[n,r]of this.#t.values())e.call(t,r,n,this)}get(e){const t=this.#t.get(toBase58String(e));if(t)return t[1]}has(e){return this.#t.has(toBase58String(e))}set(e,t){return this.#t.set(toBase58String(e),[e,t]),this}get size(){return this.#t.size}[Symbol.iterator](){return this.entries()}*entries(){yield*this.#t.values()}*keys(){for(const[e]of this.#t.values())yield e}*values(){for(const[,e]of this.#t.values())yield e}}const version="index/sharded/dag@0.1";variant({[version]:struct({content:match$2(),shards:array(match$2())})});class ShardedDAGIndex{#l;#h;constructor(e){this.#l=e,this.#h=new DigestMap}get content(){return this.#l}get shards(){return this.#h}setSlice(e,t,n){let r=this.#h.get(e);r||(r=new DigestMap,this.#h.set(e,r)),r.set(t,n)}archive(){return archive$1(this)}}const create$2=e=>new ShardedDAGIndex(e),archive$1=async e=>{const t=new Map,n=[...e.shards.entries()].sort(((e,t)=>compare(e[0].digest,t[0].digest))),r={content:e.content,shards:[]};for(const e of n){const n=[...e[1].entries()].sort(((e,t)=>compare(e[0].digest,t[0].digest))).map((e=>[e[0].bytes,e[1]])),o=encode$q([e[0].bytes,n]),i=await sha256$4.digest(o),s=create$g(code$g,i);t.set(s.toString(),{cid:s,bytes:o}),r.shards.push(s)}const o=encode$q({[version]:r}),i=await sha256$4.digest(o),s=create$g(code$g,i);return ok(encode$h({roots:[{cid:s,bytes:o}],blocks:t}))},symbol=Symbol.for("@achingbrain/uint8arraylist");function findBufAndOffset(e,t){if(null==t||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const e=n+r.byteLength;if(t<e)return{buf:r,index:t-n};n=e}throw new RangeError("index is out of bounds")}function isUint8ArrayList(e){return Boolean(e?.[symbol])}class Uint8ArrayList{bufs;length;[symbol]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else{if(!isUint8ArrayList(n))throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");t+=n.byteLength,this.bufs.push(...n.bufs)}this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else{if(!isUint8ArrayList(n))throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");t+=n.byteLength,this.bufs.unshift(...n.bufs)}this.length+=t}get(e){const t=findBufAndOffset(this.bufs,e);return t.buf[t.index]}set(e,t){const n=findBufAndOffset(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else{if(!isUint8ArrayList(e))throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");for(let n=0;n<e.length;n++)this.set(t+n,e.get(n))}}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength)return this.bufs=[],void(this.length=0);for(;this.bufs.length>0;){if(!(e>=this.bufs[0].byteLength)){this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift()}}}slice(e,t){const{bufs:n,length:r}=this._subList(e,t);return concat(n,r)}subarray(e,t){const{bufs:n,length:r}=this._subList(e,t);return 1===n.length?n[0]:concat(n,r)}sublist(e,t){const{bufs:n,length:r}=this._subList(e,t),o=new Uint8ArrayList;return o.length=r,o.bufs=[...n],o}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(0===e&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let r=0;for(let o=0;o<this.bufs.length;o++){const i=this.bufs[o],s=r,a=s+i.byteLength;if(r=a,e>=a)continue;const c=e>=s&&e<a,d=t>s&&t<=a;if(c&&d){if(e===s&&t===a){n.push(i);break}const r=e-s;n.push(i.subarray(r,r+(t-e)));break}if(c){if(0===e){n.push(i);continue}n.push(i.subarray(e-s))}else{if(d){if(t===a){n.push(i);break}n.push(i.subarray(0,t-s));break}n.push(i)}}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!(isUint8ArrayList(e)||e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const r=n.byteLength;if(0===r)throw new TypeError("search must be at least 1 byte long");const o=new Int32Array(256);for(let e=0;e<256;e++)o[e]=-1;for(let e=0;e<r;e++)o[n[e]]=e;const i=o,s=this.byteLength-n.byteLength,a=n.byteLength-1;let c;for(let e=t;e<=s;e+=c){c=0;for(let t=a;t>=0;t--){const r=this.get(e+t);if(n[t]!==r){c=Math.max(1,t-i[r]);break}}if(0===c)return e}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=allocUnsafe(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const r=alloc(2);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt16(0,t,n),this.write(r,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const r=alloc(4);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt32(0,t,n),this.write(r,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const r=alloc(8);new DataView(r.buffer,r.byteOffset,r.byteLength).setBigInt64(0,t,n),this.write(r,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=allocUnsafe(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const r=alloc(2);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint16(0,t,n),this.write(r,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const r=alloc(4);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint32(0,t,n),this.write(r,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const r=alloc(8);new DataView(r.buffer,r.byteOffset,r.byteLength).setBigUint64(0,t,n),this.write(r,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const r=alloc(4);new DataView(r.buffer,r.byteOffset,r.byteLength).setFloat32(0,t,n),this.write(r,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const r=alloc(8);new DataView(r.buffer,r.byteOffset,r.byteLength).setFloat64(0,t,n),this.write(r,e)}equals(e){if(null==e)return!1;if(!(e instanceof Uint8ArrayList))return!1;if(e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!equals$4(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new Uint8ArrayList;return n.bufs=e,null==t&&(t=e.reduce(((e,t)=>e+t.byteLength),0)),n.length=t,n}}const MSB$2=128,REST=127,MSBALL$1=-128,INT$1=Math.pow(2,31),encode$1=e=>{const t=[];let n=0;for(;e>=INT$1;)t[n++]=255&e|MSB$2,e/=128;for(;e&MSBALL$1;)t[n++]=255&e|MSB$2,e>>>=7;return t[n]=0|e,t},decode$1=(e,t)=>{let n,r=0,o=0,i=t=t||0;const s=e.length;do{if(i>=s||o>49)throw new RangeError("Could not decode varint");n=e.get(i++),r+=o<28?(n&REST)<<o:(n&REST)*Math.pow(2,o),o+=7}while(n>=MSB$2);return[r,i-t]},State={ReadHeaderLength:0,ReadHeader:1,ReadBlockLength:2,ReadBlock:3},CIDV0_BYTES={SHA2_256:18,LENGTH:32};class CARReaderStream extends TransformStream{#f;constructor(e,t){const n=new Uint8ArrayList;let r,o=0,i=o,s=8,a=State.ReadHeaderLength;const c=new Promise((e=>{r=e}));super({transform(e,t){for(n.append(e);!(n.length<s);)if(a===State.ReadHeaderLength){const[e,t]=decode$1(n);n.consume(t),i=o,o+=t,a=State.ReadHeader,s=e}else if(a===State.ReadHeader){const e=decode$y(n.slice(0,s));r&&r(e),n.consume(s),i=o,o+=s,a=State.ReadBlockLength,s=8}else if(a===State.ReadBlockLength){const[e,t]=decode$1(n);n.consume(t),i=o,o+=t,a=State.ReadBlock,s=e}else if(a===State.ReadBlock){const e=i,r=o-i+s;let c;if(i=o,n.get(0)===CIDV0_BYTES.SHA2_256&&n.get(1)===CIDV0_BYTES.LENGTH){c=createLegacy(decode$z(n.subarray(0,34))),n.consume(34),o+=34}else{const[e,t]=decode$1(n);if(1!==e)throw new Error(`unexpected CID version (${e})`);n.consume(t),o+=t;const[r,i]=decode$1(n);n.consume(i),o+=i;const s=getMultihashLength(n);c=create$g(r,decode$z(n.subarray(0,s))),n.consume(s),o+=s}const d=s-(o-i),u=n.subarray(0,d);t.enqueue({cid:c,bytes:u,offset:e,length:r,blockOffset:o,blockLength:d}),n.consume(d),i=o,o+=d,a=State.ReadBlockLength,s=8}},flush(e){a!==State.ReadBlockLength&&e.error(new Error("unexpected end of data"))}},e,t??new CountQueuingStrategy({highWaterMark:1})),this.#f=c}getHeader(){return this.#f}}const getMultihashLength=e=>{const[,t]=decode$1(e),[n,r]=decode$1(e,t);return t+r+n},encodeHeader=e=>{const t=encode$q({version:1,roots:e}),n=encode$1(t.length),r=new Uint8Array(n.length+t.length);return r.set(n,0),r.set(t,n.length),r},encodeBlock=e=>{const t=encode$1(e.cid.bytes.length+e.bytes.length),n=new Uint8Array(t.length+e.cid.bytes.length+e.bytes.length);return n.set(t),n.set(e.cid.bytes,t.length),n.set(e.bytes,t.length+e.cid.bytes.length),n};class CARWriterStream extends TransformStream{constructor(e=[],t,n){super({start:t=>t.enqueue(encodeHeader(e)),transform:(e,t)=>t.enqueue(encodeBlock(e))},t,n)}}async function indexShardedDAG(e,t,n){const r=create$2(e);for(const[e,o]of t.entries()){const t=n[e];r.shards.set(o.multihash,t)}return await r.archive()}const SHARD_SIZE=133169152;class ShardingStream extends TransformStream{constructor(e={}){const t=e.shardSize??SHARD_SIZE,n=t-headerEncodingLength();let r=[],o=null,i=new DigestMap,s=null,a=0;super({async transform(e,t){null!=o&&null!=s&&(t.enqueue(await encodeCAR(o,s)),o=null,s=null);const c=blockHeaderEncodingLength(e),d=c+e.bytes.length;if(d>n)throw new Error(`block will cause CAR to exceed shard size: ${e.cid}`);r.length&&a+d>n&&(o=r,s=i,r=[],i=new DigestMap,a=0),r.push(e),i.set(e.cid.multihash,[headerEncodingLength()+a+c,e.bytes.length]),a+=d},async flush(n){null!=o&&null!=s&&n.enqueue(await encodeCAR(o,s));const c=r.at(-1);if(null==c)return;const d=e.rootCID??c.cid,u=headerEncodingLength(d);if(u+a>t){const e=u+a-t,o=[];let s=0;for(;s<e;){const e=r[r.length-1];if(r.pop(),i.delete(e.cid.multihash),o.unshift(e),s+=blockEncodingLength(e),r.length<1)throw new Error(`block will cause CAR to exceed shard size: ${e.cid}`)}n.enqueue(await encodeCAR(r,i)),s=0;const c=new DigestMap;for(const e of o){const t=blockHeaderEncodingLength(e);c.set(e.cid.multihash,[u+s+t,e.bytes.length]),s+=t+e.bytes.length}n.enqueue(await encodeCAR(o,c,d))}else{const e=u-headerEncodingLength();for(const t of i.values())t[0]+=e;n.enqueue(await encodeCAR(r,i,d))}}})}}const defaultFileComparator=(e,t,n=e=>e.name)=>ascending(e,t,n);function ascending(e,t,n){const r=n(e),o=n(t);return r===o?0:r<o?-1:1}const encodeCAR=async(e,t,n)=>Object.assign(await encode$2(e,n),{slices:t});async function uploadFile(e,t,n={}){return await uploadBlockStream(e,createFileEncoderStream(t,n),n)}async function uploadDirectory(e,t,n={}){const{customOrder:r=!1}=n,o=r?t:[...t].sort(defaultFileComparator);return await uploadBlockStream(e,createDirectoryEncoderStream(o,n),n)}async function uploadCAR(e,t,n={}){const r=new BlockStream(t);return n.rootCID=n.rootCID??(await r.getRoots())[0],await uploadBlockStream(e,r,n)}async function uploadBlockStream(e,t,{pieceHasher:n=PieceHasher,...r}={}){const o="function"==typeof e?e:()=>e,i=[],s=[];let a=null;if(await t.pipeThrough(new ShardingStream(r)).pipeThrough(new TransformStream({async transform(e,t){const i=new Uint8Array(await e.arrayBuffer()),s=await sha256$2.digest(i),a=await o([{can:ability$2,nb:input$8(s,i.length)}]);await add$2(a,s,i,r);const c=create$9(code,s);let d;if(n){const e=await n.digest(i);d=create$9(code$3,e);const t=create$9(code$3,s),o=await filecoinOffer({issuer:a.issuer,audience:a.audience,with:a.issuer.did(),proofs:a.proofs},t,d,r);if(o.out.error)throw new Error("failed to offer piece for aggregation into filecoin deal",{cause:o.out.error})}const{version:u,roots:l,size:h,slices:f}=e;t.enqueue({version:u,roots:l,size:h,cid:c,piece:d,slices:f})}})).pipeTo(new WritableStream({write(e){a=a||e.roots[0],s.push(e.cid),e.slices.set(e.cid.multihash,[0,e.size]),i.push(e.slices),r.onShardStored&&r.onShardStored(e)}})),!a)throw new Error("missing root CID");const c=await indexShardedDAG(a,s,i);if(!c.ok)throw new Error("failed to archive DAG index",{cause:c.error});const d=await sha256$2.digest(c.ok),u=create$9(code,d),[l,h,f]=await Promise.all([o([{can:ability$2,nb:input$8(d,c.ok.length)}]),o([{can:ability$1,nb:input$4(u)}]),o([{can:ability,nb:input$3(a,s)}])]);return await add$2(l,d,c.ok,r),await add$1(h,u,r),await add(f,a,s,r),a}const accessServiceURL=new URL("https://up.web3.storage"),accessServicePrincipal=parse$1("did:web:web3.storage"),accessServiceConnection=connect({id:accessServicePrincipal,codec:outbound,channel:open$2({url:accessServiceURL,method:"POST"})}),uploadServiceURL=new URL("https://up.web3.storage"),uploadServicePrincipal=parse$1("did:web:web3.storage"),uploadServiceConnection=connect({id:uploadServicePrincipal,codec:outbound,channel:open$2({url:uploadServiceURL,method:"POST"})}),filecoinServiceURL=new URL("https://up.web3.storage"),filecoinServicePrincipal=parse$1("did:web:web3.storage"),filecoinServiceConnection=connect({id:filecoinServicePrincipal,codec:outbound,channel:open$2({url:filecoinServiceURL,method:"POST"})}),serviceConf={access:accessServiceConnection,upload:uploadServiceConnection,filecoin:filecoinServiceConnection};class Base{_agent;_serviceConf;constructor(e,t={}){this._serviceConf=t.serviceConf??serviceConf,this._agent=new Agent(e,{servicePrincipal:this._serviceConf.access.id,url:this._serviceConf.access.channel.url,connection:this._serviceConf.access}),this._receiptsEndpoint=t.receiptsEndpoint??receiptsEndpoint}get agent(){return this._agent}async _invocationConfig(e){const t=this._agent.currentSpace();if(!t)throw new Error("missing current space: use createSpace() or setCurrentSpace()");const n=this._agent.issuer,r=await this._agent.proofs(e.map((e=>({can:e,with:t})))),o=this._serviceConf.upload.id;return{issuer:n,with:t,proofs:r,audience:o}}}const unwrap=({ok:e,error:t})=>{if(t)throw t;return e};class AccessClient extends Base{async authorize(e,t){const n=fromEmail(e),r=unwrap(await request(this,{account:n})),o=unwrap(await r.claim(t));return await unwrap(await o.save()),o.proofs}async claim(e){const t=unwrap(await claim(this,e));return await unwrap(await t.save()),t.proofs}async request(e){return await request(this,e)}async delegate(e){return await delegate(this,e)}}const claim=async({agent:e},t)=>claim$1(e,t),request=async({agent:e},t)=>request$2(e,t),delegate=async({agent:e},t)=>delegate$1(e,t),{accountAccess:accountAccess}=access;class PlanClient extends Base{async get(e,t){const n=await get({agent:this.agent},{...t,account:e});if(!n.ok)throw new Error(`failed ${get$c.can} invocation`,{cause:n.error});return n.ok}async set(e,t,n){const r=await set({agent:this.agent},{...n,account:e,product:t});if(!r.ok)throw new Error(`failed ${set$5.can} invocation`,{cause:r.error});return r.ok}async createAdminSession(e,t,n){const r=await createAdminSession({agent:this.agent},{...n,account:e,returnURL:t});if(!r.ok)throw new Error(`failed ${createAdminSession$1.can} invocation`,{cause:r.error});return r.ok}}const get=async({agent:e},{account:t,nonce:n,proofs:r=[]})=>(await e.invokeAndExecute(get$c,{with:t,proofs:r,nonce:n})).out,set=async({agent:e},{account:t,product:n,nonce:r,proofs:o=[]})=>(await e.invokeAndExecute(set$5,{with:t,nb:{product:n},nonce:r,proofs:o})).out,createAdminSession=async({agent:e},{account:t,returnURL:n,nonce:r,proofs:o=[]})=>(await e.invokeAndExecute(createAdminSession$1,{with:t,proofs:o,nonce:r,nb:{returnURL:n}})).out;class SubscriptionClient extends Base{async list(e,t){const n=await list$1({agent:this.agent},{...t,account:e});if(!n.ok)throw new Error(`failed ${list$6.can} invocation`,{cause:n.error});return n.ok}}const list$1=async({agent:e},{account:t,nonce:n,proofs:r=[]})=>(await e.invokeAndExecute(list$6,{with:t,proofs:r,nb:{},nonce:n})).out,list=({agent:e},{account:t}={})=>{const n={with:t??/did:mailto:.*/,can:"*"},r=e.proofs([n]),o={},i={};for(const t of r){const n=allows(t);for(const[r,s]of Object.entries(n)){if(AccountDID.is(r)&&s["*"]){const n=r;(o[n]||(o[n]=new Account({id:n,agent:e,proofs:[]}))).addProof(t)}for(const e of s["ucan/attest"]||[]){const n=e.proof;n&&(i[`${n}`]=t)}}}for(const e of Object.values(o))for(const t of e.proofs){const n=i[`${t.cid}`];n&&e.addProof(n)}return o},login=async({agent:e},t,n={})=>{const r=fromEmail(t),o=list({agent:e},{account:r})[r];if(o)return{ok:o};const i=await request({agent:e},{account:r,access:accountAccess}),{ok:s,error:a}=i;if(a)return{error:a};{const{ok:t,error:o}=await s.claim({signal:n.signal});return o?{error:o}:{ok:new Account({id:r,proofs:t.proofs,agent:e})}}};class Account{constructor(e){this.model=e,this.plan=new AccountPlan(e)}get agent(){return this.model.agent}get proofs(){return this.model.proofs}did(){return this.model.id}toEmail(){return toEmail(this.did())}addProof(e){this.proofs.push(e)}toJSON(){return{id:this.did(),proofs:this.proofs.sort(((e,t)=>e.cid.toString().localeCompare(t.cid.toString()))).map((e=>e.toJSON()))}}provision(e,t={}){return add$7(this.agent,{...t,account:this.did(),consumer:e,proofs:this.proofs})}async save({agent:e=this.agent}={}){return await importAuthorization(e,this)}}class AccountPlan{constructor(e){this.model=e}async get(e){return await get(this.model,{...e,account:this.model.id,proofs:this.model.proofs})}async set(e,t){return await set(this.model,{...t,account:this.model.id,product:e,proofs:this.model.proofs})}async wait(e){const t=Date.now(),n=e?.interval||1e3,r=e?.timeout||9e5;for(;;){const o=await this.get();if(o.ok)return o.ok;if(o.error)throw new Error(`Error retrieving payment plan: ${o.error}`);if(Date.now()-t>r)throw new Error("Timeout: Payment plan selection took too long.");if(e?.signal?.aborted)throw new Error("Aborted: Payment plan selection was aborted.");console.log("Waiting for payment plan to be selected..."),await new Promise((e=>setTimeout(e,n)))}}async createAdminSession(e,t,n){return await createAdminSession(this.model,{...n,account:e,returnURL:t})}async subscriptions(e){return await list$1(this.model,{...e,account:this.model.id,proofs:this.model.proofs})}}class UsageClient extends Base{async report(e,t,n){const r=await report({agent:this.agent},{...n,space:e,period:t});if(!r.ok)throw new Error(`failed ${report$1.can} invocation`,{cause:r.error});return r.ok}}const report=async({agent:e},{space:t,period:n,nonce:r,proofs:o=[]})=>(await e.invokeAndExecute(report$1,{with:t,proofs:o,nonce:r,nb:{period:{from:Math.floor(n.from.getTime()/1e3),to:Math.ceil(n.to.getTime()/1e3)}}})).out;class Space{#p;constructor(e){this.#p=e,this.usage=new StorageUsage(e)}get name(){return String(this.#p.meta?.name??"")}did(){return this.#p.id}meta(){return this.#p.meta}}class StorageUsage{#p;constructor(e){this.#p=e}async get(){const{agent:e}=this.#p,t=this.#p.id,n=new Date,r={from:startOfLastMonth(n),to:n},o=await report({agent:e},{space:t,period:r});if(o.error)return o;const i=e.connection.id.did(),s=o.ok[i];return{ok:null==s?.size.final?void 0:BigInt(s.size.final)}}}const startOfMonth=e=>{const t=new Date(e);return t.setUTCDate(1),t.setUTCHours(0),t.setUTCMinutes(0),t.setUTCSeconds(0),t.setUTCMilliseconds(0),t},startOfLastMonth=e=>{const t=startOfMonth(e);return t.setUTCMonth(t.getUTCMonth()-1),t};class AgentDelegation extends Delegation{#y;constructor(e,t,n={}){super(e,t),this.#y=n}meta(){return this.#y}}var encode_1=encode,MSB=128,MSBALL=-128,INT=Math.pow(2,31);function encode(e,t,n){t=t||[];for(var r=n=n||0;e>=INT;)t[n++]=255&e|MSB,e/=128;for(;e&MSBALL;)t[n++]=255&e|MSB,e>>>=7;return t[n]=0|e,encode.bytes=n-r+1,t}var decode=read,MSB$1=128,REST$1=127;function read(e,t){var n,r=0,o=0,i=t=t||0,s=e.length;do{if(i>=s)throw read.bytes=0,new RangeError("Could not decode varint");n=e[i++],r+=o<28?(n&REST$1)<<o:(n&REST$1)*Math.pow(2,o),o+=7}while(n>=MSB$1);return read.bytes=i-t,r}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(e){return e<N1?1:e<N2?2:e<N3?3:e<N4?4:e<N5?5:e<N6?6:e<N7?7:e<N8?8:e<N9?9:10},varint={encode:encode_1,decode:decode,encodingLength:length},_brrp_varint=varint;const encodeTo=(e,t,n=0)=>(_brrp_varint.encode(e,t,n),t),encodingLength=e=>_brrp_varint.encodingLength(e),create$1=(e,t)=>{const n=t.byteLength,r=encodingLength(e),o=r+encodingLength(n),i=new Uint8Array(o+n);return encodeTo(e,i,0),encodeTo(n,i,r),i.set(t,o),new Digest(e,n,t,i)};class Digest{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const from=({name:e,code:t,encode:n})=>new Hasher(e,t,n);class Hasher{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?create$1(this.code,t):t.then((e=>create$1(this.code,e)))}throw Error("Unknown type, must be binary type")}}const sha=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),sha256=from({name:"sha2-256",code:18,encode:sha("SHA-256")});class BlobClient extends Base{async add(e,t={}){t={receiptsEndpoint:this._receiptsEndpoint.toString(),connection:this._serviceConf.upload,...t};const n=await this._invocationConfig([add$4.can]),r=new Uint8Array(await e.arrayBuffer()),o=await sha256.digest(r);return{digest:o,...await add$2(n,o,r,t)}}async list(e={}){const t=await this._invocationConfig([list$5.can]);return e.connection=this._serviceConf.upload,list$3(t,e)}async remove(e,t={}){const n=await this._invocationConfig([remove$5.can]);return t.connection=this._serviceConf.upload,remove$3(n,e,t)}async get(e,t={}){const n=await this._invocationConfig([get$b.can]);return t.connection=this._serviceConf.upload,get$8(n,e,t)}}class IndexClient extends Base{async add(e,t={}){const n=await this._invocationConfig([add$5.can]);return t.connection=this._serviceConf.upload,add$1(n,e,t)}}class StoreClient extends Base{async add(e,t={}){const n=await this._invocationConfig([add$a.can]);return t.connection=this._serviceConf.upload,add$3(n,e,t)}async get(e,t={}){const n=await this._invocationConfig([get$h.can]);return t.connection=this._serviceConf.upload,get$a(n,e,t)}async list(e={}){const t=await this._invocationConfig([list$9.can]);return e.connection=this._serviceConf.upload,list$4(t,e)}async remove(e,t={}){const n=await this._invocationConfig([remove$8.can]);return t.connection=this._serviceConf.upload,remove$4(n,e,t)}}class UploadClient extends Base{async add(e,t,n={}){const r=await this._invocationConfig([add$9.can]);return n.connection=this._serviceConf.upload,add(r,e,t,n)}async get(e,t={}){const n=await this._invocationConfig([get$g.can]);return t.connection=this._serviceConf.upload,get$7(n,e,t)}async list(e={}){const t=await this._invocationConfig([list$8.can]);return e.connection=this._serviceConf.upload,list$2(t,e)}async remove(e,t={}){const n=await this._invocationConfig([remove$7.can]);return t.connection=this._serviceConf.upload,remove$2(n,e,t)}}class SpaceClient extends Base{async info(e,t){return await this._agent.getSpaceInfo(e,t)}async egressRecord(e,t){const n=await egressRecord({agent:this.agent},{...e},{...t});if(!n.ok)throw new Error(`failed ${egressRecord$1.can} invocation`,{cause:n.error});return n.ok}}const egressRecord=async({agent:e},{space:t,resource:n,bytes:r,servedAt:o},{nonce:i,proofs:s=[]})=>(await e.invokeAndExecute(egressRecord$1,{with:t,proofs:s,nonce:i,nb:{resource:n,bytes:r,servedAt:Math.floor(new Date(o).getTime()/1e3)}})).out;class FilecoinClient extends Base{async offer(e,t,n){return filecoinOffer(await this._invocationConfig([filecoinOffer$1.can]),e,t,{...n,connection:this._serviceConf.filecoin})}async info(e,t){return filecoinInfo(await this._invocationConfig([filecoinInfo$1.can]),e,{...t,connection:this._serviceConf.filecoin})}}class CouponAPI extends Base{async redeem(e,t={}){const{agent:n}=this,r=unwrap(await extract(e));return unwrap(await redeem(r,{...t,agent:n}))}async issue({proofs:e=[],...t}){const{agent:n}=this;return await issue({...t,issuer:n.issuer,proofs:[...e,...n.proofs(t.capabilities)]})}}const extract=async e=>{const{ok:t,error:n}=await extract$1(e);return t?ok(new Coupon({proofs:[t]})):error$1(n)},archive=async e=>{const[t]=e.proofs;return await archive$2(t)},issue=async({password:e="",...t})=>{const n=await deriveSigner(e),r=await delegate$3({...t,audience:n});return new Coupon({proofs:[r]})},redeem=async(e,{agent:t,password:n=""})=>{const r=await deriveSigner(n),[o]=e.proofs;if(o.audience.did()!==r.did())return error$1(new RangeError(""===n?"Extracting account requires a password":"Provided password is invalid"));{const e=await delegate$3({issuer:r,audience:t,capabilities:o.capabilities,expiration:o.expiration,notBefore:o.notBefore,proofs:[o]});return ok(new GrantedAccess({agent:t,proofs:[e]}))}},deriveSigner=async e=>{const{digest:t}=await sha256$4.digest((new TextEncoder).encode(e));return await derive(t)};class Coupon{constructor(e){this.model=e}get proofs(){return this.model.proofs}redeem(e,t={}){return redeem(this,{...t,agent:e})}archive(){return archive(this)}}class Client extends Base{constructor(e,t){super(e,t),this.capability={access:new AccessClient(e,t),filecoin:new FilecoinClient(e,t),index:new IndexClient(e,t),plan:new PlanClient(e,t),space:new SpaceClient(e,t),blob:new BlobClient(e,t),store:new StoreClient(e,t),subscription:new SubscriptionClient(e,t),upload:new UploadClient(e,t),usage:new UsageClient(e,t)},this.coupon=new CouponAPI(e,t)}did(){return this._agent.did()}async authorize(e,t){await this.capability.access.authorize(e,t)}async login(e,t={}){const n=unwrap(await login(this,e,t));return unwrap(await n.save()),n}accounts(){return list(this)}async uploadFile(e,t={}){return uploadFile(await this._invocationConfig([add$4.can,add$5.can,filecoinOffer$1.can,add$9.can]),e,t={receiptsEndpoint:this._receiptsEndpoint.toString(),connection:this._serviceConf.upload,...t})}async uploadDirectory(e,t={}){return uploadDirectory(await this._invocationConfig([add$4.can,add$5.can,filecoinOffer$1.can,add$9.can]),e,t={receiptsEndpoint:this._receiptsEndpoint.toString(),connection:this._serviceConf.upload,...t})}async uploadCAR(e,t={}){return uploadCAR(await this._invocationConfig([add$4.can,add$5.can,filecoinOffer$1.can,add$9.can]),e,t={receiptsEndpoint:this._receiptsEndpoint.toString(),connection:this._serviceConf.upload,...t})}async getReceipt(e){return poll(e,{receiptsEndpoint:new URL(this._receiptsEndpoint).toString()})}defaultProvider(){return this._agent.connection.id.did()}currentSpace(){const e=this._agent,t=e.currentSpace();if(!t)return;const n=e.spaces.get(t);return new Space({id:t,meta:n,agent:e})}async setCurrentSpace(e){await this._agent.setCurrentSpace(e)}spaces(){return[...this._agent.spaces].map((([e,t])=>new Space({id:e,meta:t,agent:this._agent})))}async createSpace(e,t){const n=await this._agent.createSpace(e),r=t?.account;if(r){const e=await r.provision(n.did());if(e.error)throw new Error(`failed to provision account: ${e.error.message}`,{cause:e.error});await n.save();const t=await n.createRecovery(r.did()),o=await this.capability.access.delegate({space:n.did(),delegations:[t]});if(o.error)throw new Error(`failed to authorize recovery account: ${o.error.message}`,{cause:o.error})}if(!0!==t?.skipGatewayAuthorization){let e=t?.authorizeGatewayServices;e&&0!==e.length||(e=[connect({id:{did:()=>process.env.DEFAULT_GATEWAY_ID??"did:web:w3s.link"},codec:outbound,channel:open$2({url:new URL(process.env.DEFAULT_GATEWAY_URL??"https://w3s.link")})})]),await n.save();for(const t of e)await authorizeContentServe(this,n,t)}return n}async shareSpace(e,t,n={abilities:["space/*","store/*","upload/*","access/*","usage/*","filecoin/*"],expiration:1/0}){const{abilities:r,...o}=n,i=this.agent.currentSpace();try{await this.agent.setCurrentSpace(t);const{root:i,blocks:s}=await this.agent.delegate({...o,abilities:r,audience:{did:()=>fromEmail(email(e))},audienceMeta:n.audienceMeta??{}}),a=new AgentDelegation(i,s,{audience:e}),c=await this.capability.access.delegate({space:t,delegations:[a]});if(c.error)throw new Error(`failed to share space with ${e}: ${c.error.message}`,{cause:c.error});return a}finally{i&&i!==t&&await this.agent.setCurrentSpace(i)}}async addSpace(e){return await this._agent.importSpaceFromDelegation(e)}proofs(e){return this._agent.proofs(e)}async addProof(e){await this._agent.addProof(e)}delegations(e){const t=[];for(const{delegation:n,meta:r}of this._agent.delegationsWithMeta(e))t.push(new AgentDelegation(n.root,n.blocks,r));return t}async createDelegation(e,t,n={}){const r=n.audienceMeta??{name:"agent",type:"device"},{root:o,blocks:i}=await this._agent.delegate({...n,abilities:t,audience:e,audienceMeta:r});return new AgentDelegation(o,i,{audience:r})}async revokeDelegation(e,t={}){return this._agent.revoke(e,{proofs:t.proofs})}async remove(e,t={}){if(!t.shards)return void await this.capability.upload.remove(e);const n=await this.capability.upload.get(e);n.shards?.length&&await Promise.allSettled(n.shards.map((async e=>{try{const t=await this.capability.blob.remove(e.multihash);t.ok&&0===t.ok.size&&await this.capability.store.remove(e)}catch(t){if("StoreItemNotFound"!==t?.cause?.name)throw new Error(`failed to remove shard: ${e}`,{cause:t})}}))),await this.capability.upload.remove(e)}}const authorizeContentServe=async(e,t,n,r={})=>{const o=e.currentSpace();try{await e.setCurrentSpace(t.did());const o={did:()=>r.audience??n.id.did()},i=await e.createDelegation(o,[contentServe.can],{expiration:r.expiration??1/0}),s=e.proofs([{can:access$1.can,with:t.did()}]),a=await delegate$2.invoke({issuer:e.agent.issuer,audience:o,with:t.did(),proofs:[...s,i],nb:{delegations:{[i.cid.toString()]:i.cid}}}).execute(n);if(a.out.error)throw new Error(`failed to publish delegation for audience ${o.did()}: ${a.out.error.message}`,{cause:a.out.error});return{ok:{...a.out.ok,delegation:i}}}finally{o&&await e.setCurrentSpace(o.did())}};async function create(e={}){const t=e.store??new StoreIndexedDB("w3up-client"),n=await t.load();if(n){const r=AgentData.fromExport(n,{store:t});if(e.principal&&r.principal.did()!==e.principal.did())throw new Error(`store cannot be used with ${e.principal.did()}, stored principal and passed principal must match`);return new Client(r,e)}const r=e.principal??await generate(),o=await AgentData.create({principal:r},{store:t});return new Client(o,e)}async function createW3Client(){try{return await create()}catch(e){throw console.error("Error creating W3 client:",e),e}}async function authenticateWithEmail(e,t){try{return await e.login(t),{success:!0,email:t}}catch(e){return console.error("Authentication error:",e),{success:!1,email:t}}}async function storeContent(e,t){try{let n;if(t instanceof Blob)n=t;else if("string"==typeof t)n=new Blob([t],{type:"text/plain"});else{const e=JSON.stringify(t);n=new Blob([e],{type:"application/json"})}return{success:!0,cid:(await e.uploadBlob(n)).toString()}}catch(e){return console.error("Storage error:",e),{success:!1,cid:null}}}async function listUploads(e){try{const t=await e.currentSpace();return await e.capability.store.list({space:t.did()})}catch(e){throw console.error("Error listing uploads:",e),e}}new Set(abilitiesAsStrings);const w3Storage={create:createW3Client,authenticate:authenticateWithEmail,store:storeContent,list:listUploads};export{authenticateWithEmail,createW3Client,w3Storage as default,listUploads,storeContent,w3Storage};
